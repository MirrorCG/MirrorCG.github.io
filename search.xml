<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Maya中创建UI</title>
      <link href="/posts/20220823a1.html"/>
      <url>/posts/20220823a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在maya中创建各种UI<span id="more"></span></p><h4 id="创建主菜单和菜单项："><a href="#创建主菜单和菜单项：" class="headerlink" title="创建主菜单和菜单项："></a>创建主菜单和菜单项：</h4><p>menuItem() 若不指定父级,都默认将菜单项添加到上一个创建的菜单中。</p><p><img src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E4%B8%BB%E8%8F%9C%E5%8D%95%E8%8F%9C%E5%8D%95%E9%A1%B9.png" alt="主菜单菜单项.png" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E4%B8%BB%E8%8F%9C%E5%8D%95%E8%8F%9C%E5%8D%95%E9%A1%B9.png" class="lozad post-image"></p><p>示例代码：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds cmds.menu( &quot;test&quot;,label&#x3D;&#39;流程框架&#39;, tearOff&#x3D;True,parent&#x3D;&quot;MayaWindow&quot; )cmds.menuItem( label&#x3D;&#39;New&#39; )cmds.menuItem( label&#x3D;&#39;Open&#39; )cmds.menuItem( label&#x3D;&#39;Save&#39; )cmds.menuItem( divider&#x3D;True )  # 分隔线cmds.menuItem( label&#x3D;&#39;print&#39;,c&#x3D;&quot;print(11111)&quot; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建菜单集"><a href="#创建菜单集" class="headerlink" title="创建菜单集"></a>创建菜单集</h4><p>菜单集中的菜单项来自于上面创建的主菜单，因此需要有菜单项才能添加和显示菜单集。空的菜单集不在菜单集的下拉框中显示，因此菜单集下至少应该拥有一项菜单项。</p><p><img src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E8%8F%9C%E5%8D%95%E9%9B%86.png" alt="菜单集.png" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E8%8F%9C%E5%8D%95%E9%9B%86.png" class="lozad post-image"></p><p>示例代码：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds cmds.menuSet( &#39;testSet&#39;, label&#x3D;&#39;testSetLabel&#39; )  # 创建菜单集,不指定标签，显示为空行cmds.menuSet(am&#x3D;&quot;mainKeysMenu&quot;)  # 从当前菜单添加cmds.menuSet(cms&#x3D;1,q&#x3D;1 ) #  设置当前激活的菜单，只是激活，不刷新显示cmds.menuSet (ams&#x3D;True,q&#x3D;True)  # 所有的菜单集cmds.menuSet(rm&#x3D;&quot;mainKeysMenu&quot;)  # 从当前菜单移除currentmenus &#x3D; cmds.menuSet(query&#x3D;True, menuArray&#x3D;True)  # 查询当前流单集中所有的菜单项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建状态栏菜单"><a href="#创建状态栏菜单" class="headerlink" title="创建状态栏菜单"></a>创建状态栏菜单</h4><p>状态行只需要为控件指定父级窗口为”statusFieldButton”即可。</p><p><img src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E7%8A%B6%E6%80%81%E6%A0%8F.png" alt="状态栏.png" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E7%8A%B6%E6%80%81%E6%A0%8F.png" class="lozad post-image">  </p><p>示例代码：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds cmds.iconTextButton(&quot;状态行名称1&quot;,l&#x3D;&quot;标签1&quot;,style&#x3D;&quot;textOnly&quot;,al&#x3D;&#39;center&#39;,p&#x3D;cmds.iconTextButton(&quot;statusFieldButton&quot;,q&#x3D;1,p&#x3D;1))cmds.button(&quot;状态行名称2&quot;,l&#x3D;&quot;标签2&quot;,al&#x3D;&#39;center&#39;,p&#x3D;cmds.iconTextButton(&quot;statusFieldButton&quot;,q&#x3D;1,p&#x3D;1))cmds.nodeIconButton(&quot;状态行名称3&quot;, label&#x3D;&quot;标签3&quot; , style&#x3D;&#39;iconAndTextHorizontal&#39;, command&#x3D;&#39;cmds.spotLight()&#39;, image1&#x3D;&#39;spotlight.png&#39;,p&#x3D;cmds.iconTextButton(&quot;statusFieldButton&quot;,q&#x3D;1,p&#x3D;1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建侧栏工具页"><a href="#创建侧栏工具页" class="headerlink" title="创建侧栏工具页"></a>创建侧栏工具页</h4><p>侧栏工具页通过 toolBar 控件生成，创建后可指定吸附到边界上。</p><p><img src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E4%BE%A7%E6%A0%8F%E5%B7%A5%E5%85%B7%E9%A1%B5.png" alt="侧栏工具页.png" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E4%BE%A7%E6%A0%8F%E5%B7%A5%E5%85%B7%E9%A1%B5.png" class="lozad post-image">  </p><p>示例代码：<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds myWindow&#x3D;cmds.window()buttonForm &#x3D; cmds.formLayout( parent &#x3D; myWindow)cmds.button( parent &#x3D; buttonForm,l&#x3D;&quot;testSide&quot;)cmds.toolBar( area&#x3D;&#39;top&#39;, content&#x3D;myWindow, allowedArea&#x3D;[&#39;top&#39;, &#39;bottom&#39;, &quot;left&quot;, &quot;right&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="创建工具架分页："><a href="#创建工具架分页：" class="headerlink" title="创建工具架分页："></a>创建工具架分页：</h4><p>工具架分页由cmds.shelfLayout()创建，将创建的工具架分页的父级指向shelf主窗口，然后在shelfLayout下创建工具按钮即可：</p><p><img src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E5%B7%A5%E5%85%B7%E6%9E%B6%E5%88%86%E9%A1%B5.png" alt="工具架分页.png" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E5%B7%A5%E5%85%B7%E6%9E%B6%E5%88%86%E9%A1%B5.png" class="lozad post-image">  </p><p>示例代码：<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.mel as mmimport maya.cmds as cmdsmainTopShelfTab &#x3D; mm.eval(&#39;global string $gShelfTopLevel;string $a&#x3D;$gShelfTopLevel;&#39;)# 获取工具架顶级布局newShelfLayout &#x3D; cmds.shelfLayout(&quot;NewLayout&quot;,p&#x3D;mainTopShelfTab)  # 创建工具架分页newToolButton &#x3D; cmds.shelfButton(&quot;testShelf&quot;,docTag&#x3D;u&quot;测试工具&quot;,rpt&#x3D;1,l&#x3D;&quot;工具&quot;,i1 &#x3D; r&quot;S:&#x2F;icon&#x2F;TDtool.ico&quot;,iol&#x3D;&quot;工具&quot;,c&#x3D;&#39;print(u&quot;测试&quot;)&#39;,p&#x3D;newShelfLayout)  # 添加工具按钮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>一些常用代码：<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">mainTopShelfTab &#x3D; mm.eval(&#39;global string $gShelfTopLevel;string $a&#x3D;$gShelfTopLevel;&#39;)  # 获取工具架顶级布局shelfnum &#x3D; cmds.shelfTabLayout(mainTopShelfTab,q&#x3D;1,numberOfChildren&#x3D;1)  # 获取指定工具架窗口的工具数量shelfTools &#x3D; cmds.shelfTabLayout(mainTopShelfTab,q&#x3D;1,ca&#x3D;1) # 获取工具架上所有工具栏shelf_fullname &#x3D; cmds.shelfLayout(shelfTool[2],q &#x3D; 1,fpn &#x3D; 1)  # 获取指定名称的工具架全路径shelfVisible &#x3D; cmds.shelfButton(&quot;testShelf&quot;,e&#x3D;1,visible&#x3D;0) # 设置工具按钮可见性maya.mel.eval(&#39;addNewShelfTab &quot;test&quot;&#39;)  # 添加指定名称工具架页maya.mel.eval(&#39;deleteShelfTab &quot;test&quot;&#39;)  #删除指定个名称工具架<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>从maya文档中加载默认工具架及其按钮：<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">#注意此脚本会将一部分默认不加载的工具架也加载到maya工具架下 def get_shelf():  &quot;&quot;&quot;获取maya安装目录下shelf&quot;&quot;&quot;  shelf_files &#x3D; []  maya_shelf_path &#x3D; &#39;&#123;&#125;&#x2F;scripts&#x2F;shelves&#39;.format(os.getenv(&#39;MAYA_LOCATION&#39;))  files &#x3D; os.listdir( maya_shelf_path)  if files:      for _file in files:          if &quot;_&quot; in _file and &quot;.&quot; in _file and &quot;.res.&quot; not in _file:              shelf_files.append(_file.split(&#39;.&#39;)[0].split(&#39;_&#39;)[-1])  return shelf_filesdef load_shelf():  &quot;&quot;&quot;加载maya默认shelf&quot;&quot;&quot;  allShelfs &#x3D; mel.eval(&#39;shelfTabLayout -q -childArray $gShelfTopLevel&#39;) # 获取maya默认shelfs  maya_files &#x3D; get_shelf()  if maya_files:      for _shelf in maya_files:          if _shelf not in allShelfs:              mel.eval(&#39;loadNewShelf &quot;shelf_&#123;&#125;.mel&quot;;&#39;.format(_shelf))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>循环删除指定工具架下的按钮：<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">def remove button (self,shelf):    &quot;&quot;&quot;批量删除指定工具架下的工具&quot;&quot;&quot;&quot;    shelf_fullname &#x3D; cmds.shelfLayout (&quot;shelfname&quot;,q&#x3D;1,fpn&#x3D;1)   buttons &#x3D; cmds.shelfLayout(shelf_fullname,q &#x3D; 1,ca &#x3D; 1)    for _button in buttons:        button_fullname &#x3D; cmds.shelfButton(_button,q &#x3D;1,fpn &#x3D;1)        cmds.deleteUI( button_fullname)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>删除指定的工具架，方法改自deleteShelfTab，会删除一些首选项中存储的变量：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import osimport maya.cmds as cmdsimport maya.mel as mm def remove_shelf(_shelfname):    mainTopShelfTab &#x3D; mm.eval(&#39;global string $gShelfTopLevel;string $a&#x3D;$gShelfTopLevel;&#39;)    shelf_info &#x3D; &#123;i: _shelf for i, _shelf in enumerate(cmds.shelfTabLayout(mainTopShelfTab, q&#x3D;1, ca&#x3D;1))                   if _shelf.split(&quot;|&quot;)[-1].startswith(_shelfname[:2])&#125;    shelfnum&#x3D; cmds.shelfTabLayout(mainTopShelfTab, q&#x3D;1, numberofChildren&#x3D;1)    if shelf_info:        for _k,_v in shelf_info.items():            if _v &#x3D;&#x3D; _shelfname:                shelf_fullname &#x3D; cmds.shelfLayout(_v, q&#x3D;1, fpn&#x3D;1)                for _i in range(shelfnum):                    _align_c &#x3D; &quot;left&quot;                    if cmds.optionVar(ex&#x3D;&quot;shelfAlign&#123;&#125;&quot;.format(_i+1)):                        _align_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfAlign&#123;&#125;&quot;.format(_i+1))                    _shelfload_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfLoad&#123;&#125;&quot;.format(_i+1))                    _shelfname_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfName&#123;&#125;&quot;.format(_i+1))                    _shelffile_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfFile&#123;&#125;&quot;.format(_i+1))                    cmds.optionVar(                        iv&#x3D;(&quot;shelfLoad&#123;&#125;&quot;.format(_i+1), _shelfload_c),                        sv&#x3D;[(&quot;shelfAlign&#123;&#125;&quot;.format(_i+1), _align_c),                            (&quot;shelfName&#123;&#125;&quot;.format(_i+1), _shelfname_c),                            (&quot;shelfFile&#123;&#125;&quot;.format(_i+1), _shelffile_c)                            ])                cmds.optionVar(remove &#x3D;[&quot;shelfLoad&#123;&#125;&quot;.format(_k),                                        &quot;shelfAlign&#123;&#125;&quot;.format(_k),                                        &quot;shelfName&#123;&#125;&quot;.format(_k),                                        &quot;shelfFile&#123;&#125;&quot;.format(_k)                                        ])                cmds.deleteUI(shelf_fullname, layout&#x3D;1)                shelfDir &#x3D; cmds.internalVar(ush&#x3D;1)                shelfFile &#x3D; os.path.join(shelfDir, &quot;shelf_&#123;&#125;.mel&quot;.format(_v))                if os.path.exists(shelfFile):                    os.remove(shelfFile)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除UI"><a href="#删除UI" class="headerlink" title="删除UI"></a>删除UI</h4><p>删除UI需要知道窗口的窗口名称：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds cmds.deleteUI(&quot;windowName&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> QT事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python代码中的字符编码</title>
      <link href="/posts/20220822a1.html"/>
      <url>/posts/20220822a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Python 中的字符编码 <span id="more"></span></p><h4 id="文本编辑器存储信息的过程"><a href="#文本编辑器存储信息的过程" class="headerlink" title="文本编辑器存储信息的过程"></a>文本编辑器存储信息的过程</h4><ol><li><p>打开编辑器就在内存中开辟了一个空间，用编辑器编写的内容暂存在内存中，断电会丢失。</p></li><li><p>保存时，编辑器把内存的Unicode数据通过某种编码格式存到了硬盘上。</p></li><li><p>编写.py文件（没有执行时）和编写其他文件没有区别，只是在写一堆字符。</p></li></ol><h4 id="python解释器解释python代码的流程"><a href="#python解释器解释python代码的流程" class="headerlink" title="python解释器解释python代码的流程"></a>python解释器解释python代码的流程</h4><ol><li><p>python解释器启动，相当于启动了一个文本编辑器。</p></li><li><p>python解释器相当于文本编辑器，打开test.py文件，从硬盘将test.py文件通过某种编码格式（gbk,utf8等）解码数据从硬盘读入到内存中（python的解释性决定了解释器只关心文件的内容，不关心文件的后缀）。</p></li><li><p>python解释器解释执行加载到内存中的test.py代码。在该阶段才会识别python语法，为变量值等开辟存储空间。</p></li></ol><h4 id="Python2和Python3的区别"><a href="#Python2和Python3的区别" class="headerlink" title="Python2和Python3的区别"></a>Python2和Python3的区别</h4><ol><li><p>python2有两种存储形式，第一种：Unicode；第二种：按coding头选择存储格式，假设python2用utf8存储 x&#x3D;’中文’，当你print(x)的时候，终端接收gbk的变量x，但是windows终端编码是utf8，会乱码。Python3 默认存储形式为utf-8。</p></li><li><p>字符串类型：Python2 unicode 和 str类型（gbk、utf-8、MP4、MP3、JPG）；Python3 str（Unicode字符串）和bytes类型（（gbk、utf-8、MP4、MP3、JPG））。</p></li><li><p>python3只有Unicode一种存储变量的形式。Python2中默认使用ascii，Python3中默认使用utf-8，部分文本编辑器编写的文件默认为gbk编码格式，需要注意编写代码时文本编辑器的默认编码格式。</p></li><li><p>Python2 解释器编码默认为ASCII，只能处理 ascii字符，如果代码中有中文会报错，所以需要在代码顶部添加下面一行声明，将代码文件编码声明修改为 utf-8。Python3 解释器默认编码为utf-8;可通过 sys.getdefaultencoding() 查询。</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-print(u&quot;测试中文打印&quot;.encode(&quot;gbk&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h4 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h4><p>  当字符串第一次写入文件时，文件创建成功，文件编码和字符串编码保持一致。如果后续写入其他编码的字符串，则文件编码会被修改，原来的数据会出现乱码。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>python bytes 也称字节序列，并非字符。取值范围 0 &lt;&#x3D; bytes &lt;&#x3D; 255，输出的时候最前面会有字符b修饰；string 是python中字符串类型;</p></li><li><p>bytes主要是给在计算机看的，string主要是给人看的；string经过编码encode，转化成二进制对象，给计算机识别；bytes经过解码decode，转化成string，让我们看，但是注意反编码的编码规则是有范围,\xc8就不是utf8识别的范围；</p></li><li><p>内存中固定使用Unicode编码，我们只能改变存储到硬盘时使用的编码格式。读文件时，读取文件采用的编码格式与文本原来的编码格式不同则会导致出现乱码。需注意文本编辑器的编码格式，这能直接影响编译器是否能正确编译程序文本文件。同时也要注意控制台的编码格式，其中Windows 默认的编码格式为gbk，因此某些字符需要转码后打印在控制台才不会是乱码：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-print(u&quot;测试中文打印&quot;.encode(&quot;gbk&quot;))print(unicode(&quot;测试中文打印&quot;，&quot;utf-8&quot;).encode(&quot;gbk&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>任何语言、任何操作系统、任何编码，都可以和Unicode编码通过decode()和encode()的方式互相转换。</p></li></ol><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><a href="https://www.cnblogs.com/yyxayz/p/4044528.html" title="" target="">1.Python的字符编码问题</a></br><a href="https://www.runoob.com/python3/python3-func-bytes.html" title="" target="">2.bytes()内建函数</a>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 锦囊小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua脚本语言</title>
      <link href="/posts/20220821a2.html"/>
      <url>/posts/20220821a2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">脚本语言--Lua学习笔记。<span id="more"></span></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>菜鸟教程：<a href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Doc </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yeti毛发</title>
      <link href="/posts/20220821a1.html"/>
      <url>/posts/20220821a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了一些Maya中Yeti毛发的相关的问题：<span id="more"></span></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>对应的版本: yeti插件版本需要与arnold(或redshift渲染器)版本、maya版本相对应，否则不报错且无法使用</p></li><li><p>环境变量：需在 pgYetiMaya.mod写入环境变量的文件(一行一句)。C:\rlm\yeti.lic 为破解文件。</p><ul><li><ul><li>pgYetiMaya 3.6.0 C:\Yeti-v3.6.0_Maya2018-windows</li></ul></li><li>PATH +:&#x3D; bin</li><li>MTOA_EXTENSIONS_PATH +:&#x3D; plug-ins</li><li>ARNOLD_PLUGIN_PATH +:&#x3D; bin</li><li>YETI_DOCS +:&#x3D; docs</li><li>YETI_TMP &#x3D; C:\Yeti-v3.6.0_Maya2018-windows\tmp</li><li>PEREGRINE_LOG_FILE &#x3D; C:\Yeti-v3.6.0_Maya2018-windows\Yeti.log</li><li>YETI_GEOCACHE_SIZE &#x3D; 1024</li><li>YETI_TEXTURECACHE_SIZE &#x3D; 1024</li><li>YETI_HOME &#x3D; C:\Yeti-v3.6.0_Maya2018-windows</li><li>peregrinel_LICENSE &#x3D; C:\rlm\yeti.lic</li></ul></li><li><p>破解：yeti破解文件或通过rlm服务器破解</p></li></ul><h3 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h3><ol><li>yeti 与Arnold版本不匹配，需要下载相对应的各插件版本，具体参考yeti官网文档</li><li>yeti安装后未破解，打开yeti graph editer时会提示没有许可或工具不显示</li><li>yeti破解后没有成功建立和渲染器的链接，需要在上述对应的.mod文件中写入环境变量,成功写入环境变量后即可渲染</li><li>yeti插件与渲染器成功建立来链接后，开启Maya可能会出现.dll文件的报错没然后Maya卡死，该问题是maya环境中没有找到.dll与对应的渲染器，可能是没有安装，删除yeti安装目录文件夹bin下对应的.dll即可</li><li>渲染没有毛发：渲染器和yeti插件的链接没有接上。没有指定Yeti毛发缓存的存放路径YETI_TMP</li><li>“pgYetiMaya.mod”文件中不能有空行</li></ol><h3 id="制作和渲染问题"><a href="#制作和渲染问题" class="headerlink" title="制作和渲染问题"></a>制作和渲染问题</h3><ol><li><p>pgYetiPreRender:此代码用于指定yeti渲染前产生的yeti缓存文件存放位置，渲染时直接调用此路径下的.fur文件，若不在Maya渲染射中的中preRenderMel选项中填入此代码，则渲染器找不到生成的缓存，渲染失败。低版本中，此代码不会自动写入和自动清除，高版本会判定场景中是否存在相关yeti节点，然后自动写入或清除。</p></li><li><p>yeti毛发取消缓存(将input Mode 设置为None)，需要保存后重开文件，才能正常渲染出毛发。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yeti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShotGrid的API使用示例</title>
      <link href="/posts/20220814a1.html"/>
      <url>/posts/20220814a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">本文为 ShotGrid 的 Python API 学习笔记。<span id="more"></span></p><h3 id="注册网站"><a href="#注册网站" class="headerlink" title="注册网站"></a>注册网站</h3><p>如果已经有了自己可操作的 ShotGrid 网站页面，就直接开始吧。没有的话需要在 Autodesk 官网下找到<a href="https://www.shotgridsoftware.com/trial/" title="" target="">ShotGrid 注册</a>自己的 ShotGrid 网站页面，设置邮箱和电话号码后，获取登录账户和密码（可以获得30天的试用时间），就可以开始下面的操作了。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h5 id="最低要求"><a href="#最低要求" class="headerlink" title="最低要求"></a>最低要求</h5><ul><li>Python 2.7 或 Python 3.7</li></ul><h5 id="下载并写入Python搜索路径"><a href="#下载并写入Python搜索路径" class="headerlink" title="下载并写入Python搜索路径"></a>下载并写入Python搜索路径</h5><ul><li>手动下载<ul><li>下载 PythonAPI 库到本地：<a href="https://github.com/shotgunsoftware/python-api/releases" title="" target="">从这下载</a>最新版本到本地。</li><li>将下载的 PythonAPI 加入到 PYTHONPATH 环境变量中，用于我们在代码中可搜索到对应的模块。</li></ul></li><li>pip下载<ul><li>安装最新版本<pre class="language-dos" data-language="dos"><code class="language-dos">pip install git+https:&#x2F;&#x2F;github.com&#x2F;shotgunsoftware&#x2F;python-api.git</code></pre></li><li>安装特定版本<pre class="language-dos" data-language="dos"><code class="language-dos">pip install git+https:&#x2F;&#x2F;github.com&#x2F;shotgunsoftware&#x2F;python-api.git@v3.0.26</code></pre></li></ul></li></ul><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>直接使用用户名和密码，用户身份登录的脚本操作，会生成事件，其中存储了一些额外的元数据，EventLogEntry用于标识事件是由代表用户的脚本创建的。<br><img src="/images/ShotGrid%E7%9A%84API%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/%E4%BA%8B%E4%BB%B6%E7%94%9F%E6%88%90%E6%8E%A7%E5%88%B6.png" alt="事件生成控制 png" srcset="/images/home/Myhead.jpg" data-src="/images/ShotGrid%E7%9A%84API%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/%E4%BA%8B%E4%BB%B6%E7%94%9F%E6%88%90%E6%8E%A7%E5%88%B6.png" class="lozad post-image"><br>而使用脚本身份验证登录前，必须在Shotgun 中注册 (User&gt;Scripts)并具有有效的 API 密钥 (密钥需要在创建的时候记录下来，创建完后不再显示).</p><ul><li><p>基于用户名登陆验证</p><pre class="language-none"><code class="language-none">sg &#x3D; shotgun_api3.Shotgun(&quot;https:&#x2F;&#x2F;piedpiper.shotgunstudio.com&quot;,                        login&#x3D;&quot;rhendriks&quot;,                        password&#x3D;&quot;c0mPre$Hi0n&quot;)</code></pre></li><li><p>基于脚本登录验证</p><pre class="language-none"><code class="language-none">sg &#x3D; shotgun_api3.Shotgun(&quot;https:&#x2F;&#x2F;piedpiper.shotgunstudio.com&quot;,                        script_name&#x3D;&quot;rhendriks&quot;,                        api_key&#x3D;&quot;c0mPre$Hi0n&quot;)</code></pre></li></ul><h3 id="查询内容"><a href="#查询内容" class="headerlink" title="查询内容"></a>查询内容</h3><p>查询结果默认返回查询对象的id,字段中的实体通过id连接，如果使用实体作为过滤项（过滤条件有大括号），每个filter中的实体都应该包含实体的id，这个实体用于筛选查询的范围，那么必须使用实体的id进行过滤，不能使用名称或其他条件，例如[ “shot”,”is”,{“type”:”Shot”,”id”:1173}]；如果过滤项不是实体，那么可以使用名称或其他字段进行过滤，但必须使用点语法（链式调用），例如[ “shot.Shot.code”,”is”,”seq110”]。点语法用于查询点语法中使用的实体以外的实体，例如，project.Project.name为点语法的项目名，只能通过项目名查场次和镜头等，不能用它查询项目本身。查询本身不用点语法，直接使用shotgun.find(“Project”,[ “name”，”is”，”Test_Fly”],[])；点语法：”fieldname.entityname.fieldname.entityname.fieldname…” 只能单实体关系使用语法，由于性能问题，一个字段链接了多个实体时，不能通过点语法获得结果，需要遍历获取。不显示字段代码名称的字段，可以从filed &gt; 右键菜单 &gt; ConfigField 中获取field code名称</p><ul><li><p>查询所有项目</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_project &#x3D; sg.find(&quot;Project&quot;, [], [&quot;id&quot;, &quot;name&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询指定名称的项目(默认返回id)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_project &#x3D; sg.find(&quot;Project&quot;, [[&#39;name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询指定项目所有的场次(通过项目id获取，可直接使用查询到的实体获取相关内容)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_project &#x3D; sg.find(&quot;Project&quot;, [[&#39;name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])[0][&quot;id&quot;]sg_sequence &#x3D; sg.find(&quot;Sequence&quot;, [[&#39;project&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: sg_project&#125;]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询指定项目的场次(通过项目名称获取,使用点语法)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_sequence &#x3D; sg.find(&quot;Sequence&quot;, [[&#39;project.Project.name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定项目的所有镜头(通过项目名称获取)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_shot &#x3D; sg.find(&quot;Shot&quot;, [[&#39;project.Project.name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定场次的所有镜头(通过场次id获取)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_shot1 &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;, &quot;is&quot;, &#123;&quot;type&quot;:&quot;Sequence&quot;, &quot;id&quot;:44&#125;]], [ &quot;code&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定场次的状态为IP所有镜头(通过场次id获取)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_shot2 &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;,&quot;is&quot;, &#123;&quot;type&quot;:&quot;Sequence&quot;,&quot;id&quot;:44&#125;]，[&quot;sg_status_list&quot;, &quot;is&quot;, &quot;ip&quot;]],[ &quot;code&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定场次的状态为IP所有镜头(通过场次名称和项目共同筛选获取)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_shot3 &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Sequence&quot;,&quot;Sequence Name&quot;:&quot;seq001&quot;&#125;],[&quot;sg_status_list&quot;, &quot;is&quot;, &quot;ip&quot;], [&#39;project&#39;, &#39;is&#39;,&#123;&#39;type&#39;:&#39;Project&#39;,&#39;id&#39;:122&#125;]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定场次的状态为IP所有镜头(通过场次名称和项目共同筛选获取)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_shots &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Sequence&quot;,&quot;Sequence Name&quot;:&quot;seq001&quot;&#125;],[&quot;sg_status_list&quot;, &quot;is&quot;, &quot;ip&quot;], [&#39;project&#39;, &#39;is&#39;,&#123;&#39;type&#39;:&#39;Project&#39;,&#39;id&#39;:122&#125;]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定镜头的资产</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">project_id &#x3D; 122sequence_id &#x3D; 182filter &#x3D;  [  [&#39;project&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: project_id&#125;],  [&#39;sg_asset_type&#39;, &#39;is&#39;, &#39;Character&#39;],  [&#39;sequences&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Sequence&#39;, &#39;id&#39;: sequence_id&#125;]] fields &#x3D; [&#39;id&#39;, &#39;code&#39;, &#39;sg_asset_type&#39;]asset &#x3D; sg.find(&quot;Asset&quot;, filter, fields)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取指定类型的资产</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fields &#x3D; [&#39;id&#39;, &#39;sg_asset_type&#39;, &#39;code&#39;]filters &#x3D; [  [&#39;project&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;:122&#125;],  [&#39;sequence&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Sequence&#39;, &#39;id&#39;: 145&#125;],  [&#39;sg_asset_type&#39;, &#39;is&#39;, &#39;Character&#39;]]Character &#x3D; sg.find(&#39;Asset&#39;, filters, fields)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>计算指定Sequence里所有的任务数量，并找到其中最近截止日期</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">entity_type&#x3D;&#39;Task&#39;filter &#x3D; [[&#39;entity.Shot.sg_sequence&#39;, &#39;is&#39;, &#123;&#39;type&#39;:&#39;Sequence&#39;, &#39;id&#39;:2&#125;],[&#39;sg_status_list&#39;, &#39;is_not&#39;, &#39;na&#39;]]summary_field &#x3D; [&#123;&#39;field&#39;:&#39;id&#39;, &#39;type&#39;:&#39;count&#39;&#125;,&#123;&#39;field&#39;:&#39;due_date&#39;,&#39;type&#39;:&#39;latest&#39;&#125;]result &#x3D; sg.summarize(entity_type,filter,summary_field)#最近的截至日期，和当前场次所有任务的总数#&#123;&#39;groups&#39;: [], &#39;summaries&#39;: &#123;&#39;due_date&#39;: &#39;2013-07-05&#39;, &#39;id&#39;: 30&#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取指定 Version id 的mov</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">mov &#x3D; sg.find(&quot;Version&quot;, [&quot;id&quot;, &quot;is&quot;, 12321], [ &quot;sg_uploaded_movie&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询所有的工作流环节</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pipeline &#x3D; shotgun.find(&quot;Step&quot;,[ ],[ &quot;code&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询指定工作流环节</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotgun.find(&quot;Step&quot;,[ &quot;code&quot;，&quot;is&quot;，&quot;Animation&quot;],[])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询指定id的镜头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotgun.find(&quot;Shot&quot;,[ &quot;id&quot;，&quot;is&quot;，&quot;1207&quot;],[ &quot;code&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定镜头的指定环节的task信息（task是单独的，筛选它的link字段为entity，因此下面是筛选link字段中id为1207的镜头。注意，过滤器的第三项是要过滤的实体的话，必须使用实体id）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotgun.find(&quot;Task&quot;,[[ &quot;entity&quot;，&quot;is&quot;，&#123;&quot;type&quot;:&quot;shot&quot;,&quot;id&quot;:1207&#125;],[ &quot;shot&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Shot&quot;,&quot;id&quot;:1174&#125;],[ &quot;content&quot;,&quot;is&quot;,&quot;anim&quot;]],[])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定镜头、指定环节、指定名称的task信息</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotgun.find(&quot;Task&quot;,[[ &quot;entity&quot;，&quot;is&quot;，&#123;&quot;type&quot;:&quot;shot&quot;,&quot;id&quot;:1207&#125;],[ &quot;shot&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Shot&quot;,&quot;id&quot;:1174&#125;],[ &quot;content&quot;,&quot;is&quot;,&quot;anim&quot;]],[])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="下载mov"><a href="#下载mov" class="headerlink" title="下载mov"></a>下载mov</h3><p>下载指定 Version id 的mov<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">mov &#x3D; sg.find(&quot;Version&quot;, [&quot;id&quot;, &quot;is&quot;, 12321], [&quot;sg_uploaded_movie&quot;])localpath &#x3D; r&quot;E:\temp&quot; + mov[&quot;sg_uploaded_movie&quot;][&quot;name&quot;]sg.download_attachment(version[&quot;sg_uploaded_movie&quot;], file_path&#x3D;local_file_path)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h3 id="创建内容"><a href="#创建内容" class="headerlink" title="创建内容"></a>创建内容</h3><ul><li><p>创建镜头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotname &#x3D; &quot;test001&quot;data &#x3D; &#123;  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,  &#39;sg_sequence&#39;: &#123;&#39;type&#39;: &#39;Sequence&#39;, &#39;id&#39;: 145&#125;,  &#39;code&#39;: shotname,  &#39;sg_status_list&#39;: &#39;ip&#39;&#125;shot &#x3D; sg.create(&#39;Shot&#39;, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在镜头的pipeline步环节下创建task(一个流程环节可以有多个任务)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">animationStepId &#x3D; 106shotId &#x3D; 1173 data &#x3D; &#123;  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,  &#39;content&#39;: &#39;anim&#39;, # 任务名  &#39;step&#39;: &#123;&#39;name&#39;: &#39;Animation&#39;, &#39;type&#39;: &#39;Step&#39;, &#39;id&#39;: animationStepId&#125;,  &#39;entity&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: shotId&#125;&#125;task &#x3D; sg.create(&#39;Task&#39;, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Task下创建Version</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">taskCode &#x3D; &#39;testVersion_v001&#39;shotId &#x3D; 1173 taskId &#x3D; 5964data &#x3D; &#123;  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,  &#39;code&#39; : taskCode,  &#39;sg_status_list&#39; : &#39;rev&#39;,  &#39;entity&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: shotId&#125;,   &#39;sg_task&#39;: &#123;&#39;type&#39;: &#39;Task&#39;, &#39;id&#39;: taskId&#125;,   &#39;user&#39;: &#123;&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 220&#125; # 创建Version的人员&#125;version &#x3D; sg.create(&#39;Version&#39;, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建带有镜头和任务链接的版本</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">shotID &#x3D; 1173taskID &#x3D; 5964 data &#x3D; &#123; &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;,&#39;id&#39;: 122&#125;,        &#39;code&#39;: &#39;100_010_anim_v1&#39;,        &#39;description&#39;: &#39;first pass at opening shot with bunnies&#39;,        &#39;sg_path_to_frames&#39;: &#39;&#x2F;v1&#x2F;gun&#x2F;s100&#x2F;010&#x2F;frames&#x2F;anim&#x2F;100_010_animv1_jack.#.jpg&#39;,        &#39;sg_status_list&#39;: &#39;rev&#39;,        &#39;entity&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;:  shotID&#125;,        &#39;sg_task&#39;: &#123;&#39;type&#39;: &#39;Task&#39;, &#39;id&#39;: taskID&#125;,        &#39;user&#39;: &#123;&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 165&#125; &#125; result &#x3D; sg.create(&#39;Version&#39;, data) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用任务模板创建任务</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">filters &#x3D; [[&#39;code&#39;,&#39;is&#39;, &#39;3D Shot Template&#39; ]]taskTemplate &#x3D; sg.find_one(&#39;TaskTemplate&#39;, filters)  # 查找任务模板taskId &#x3D; 5964data &#x3D; &#123;&#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;,&#39;id&#39;: 122&#125;,      &#39;code&#39;: &#39;seq001_sc001&#39;,      &#39;description&#39;: &#39;creating a task with taskTemplate&#39;,      &#39;task_template&#39;: template &#125;result &#x3D; sg.create(&#39;Shot&#39;, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建自定义实体 Entity(查找方式和查找别的实体一样)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data &#x3D; &#123;  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,  &#39;code&#39;: &#39;test_plate_v001&#39;,  &#39;sg_shot&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: 1173&#125;,  &#39;updated_by&#39;: &#123;&#39;type&#39;: &#39;Group&#39;, &#39;id&#39;: 3&#125;, # 更新用户为群组  &#39;sg_original_resolution&#39;: &#39;1920x1080&#39;,  &#39;sg_plate_type&#39;: &#39;BG01&#39;,  &#39;sg_frames_scanned&#39;: 150,  &#39;sg_scan_start&#39;: 1,  &#39;sg_scan_end&#39;: 150&#125;plate &#x3D; sg.create(&#39;CustomEntity10&#39;, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>上传缩略图</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">versionID &#x3D; 214picPath &#x3D; &quot;&#x2F;v1&#x2F;gun&#x2F;s100&#x2F;010&#x2F;beauties&#x2F;anim&#x2F;100_010_animv1.jpg&quot;sg.upload_thumbnail(&quot;Version&quot;, versionID, picPath)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h3><ul><li><p>更新镜头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotId &#x3D; 1173data &#x3D; &#123;  &#39;description&#39;: &#39;Open on a beautiful field with fuzzy bunnies&#39;,  &#39;sg_status_list&#39;: &#39;ip&#39;  &#125;result &#x3D; sg.update(&#39;Shot&#39;, shotId, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>更新Mov到镜头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotId &#x3D; 423mov_file &#x3D; &#39;&#x2F;data&#x2F;show&#x2F;ne2&#x2F;100_110&#x2F;anim&#x2F;01.mlk-02b.mov&#39;sg.upload(&quot;Shot&quot;, shotId, mov_file, field_name&#x3D;&quot;sg_latest_quicktime&quot;, display_name&#x3D;&quot;Latest QT&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h3><ul><li><p>删除指定id的project实体</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_delete &#x3D; sg.delete(&quot;Project&quot;,155)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除指定镜头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotId &#x3D; 1173result &#x3D; sg.delete(&quot;Shot&quot;,shotId)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="恢复内容"><a href="#恢复内容" class="headerlink" title="恢复内容"></a>恢复内容</h3><ul><li>恢复删掉的镜头<pre class="line-numbers language-python" data-language="python"><code class="language-python">shotId &#x3D; 1173sg.revive(&quot;Shot&quot;, shotId)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="批量处理（创建，删除，更新）镜头"><a href="#批量处理（创建，删除，更新）镜头" class="headerlink" title="批量处理（创建，删除，更新）镜头"></a>批量处理（创建，删除，更新）镜头</h3><p>使用batch函数的任务，要么全部完成，要么全都不完成</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">batch_data &#x3D; []for i in range(1,100):    data &#x3D; &#123;        &quot;code&quot;: &quot;shot_%04d&quot; % i,        &quot;project&quot;: project    &#125;    batch_data.append(&#123;&quot;request_type&quot;: &quot;create&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;data&quot;: data&#125;)sg.batch(batch_data)  batch_data &#x3D; [  &#123;&quot;request_type&quot;: &quot;create&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;data&quot;: &#123;&quot;code&quot;: &quot;New Shot 1&quot;, &quot;project&quot;: project&#125;&#125;,  &#123;&quot;request_type&quot;: &quot;update&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 3624, &quot;data&quot;: &#123;&quot;code&quot;: &quot;Changed 1&quot;&#125;&#125;,  &#123;&quot;request_type&quot;: &quot;delete&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 3624&#125;]sg.batch(batch_data) # 三种不同类型可同时存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关闭链接"><a href="#关闭链接" class="headerlink" title="关闭链接"></a>关闭链接</h3>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">sg.close()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="部分可查询实体类型"><a href="#部分可查询实体类型" class="headerlink" title="部分可查询实体类型"></a>部分可查询实体类型</h3><table><thead><tr><th align="right">实体类型名称</th><th align="left">实体含义</th></tr></thead><tbody><tr><td align="right">ActionMenuItem</td><td align="left">动作菜单</td></tr><tr><td align="right">ApiUser</td><td align="left">脚本</td></tr><tr><td align="right">Asset</td><td align="left">资产</td></tr><tr><td align="right">Attachment</td><td align="left">附件</td></tr><tr><td align="right">Booking</td><td align="left">人员规划</td></tr><tr><td align="right">Camera</td><td align="left">摄像机</td></tr><tr><td align="right">ClientUser</td><td align="left">客户</td></tr><tr><td align="right">Composition</td><td align="left">合成</td></tr><tr><td align="right">Cut</td><td align="left">剪辑镜头</td></tr><tr><td align="right">CutItem</td><td align="left">剪辑镜头项</td></tr><tr><td align="right">Delivery</td><td align="left">分发</td></tr><tr><td align="right">Department</td><td align="left">部门</td></tr><tr><td align="right">Episode</td><td align="left">季</td></tr><tr><td align="right">EventLogEntry</td><td align="left">事件日志</td></tr><tr><td align="right">FilesystemLocation</td><td align="left">文件系统位置</td></tr><tr><td align="right">Group</td><td align="left">组</td></tr><tr><td align="right">HumanUser</td><td align="left">人员</td></tr><tr><td align="right">Icon</td><td align="left">图标</td></tr><tr><td align="right">Level</td><td align="left">关卡</td></tr><tr><td align="right">LocalStorage</td><td align="left">本地存储</td></tr><tr><td align="right">MocapPass</td><td align="left">动作捕捉过程</td></tr><tr><td align="right">MocapSetup</td><td align="left">动作捕捉设置</td></tr><tr><td align="right">MocapTake</td><td align="left">动作捕捉条目</td></tr><tr><td align="right">MocapTakeRange</td><td align="left">动作捕捉条目范围</td></tr><tr><td align="right">Note</td><td align="left">反馈，记录</td></tr><tr><td align="right">Page</td><td align="left">页面</td></tr><tr><td align="right">PageHit</td><td align="left">页面点击</td></tr><tr><td align="right">PageSetting</td><td align="left">页面设置</td></tr><tr><td align="right">Performer</td><td align="left">演员</td></tr><tr><td align="right">PermissionRuleSet</td><td align="left">权限组设置</td></tr><tr><td align="right">Phase</td><td align="left">项目时间表</td></tr><tr><td align="right">PhysicalAsset</td><td align="left">实拍道具</td></tr><tr><td align="right">PipelineConfiguration</td><td align="left">工作流工序配置</td></tr><tr><td align="right">Playlist</td><td align="left">播放表单</td></tr><tr><td align="right">PlaylistShare</td><td align="left">共享的播放表单</td></tr><tr><td align="right">Project</td><td align="left">项目</td></tr><tr><td align="right">PublishedFile</td><td align="left">已发布文件</td></tr><tr><td align="right">PublishedFileDependency</td><td align="left">已发布文件依存关系</td></tr><tr><td align="right">PublishedFileType</td><td align="left">已发布文件类型</td></tr><tr><td align="right">Release</td><td align="left">软件发布版本</td></tr><tr><td align="right">Reply</td><td align="left">回复</td></tr><tr><td align="right">Revision</td><td align="left">修正版本</td></tr><tr><td align="right">Routine</td><td align="left">运动捕捉例程</td></tr><tr><td align="right">RvLicense</td><td align="left">RV许可证</td></tr><tr><td align="right">Scene</td><td align="left">场</td></tr><tr><td align="right">Sequence</td><td align="left">本</td></tr><tr><td align="right">ShootDay</td><td align="left">拍摄日期</td></tr><tr><td align="right">Shot</td><td align="left">镜头</td></tr><tr><td align="right">Software</td><td align="left">DCC软件</td></tr><tr><td align="right">Status</td><td align="left">状态</td></tr><tr><td align="right">Step</td><td align="left">工作流工序</td></tr><tr><td align="right">Tag</td><td align="left">标签</td></tr><tr><td align="right">Task</td><td align="left">任务</td></tr><tr><td align="right">TaskDependency</td><td align="left">任务依存关系</td></tr><tr><td align="right">TaskTemplate</td><td align="left">任务模版</td></tr><tr><td align="right">Ticket</td><td align="left">软件开发工单</td></tr><tr><td align="right">TimeLog</td><td align="left">工时记录</td></tr><tr><td align="right">Version</td><td align="left">版本</td></tr></tbody></table><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>ShotGrid API文档：<a href="https://developer.shotgridsoftware.com/python-api/">https://developer.shotgridsoftware.com/python-api/</a><br>用户帮助文档：<a href="https://shotgunsoftware.zendesk.com/hc/zh-cn">https://shotgunsoftware.zendesk.com/hc/zh-cn</a><br>站点状态查询网站：<a href="https://status.shotgridsoftware.com/">https://status.shotgridsoftware.com/</a><br>shot教学视频：<a href="https://space.bilibili.com/399556599">https://space.bilibili.com/399556599</a></p>]]></content>
      
      
      <categories>
          
          <category> ShotGrid </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pipeline </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuke学习笔记4_回调函数</title>
      <link href="/posts/20220807a1.html"/>
      <url>/posts/20220807a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h3 id="Nuke-API-文档"><a href="#Nuke-API-文档" class="headerlink" title="Nuke API 文档"></a>Nuke API 文档</h3><ul><li>本地文档：C:\Program Files\Nuke12.2v2\Documentation</li><li>在线文档：<a href="https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html">https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html</a><ul><li>Nuke Python Developers Guide: 案例教程</li><li>Python Scripting Reference： API 参考文档</li><li><a href="http://www.nukepedia.com/reference/Tcl/" title="" target="">TCL Scripting Reference: TCL 表达式参考文档</a></li></ul></li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>部分回调函数的使用</p><ul><li>添加回调函数<ul><li>nuke.toNode(“节点名”)[“knobChanged”].setValue(回调函数) 仅对选择的节点生效，此处回调函数是字符串格式</li><li>nuke.addOnCreate(callable,args&#x3D;(),kwargs&#x3D;{},nodeClass&#x3D;”*”)</li><li>callable 可调用对象</li><li>args 不定长位置参数列表</li><li>kwargs 不定长关键字参数字典</li><li>nodeClass 默认值是星号，指无论当前节点是什么，在事件发生时都会执行这个回调函数，需自定义</li></ul></li><li>删除回调函数</li><li>事件函数<ul><li><p>knobChanged 用户在打开的面版中改变knob后执行事件，可实现联动事件</p><ul><li>nuke.thisNode() 该控件在打开、关闭面板或输入端改变时，分别指向showPanel、hidePanel、inputChange事件，这三个控件使用代码获取不到，但可以在knobChange中使用控件名<pre class="language-Python" data-language="Python"><code class="language-Python">def testevent():    &quot;&quot;&quot;如果打开面板，打印内容&quot;&quot;&quot;    k&#x3D;nuke.thisKnob()    if k.name() &#x3D;&#x3D; &quot;showPanel&quot;:        print(&quot;show&quot;)nuke.addKnobChanged(testevent, nodeClass&#x3D;&quot;NoOp&quot;)</code></pre></li></ul></li><li><p>updateUI 任意UI发生变化后触发，比knobChange优先级低，不应在其中添加任何和回调结构有关的操作</p></li><li><p>autolabel 在updateUI之后执行，用于为节点设置在Node Grape中显示的文本 ，按照函数添加的顺序，从后往前执行，只要那个函数的返回值不是None，那么这个返回值就用于该节点的显示文本，若没有返回值或返回值为None,则使用节点名显示，该显示的文本和label标签不同。</p></li></ul></li></ul><p>回调函数执行顺序：<br>可以通过控件设置的回调函数 &gt; 使用注册回调函数添加的回调函数<br>使用注册回调函数添加的回调函数的优先级依赖注册的先后顺序，并先执行指定了nodeClass参数的回调，再执行满足所有类型的回调。addAutolabel()和addFilenameFilter()是特里，它们恰恰与之相反。<br>onCreate 对于Group节点，会先执行其中的内部节点，然后再在Group节点上执行一遍回调<br>onDestory事件和onCreate事件相反<br>onUserCreate执行优先级 &gt; onCreate执行优先级 </p><h3 id="部分回调函数"><a href="#部分回调函数" class="headerlink" title="部分回调函数"></a>部分回调函数</h3><table><tr><td><img src="/images/Nuke学习笔记4_回调函数/回调函数1.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记4_回调函数/回调函数1.png" class="lozad post-image"></td><td><img src="/images/Nuke学习笔记4_回调函数/回调函数2.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记4_回调函数/回调函数2.png" class="lozad post-image"></td></tr></table>]]></content>
      
      
      <categories>
          
          <category> Nuke </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuke学习笔记3_菜单的加载和界面</title>
      <link href="/posts/20220801a1.html"/>
      <url>/posts/20220801a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h3 id="Nuke-API-文档"><a href="#Nuke-API-文档" class="headerlink" title="Nuke API 文档"></a>Nuke API 文档</h3><ul><li>本地文档：C:\Program Files\Nuke12.2v2\Documentation</li><li>在线文档：<a href="https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html">https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html</a><ul><li>Nuke Python Developers Guide: 案例教程</li><li>Python Scripting Reference： API 参考文档</li><li>TCL Scripting Reference: TCL 表达式参考文档</li></ul></li></ul><h3 id="工具加载"><a href="#工具加载" class="headerlink" title="工具加载"></a>工具加载</h3><p>开启 nuke 时，系统会加载两个安装目录的Plugins文件夹下的两个文件：</p><ul><li>init.py : 用于Nuke的环境设置、系统选项和默认参数，不能包含任何界面相关操作，命令行模式和GUI模式下均加载。</li><li>menu.py ：用于跟界面相关的设置、自定义菜单、工具架，仅GUI模式加载。<br>位于用户文件夹下存放用户预设的.nuke文件夹，其下的init.py和menu.py用于存放用户预设。</li></ul><p>加载工具方式</p><ul><li>加载工具不运行：仅需要在init.py导入模块的主函数即可，再通过工具界面去调用主函数</li></ul><h3 id="加载工具相关函数"><a href="#加载工具相关函数" class="headerlink" title="加载工具相关函数"></a>加载工具相关函数</h3><ul><li>获取插件和图标的搜索路径 nuke.pluginPath()</li><li>向系统搜索路径添加路径到开头,并加载路径下的init.py nuke.pluginAddPath(“pathstr or pathList”)</li><li>向系统搜索路径添加路径到结尾,但不加载路径下的init.py nuke.pluginAppendPath(“pathstr or pathList”)</li><li>检测指定的函数或插件是否存在 nuke.pluginExists(“pluginName or path or fileName”)</li><li>返回所有已经加载的插件的文件路径列表 nuke.pligins(num,”re表达式过滤”，”re表达式过滤”，…)  num为 0，1，2，3</li></ul><h3 id="Nuke环境变量"><a href="#Nuke环境变量" class="headerlink" title="Nuke环境变量"></a>Nuke环境变量</h3><p>NUKE_PATH、OFX_PLUGIN_PATH都是列表后面的路径先加载，以反向解析加载路径的方式进行的，因此涉及继承和覆盖的通用配置需要放在列表后面，特殊和本地的配置放在列表开头。nuke.pluginPath是正向解析加载方式。</p><ul><li>NUKE_PATH 搜索 Nuke 的init.py 和menu.py文件的路径，可以将插件放在不同的位置，并且每一个插件都有各自的init.py和menu.py文件，就不用将所有插件都写入 .nuke 文件夹下的文件中，实现分布式管理</li><li>OFX_PLUGIN_PATH 用来设置和加载ofx插件的位置，指向ofx的安装路径</li></ul><h3 id="自定义菜单常用类型"><a href="#自定义菜单常用类型" class="headerlink" title="自定义菜单常用类型"></a>自定义菜单常用类型</h3><p>Nuke的菜单界面和Qt是两套体系,Nuke 界面不属于Qt范畴</p><ul><li>菜单栏工具<ul><li>nuke.menu(“Nuke”)</li></ul></li><li>工具栏工具<ul><li>nuke.menu(“Nodes”)</li></ul></li><li>NodeGraph中右键工具<ul><li>nuke.menu(“Node Graph”)</li></ul></li></ul><h3 id="自定义菜单函数"><a href="#自定义菜单函数" class="headerlink" title="自定义菜单函数"></a>自定义菜单函数</h3><ul><li><p>nuke.Menu 菜单类型</p><ul><li>nuke.menu(“Nuke”).findItem(“菜单项名称”) 查找指定菜单项 <ul><li>菜单项名称可以是相对于顶级菜单项的名称 nuke.menu(“Nuke”).findItem(“菜单项1&#x2F;菜单项2&#x2F;菜单项3”)</li></ul></li><li>nuke.menu(“Nuke”).menu(“菜单项名称”) 查找指定菜单项</li><li>nuke.Menu.items() 返回查询到的菜单项</li><li>nuke.menu(“Nuke”).addMenu(“新加项”，icon&#x3D;””,tooltip&#x3D;””,index&#x3D;””) 创建新菜单，其中新加项也是相对路径，index添加位置，默认为-1，只对要添加的最后一级菜单项有效  </li><li>nuke.menu(“Nuke”).addcommand(“新加项”,”脚本字符串”，“快捷键”，”icon”,”tooltip”，”index”) 添加菜单项命令，其中 “脚本字符串”可以为可执行的Python语句，或lambda函数，若没有指定命令，则会默认为创建一个名为新加项的节点。</li><li>nuke.menu(“Nuke”).removeItem(“删除项”) 删除指定的菜单，其中删除项不为相对路径，要删除指定项，需要从指定级的上一级删除，空菜单会自动删除</li><li>nuke.menu(“Nuke”).clearMenu() 删除菜单下的所有菜单项，也不支持相对路径，不会删除当前空菜单</li></ul></li><li><p>nuke.MenuItem 创建菜单项类</p><ul><li>nuke.menu(“Nuke”).findItem(“菜单项”).action() 获取QAction对象,其父对象是QMainWindow</li><li>nuke.menu(“Nuke”).findItem(“菜单项”).invoke() 直接执行menuItem，等同于nuke.menu(“Nuke”).findItem(“菜单项”).action().trigger()</li><li>nuke.menu(“Nuke”).findItem(“菜单项”).script() 返回对应的字符串，如果是lambda函数，其返回值是空</li><li>nuke.menu(“Nuke”).findItem(“菜单项”).setScript() 重新设置字符串</li></ul></li><li><p>nuke.menu(“菜单名”) 获取指定的根菜单，以下列出部分菜单名</p><ul><li>Nuke 菜单栏</li><li>Nodes 工具栏</li><li>Node Graph NodeGraph中的右键菜单</li><li>Viewer Viewer菜单</li><li>Properties 节点属性对话框中的右键菜单</li><li>Animation 动画控件和曲线编辑器右键菜单</li><li>Pane 界面中面板布局右键菜单</li><li>Axis 坐标右键菜单</li></ul></li></ul><h3 id="获取当前软件QT对象"><a href="#获取当前软件QT对象" class="headerlink" title="获取当前软件QT对象"></a>获取当前软件QT对象</h3><pre class="line-numbers language-pyhton" data-language="pyhton"><code class="language-pyhton">from Pyside2 import QtWidgetsallWin &#x3D; [w for w in QtWidgets.QApplication.instance().topLevelWidgets() if w.windowTitle() &#x3D;&#x3D; &quot;窗口提示&quot;]allMenu &#x3D; [w for w in allWin[0]children() if isinstance(w,QtWidgets.QMenuBar)]menubar &#x3D; allMenu[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Nuke </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuke学习笔记2_节点与Knob</title>
      <link href="/posts/20220731a1.html"/>
      <url>/posts/20220731a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h3 id="Nuke-API-文档"><a href="#Nuke-API-文档" class="headerlink" title="Nuke API 文档"></a>Nuke API 文档</h3><ul><li>本地文档：C:\Program Files\Nuke12.2v2\Documentation</li><li>在线文档：<a href="https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html">https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html</a><ul><li>Nuke Python Developers Guide: 案例教程</li><li>Python Scripting Reference： API 参考文档</li><li>TCL Scripting Reference: TCL 表达式参考文档</li></ul></li></ul><h3 id="节点创建和删除"><a href="#节点创建和删除" class="headerlink" title="节点创建和删除"></a>节点创建和删除</h3><p>nuke节点的有可能有不同的版本，比如”Text”和”Text2”、 “Merge”和”Merge2”、”Tracher”和”Tracher3”以及”Tracher4”，默认情况下使用的是新版。右键 &gt; Other &gt; All Plugin &gt; Update，这个操作会扫面并加载所有可用的节点。bezier节点不能被扫描出来，可使用Roto代替,若一定要使用，可使用代码创建或使用 Comp Script Command（TCL） 快捷键（X）创建想要的节点。节点参数的键可以在Nuke中将鼠标悬停在参数选项上，显示的提示框的第一句就是参数的名称，参数的值可复制节点到文本编辑器中查询，有时参数可能设置不上，是Nuke的一些bug,需要寻找别的手段设置。前台模式适合在Gui模式下交互，并且创建的节点会默认连接到当前选择的节点下，若没有选中节点，则创建在鼠标最后一次点击的位置；后台模式更适合后台运行脚本，创建的节点的位置随机。</p><ul><li>创建节点：<ul><li>前台模式：nuke.createNode(“节点类型”) </li><li>后台模式：nuke.nodes.Read()</li></ul></li><li>创建节点时不弹出参数设置对话框：nuke.createNode(“节点类型”，inpanel&#x3D;False)</li><li>创建节点时设置参数：<ul><li>前台模式：nuke.createNode(“Text2”,”message ‘test’ yjustify center”)</li><li>后台模式：nuke.nodes.Read(message&#x3D;’test’, yjustify&#x3D;center)</li></ul></li><li>获取选中节点类型名：<ul><li>nuke.getNodeClassName()(选中状态的节点)</li><li>node &#x3D; createNode(“Text2”);node.Class()</li></ul></li><li>获取节点名：node.name()</li><li>删除节点：<ul><li>前台模式：nuke.delete(node)</li><li>后台模式：nuke.nodeDelete()(选中状态的节点)</li></ul></li></ul><h5 id="Read节点读取文件小技巧"><a href="#Read节点读取文件小技巧" class="headerlink" title="Read节点读取文件小技巧"></a>Read节点读取文件小技巧</h5><p>通过fromUserText方法读取视频文件，可以直接获取到视频文件的视频的长度。</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import nukereadNode &#x3D; nuke.nodes.Read()movPath &#x3D; r&quot;D:\mov\test.mov&quot;readNode[&#39;file&#39;].fromUserText(movpath)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是exr或者别的图片序列呢？<br>通过nuke.getFileNameList(path)方法可以获取到文件夹下的序列，进行自动分类，并返回一个字符串列表：</p><blockquote><p>[‘N.####.exr 1-15’, ‘Z.####.exr 1-7’, ‘beauty.####.exr 1-160’]</p></blockquote><p>创建read节点示例如下：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import nukereadNode &#x3D; nuke.nodes.Read()exrPath &#x3D; r&quot;D:\image\beauty&quot;exrlist &#x3D; nuke.getFileNameList(exrPath)for _each in exrlist:    readNode &#x3D; nuke.nodes.Read()    readNode[&#39;file&#39;].fromUserText(&quot;%s&#x2F;%s&quot; % (exrPath,_each))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择和链接节点"><a href="#选择和链接节点" class="headerlink" title="选择和链接节点"></a>选择和链接节点</h3><ul><li>获取节点：nuke.toNode(“节点名”)</li><li>获取节点输入：<ul><li>获取所有输入端：nuke.inputs()</li><li>获取指定输入端：nuke.input(端口数字)</li></ul></li><li>链接节点：nuke.setInput(端口数字，nuke.toNode(“节点名”)) </li><li>获取所有节点：nuke.allNodes()</li><li>获取选中节点：<ul><li>仅返回最后一个被选中的节点 nuke.selectedNode() </li><li>返回主节点树中所有选中的节点 nuke.selectedNodes()</li></ul></li><li>选中以获得的节点<ul><li>将节点设置为选中状态 node &#x3D; createNode(“Text2”);node.setSelect(是否选中) 也可以传递参数设置选中状态</li><li>将当前节点设置为整个节点树中唯一被选中的状态 node.selectOnly()</li></ul></li><li>选中所有节点 nuke.selectAll()</li><li>选中满足模糊搜索节点名称的节点：nuke.selectPattern() 仅能在GUI模式下使用</li><li>选中与当前选中节点类似的节点：nuke.selectSimilar(“要匹配的类型”)<ul><li>选中有相似的类型 nuke.selectSimilar(nuke.MATCH_CLASS)</li><li>选中有相似的label标签 nuke.selectSimilar(nuke.MATCH_LABEL)</li><li>选中有相似的颜色 nuke.selectSimilar(nuke.MATCH_COLOR)</li></ul></li><li>将选中节点的上下游都设置为选中状态 nuke.selectConnectedNodes()</li><li>判断是否有被选中的节点 nuke.nodesSelected()</li><li>反向选择 nuke.invertSelection()</li><li>将节点从选中的节点中脱离出来 nuke.extractSelected()</li><li>克隆选中的节点 nuke.cloneSelected()</li><li>以递归形式清除节点的选中状态 nukescript.misc.clear_selection_recursive() 包括Gizmo 和 Group 中选中的节点也会被清除选中。</li></ul><h3 id="节点位置和布局"><a href="#节点位置和布局" class="headerlink" title="节点位置和布局"></a>节点位置和布局</h3><p> NodeGraph 的坐标轴方向是X轴向右，Y轴向下；节点的位置指的是节点左上角的位置.<br> 位置相关方法,node &#x3D; createNode(“Text2”)：</p><ul><li>获取位置<ul><li>node.xpos()、node.ypos()</li><li>node[“xpos”].value、node[“ypos”].value</li></ul></li><li>设置位置<ul><li>node.setXpos(“value”)、node.setYpos(“value”)、node.setXYpos(“value1”,”value2”)</li><li>node[“xpos”].setValue(“value”)、node[“ypos”].setValue(“value”)</li></ul></li><li>获取节点长宽<ul><li>node.screenWidth()、node.screenHeight()</li></ul></li><li>自动布局到选中节点的下方 node.autoplace()</li><li>NodeGraph 缩放比 <ul><li>查询缩放比 nuke.zoom()</li><li>设置缩放比 nuke.zoom(倍数，[焦距的位置X,焦距的位置Y])</li><li>聚焦到指定节点 nuke.zoom(倍数，[node.xpos(),node.ypos()])</li></ul></li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>打开新Nuke工程 nuke.scriptNew() ctrl+N</li><li>打开指定Nuke工程 nuke.scriptOpen(“存在的Nuke工程路径”) </li><li>将已有的Nuke工程导入到当前的Nuke工程中<ul><li>nuke.scriptSource()</li><li>nuke.scriptRendFile()</li></ul></li><li>清空当前NodeGraph:<ul><li>直接放弃修改，无返回值 nuke.scriptClear()</li><li>提示是否保存更改，有返回值 nuke.scriptClose()</li></ul></li><li>退出Nuke nuke.scriptExit()</li><li>获取当前文件名称 <ul><li>nuke.scriptName()</li><li>nuke.Root().name()</li><li>nuke.Root()[“name”].value()</li><li>nuke.Root().knob(“name”).value()</li></ul></li><li>从节点中进入节点树环境.使用上下文管理器with ‘with nuke.Root()’</li><li>返回当前工程所在的文件夹的路径<ul><li>nuke.utils.script_directory()</li><li>nukescripts.script_directory()（该方法调用上面的方法）</li></ul></li><li>复制和粘贴<ul><li>从字符串创建一个节点 nuke.scriptReadText(“表示节点的字符串，超麻烦”)</li><li>将选中的节点暂存到文本名或粘贴板名的文件中 nuke.nodeCopy(“文件路径或临时起名的粘贴板中”)</li><li>将粘贴板中的内容粘贴到nuke中 nuke.nodePaste(“文件路径或临时起名的粘贴板中”)  # %clipboard% 可表示系统粘贴板</li></ul></li><li>保存工程 <ul><li>直接保存 nuke.scriptSave()</li><li>另存为 nuke.scriptSaveAs(“文件名”)</li><li>另存时不修改Root节点中的路径 nuke.scriptSaveToTemp(“文件名”)</li><li>保存文件后清空nuke工程 nuke.scriptSaveAndClear()</li></ul></li></ul><h3 id="Nuke中的控件（Knob）"><a href="#Nuke中的控件（Knob）" class="headerlink" title="Nuke中的控件（Knob）"></a>Nuke中的控件（Knob）</h3><p>Nuke中的文本框、下拉菜单、复选框、滑块等基本控件，以及色彩设置<br>图片尺寸、坐标值等 专属控件都称为Knob。<br>node &#x3D; nuke.toNode(“Read”)</p><ul><li>获取所有的控件 <ul><li>node.allKnobs() 所有控件列表</li><li>node.knobs() 所有控件字典</li></ul></li><li>获取特定的控件对象 <ul><li>根据控件名获取<ul><li>node.knob(“控件名”) 没找到指定对象返回None</li><li>node[“控件名”] 没找到指定对象会报错</li><li>node.knobs().get(“控件名”) 根据控件名获取控件对象</li></ul></li><li>根据序号获取<ul><li>node.numKnobs() 返回当前节点中所有控件的总数量</li><li>node.knob(控件序号)</li></ul></li></ul></li><li>获取当前用户操作的控件 nuke.thisNode() </li><li>控件状态 <ul><li>node.knob(“控件名”).enable() 是否启用</li><li>node.knob(“控件名”).enable()setEnable() 设置启用状态</li><li>node.knob(“控件名”).enable()visible() 是否可见</li><li>node.knob(“控件名”).enable()setVisible() 设置可见状态</li></ul></li><li>返回标签名、控件名、提示信息 label()、name()、tooltip()</li><li>设置标签名、控件名、提示信息 setLabel()、setName()、setTooltip()</li><li>获取控件值<ul><li>value() 控件会根据需要进行继承和修改函数</li><li>getValue(oc) 获取特定帧或特定视图下的值</li><li>getValueAt()</li><li>defaultValue() 获取默认值</li></ul></li><li>设置控件的值  <ul><li>setValue(value,view&#x3D;”default”) 控件会根据需要进行继承和修改函数</li><li>setValueAt()</li><li>setDafaultValue() 设置控件的默认值</li><li>nuke.knobDefault(“节点名.控件名”，”参数”) 对节点的参数设置全局默认值</li></ul></li><li>控件值是否不为默认值 notDefault()</li></ul><p>format_knob 参数默认值来源于Root节点的format值</p><ul><li>获取值 node.knob(“format控件名”).value() </li><li>设置值 node.knob(“format控件名”).setValue()</li><li>新建默认format值 nuke.addFormat(“新建format值”) 新建format值为TCL表达式，其至少要包含 宽度，高度，格式名三项，每项用空格分隔，名称不能用数字开头</li></ul><p>TCL表达式相关函数：</p><ul><li>node.knob(“format控件名”).fromScript(“tcl表达式”) 接受tcl表达式并赋值给对象</li><li>node.knob(“format控件名”).toScript(bool,time) 将值输出为TCL表达式 bool为Ture，结果两侧加大括号，反之不加，time为具体帧，则仅设置该帧，若为None，则设置所有帧</li><li>node.knob(“format控件名”).readKnobs(“tcl表达式”) 使用tcl表达式为一个或多个节点控件赋值</li><li>node.knob(“format控件名”).writeKnobs(value) 将控件值以tcl表达式方式输出,value需要根据常量获取，详情见文档</li></ul><h3 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h3><p>UI交互式创建</p><table><tr><td><img src="/images/Nuke学习笔记2_节点与Knob/编辑控件.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记2_节点与Knob/编辑控件.png" class="lozad post-image"></td><td><img src="/images/Nuke学习笔记2_节点与Knob/创建控件.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记2_节点与Knob/创建控件.png" class="lozad post-image"></td></tr></table><p>代码创建<br>可使用NoOp节点进行自定义<br>node &#x3D; nuke.toNode(“Read”)</p><ul><li>添加控件 node.addKnob(控件对象)</li><li>移除控件 node.removeKnob(控件对象)</li><li>pythonScript中获取当前节点 nuke.thisNode()</li></ul><h3 id="Gizmo操作"><a href="#Gizmo操作" class="headerlink" title="Gizmo操作"></a>Gizmo操作</h3><p>将具有特定功能的节点组打包成一个节点，可用于别的nuke工程</p><ul><li>查询节点全路径 nuke.thisNode().fullName()</li><li>查询组内的节点 <ul><li>nuke.node(“组名”).node(“内部节点名”)[“knob名”].value()</li><li>nuke.node(“组名.组内节点名”)[“knob名”].value()</li></ul></li><li>在组织间进行代码操作<ul><li>node.begin() 代码开始</li><li>node.end() 代码结束</li></ul></li><li>转换正确导入的Gizmo为Group nuke.toNode(“Group”).makeGroup()</li></ul><h4 id="导入-导出gizmo"><a href="#导入-导出gizmo" class="headerlink" title="导入\导出gizmo"></a>导入\导出gizmo</h4><p>在组节点或者Gizmo节点下面，点击Node &gt; Export gizmo\Copr as Group<br>不能直接import Gizmo 节点使用，这样导入的节点是不完整的，只能使用nuke标准环境加载的方式进行应用。或将gizmo文件以文本的方式打开，将其中的Gizmo 替换为Group,这样也可以正确导入节点组。</p>]]></content>
      
      
      <categories>
          
          <category> Nuke </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuke学习笔记1_环境与命令行</title>
      <link href="/posts/20220730a1.html"/>
      <url>/posts/20220730a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h4 id="Nuke-脚本编辑窗口相关快捷键和操作"><a href="#Nuke-脚本编辑窗口相关快捷键和操作" class="headerlink" title="Nuke 脚本编辑窗口相关快捷键和操作"></a>Nuke 脚本编辑窗口相关快捷键和操作</h4><p>tab键   自动代码补全    输入部分脚本后，可获取相关的方法</p><p style="text-indent:2em">Edit > Preferences > ScriptEditor > echo python commands to output window 将输出常用操作的 Nuke Python API 代码显示在代码执行结果显示区。</p><p><img src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9CPython%E4%BB%A3%E7%A0%81%E5%88%B0%E8%84%9A%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="输出操作Python代码到脚本编辑器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9CPython%E4%BB%A3%E7%A0%81%E5%88%B0%E8%84%9A%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8.png" class="lozad post-image"> </p><h4 id="搭建-Pycharm-IDE-开发环境"><a href="#搭建-Pycharm-IDE-开发环境" class="headerlink" title="搭建 Pycharm IDE 开发环境"></a>搭建 Pycharm IDE 开发环境</h4><p style="text-indent:2em">在 Pycharm 中新建一个项目，用于开发Nuke插件,必须使用Nuke本身的Python编译器 "C:\Program Files\Nuke版本\python.exe"，该python编译器拥有完整的Nuke开发环境。</p><p style="text-indent:2em">关于 nukescripts 模块的使用，需要将“C:\Program Files\Nuke版本号\plugins”加入搜索路径</p><p style="text-indent:2em">关于 Pyside2 模块的使用，需要将“C:\Program Files\Nuke版本号\pythonextensions\site-packages”加入搜索路径</p><p style="text-indent:2em">配置好上面的环境后执行代码会发现报错：缺少一个“_nuke” 模块。这个模块在这里 "C:\Program Files\Nuke12.2v2\lib\site-packages\nuke.pyd" 中，由于这个文件和上面的 nukescripts 模块同级目录的nuke模块重名，导致不能加载这个nuke.pyd，因此会报这个错，如何解决呢？</p><ul><li>方法一.从搜索路径中去掉 “C:\Program Files\Nuke版本号\plugins”，但nukescripts模块的会缺少代码补全（加载完nuke.pyd后，会自动加载nuke和nukescripts模块，因此在执行代码时不会报这两个模块的错）.</li><li>方法二.在pycharm中将编辑nuke代码的Python解释器和运行nuke代码的python解释器分开，在编写的nuke代码的时候，将项目中python interpreter中设置的python解释器设置为普通的python解释器，可以在其搜索路径中加入我们想要的搜索路径，然后在运行nuke代码的时候，在Run&#x2F;Debug configuration中设置的python解释器设置为带有nuke环境的python解释器即可。</li></ul><p>  <img src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%88%87%E6%8D%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84Python%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt="切换执行时的Python解释器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%88%87%E6%8D%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84Python%E8%A7%A3%E9%87%8A%E5%99%A8.png" class="lozad post-image"> </p><p style="text-indent:2em">此环境可能无法正常运行Pyside2相关的代码，需要在nuke中执行(详情见下一节)。</p><p><img src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/Pycharm%E4%B8%AD%E4%BD%BF%E7%94%A8Pyside2%E6%8A%A5%E9%94%99.png" alt="Pycharm中使用Pyside2报错 png" srcset="/images/home/Myhead.jpg" data-src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/Pycharm%E4%B8%AD%E4%BD%BF%E7%94%A8Pyside2%E6%8A%A5%E9%94%99.png" class="lozad post-image">  </p><h4 id="Nuke-命令行模式"><a href="#Nuke-命令行模式" class="headerlink" title="Nuke 命令行模式"></a>Nuke 命令行模式</h4><pre class="language-dos" data-language="dos"><code class="language-dos">&quot;C:\Program Files\Nuke12.2v2\python.exe&quot; &quot;D:\test.py&quot;</code></pre><p>运行脚本需使用Nuke的Python解释器，若后台调用脚本，可使用subprocess方法切换至Nuke本身的Python解释器。</p><p>若要使用 Pyside2 模块，需要在通过nuke主程序 nuke.exe 使用参数 -t 就可以运行Pyside2模块。</p><pre class="language-dos" data-language="dos"><code class="language-dos">&quot;C:\Program Files\Nuke12.2v2\nuke.exe&quot; -t &quot;D:\test.py&quot;</code></pre><p>但 -t 参数不能获取到 QApplication 类，只能获取到 QCoreApplication 类（QApplication是QCoreApplication的子类），所以要通过 --tg 参数来获取 Pyside2 模块创建窗口所需要的 QApplication 类。</p><pre class="language-dos" data-language="dos"><code class="language-dos">&quot;C:\Program Files\Nuke12.2v2\nuke.exe&quot; --tg &quot;D:\test.py&quot;</code></pre><p>nuke命令行语法：</p><p style="text-indent:4em">nuke.exe <\option> [<\argv>] <\script> [<\range>]</p>使用不同类别的主程序常用参数:<ul><li>--nukex</li><li>--studio</li><li>--nc</li><li>--nukeassist</li></ul><p>可以在Windows环境下使用doskey创建快捷键(只在当前窗口有效)，可以使用PATH环境变量，并写在一个bat脚本中：</p><pre class="language-dos" data-language="dos"><code class="language-dos">doskey nukex &#x3D; &quot;C:\Program Files\Nuke12.2v2\nuke.exe&quot; --nukex $*</code></pre><p>效果等于：<br>“C:\Program Files\Nuke12.2v2\nuke.exe” -- nukex &lt;\option&gt; [&lt;\argv&gt;] &lt;\script&gt; [&lt;\range&gt;] &#x3D; nukex &lt;\option&gt; [&lt;\argv&gt;] &lt;\script&gt; [&lt;\range&gt;]</p><p>一些常用的参数：</p><ul><li>-t 适用于纯命令行脚本</li><li>–tg 会产生一个 QApplication 实例，用于执行 Pyside2 的Gui相关脚本</li><li>-x &lt;\scriptname&gt; 渲染名为 \scriptname 的nuke工程中所有激活的write节点</li><li>-X&lt;\nodename&gt; 仅渲染指定名的\nodename的write节点</li><li>-F 指定帧范围</li><li>–cont 出错后继续渲染</li><li>–sro 按顺序依次渲染节点</li><li>-f 以全尺（full resolution）的方式打开nuk工程</li><li>-p 和-f相对，以 proxy 的方式打开nuke工程</li><li>-v 打开指定的图像文件，如果是视频，还需要跟上帧范围（文件路径使用正斜杠，不能使用反斜杠）</li><li>–pause 打开nuke工程时暂停 Viewer 初始化</li><li>-P 显示每个节点的资源占用情况</li><li>-Pf&lt;\filename&gt; 将每个节点的资源占用情况写入名为 \filename 的xml文件中</li><li>–multigpu 启用多gpu支持</li><li>–gpulist 列出当前系统可用的GPU及其索引号</li><li>–gpu ARG 使用由索引号ARG指定的GPU,在终端模式下启动GPU加速</li><li>–safe 安全模式，启动nuke不加载 .nuke、NUKE_PATH及OFX插件</li><li>-m # 指定线程数</li><li>-n 关闭节点postage stamps的预览显示</li><li>-q 关闭终端输出</li><li>-i 使用nuke_i授权，可与 -x 和 -t 连用，写成 -ti 或 -xi,默认情况下使用nuke_r授权，但有些操作需要使用nuke_i授权。</li><li>–remap&lt;\pathPair&gt; 仅能在命令行模式下使用，在当前会话中设置路径映射，要求参数为一对或多对路径拼成的字符串，用逗号分隔</li></ul>]]></content>
      
      
      <categories>
          
          <category> Nuke </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xgen毛发</title>
      <link href="/posts/20220729a1.html"/>
      <url>/posts/20220729a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了一些Maya中Xgen毛发渲染的相关的问题：<span id="more"></span></p><ol><li><p>Xgen 角色ABC和毛发ABC的运动模糊不匹配的问题（小概率事件）：</p><p style="text-indent:2em">原因是生长面缓存只有整数帧采样并且在渲染运动模糊时，Xgen没有计算生长面的插值,或者由于前后帧的运动差异过大，Xgen计算出错误的生长面插值，导致毛发生长面的缓存和角色缓存的插值不匹配，生长面缓存和角色缓存在小数帧位置不同，就会导致运动模糊不同。也可以通过实际文件观测到，在运动模糊有问题的小数帧，毛发不加载缓存时，其毛发引导线跟随动画缓存，加载了毛发缓存后，毛发缓存曲线和动画缓存的位置一致，而毛发引导线却和缓存曲线不在相同的位置，毛发引导线和动画缓存脱离，但是毛发引导线的形态和毛发缓存一致，说明毛发引导线只是从毛发缓存继承了形态，并不继承其位置。而毛发引导线的位置是从毛发生长面继承的，此时毛发引导线的位置和动画缓存不一致，那么小数帧时生长面的缓存和动画缓存位置不一致，因此，毛发生长面缓存在计算小数帧时有问题。解决此类问题，最好为动画缓存、曲线缓存、生长面缓存都添加缓存的小数帧采样插值。</p></li><li><p>前台批渲染带渲染运动模糊时，代码批量刷新生长面时报错‘not match object “XGEN_RENDER_:XXXX”’：</p><p style="text-indent:2em">Xgen毛发在渲染运动模糊后，会生成可通过xgen.palettes()获取，但是无法使用cmds.sl("")列出，也无法删除的临时生长面，该生长面以“XG_RENDR_:”为前缀，若要在渲染运动模糊后批量处理生长面，需要跳过它，不会有任何影响。该临时生长面不会记录到maya文件中，但是会存在当前软件中，哪怕你清除场景，并重开另一个场景，也可以查询到它，处理时需直接跳过，对渲染无影响。</p></li><li><p>abc流程中，对角色缓存位置进行修改（场景移回原点）过的灯光文件，其xGen毛发可能会炸毛，可能原因是引用文件记录了一些错误的操作，这部分操作导致xGen文件状态不对，需要删除.Xgen文件，重新引用毛发文件，或者先删除.Xgen文件、卸载引用文件、清除其操作历史，再加载引用文件。</p></li></ol><h4 id="Xgen-毛发创建笔记"><a href="#Xgen-毛发创建笔记" class="headerlink" title="Xgen 毛发创建笔记"></a>Xgen 毛发创建笔记</h4><h4 id="一些Xgen文件测试记录"><a href="#一些Xgen文件测试记录" class="headerlink" title="一些Xgen文件测试记录"></a>一些Xgen文件测试记录</h4><ol><li><p>使用不同名称、完全相同的两个集合体作为Xgen描述的生长面，其基本体随机种子数会有一些差异，随机种子数是根据物体的生长面名称进行hash计算得出的结果，若替换生长面对应的几何体名称，随机种子数会发生细微变化，从而导致效果会有细微差别。</p></li><li><p>xgen文件中只记录几何体的短名，不记录长名(可以手动修改的方式使用maya规范的长名，)，测试结果是只识别几何体短名称，不区分拓扑结构和形状以及uv，只使用.xgen文件中记录的的faceid面数，但拓扑结构不同结果肯定不一样，几何体名和生长面前缀应保持一致。</p></li><li><p>绘制的iff贴图在保存文件后才会写入工程目录的文件夹，描述下有几个生长面就保存几张贴图(从新的几何体添加新的生长面，需要重新绘制贴图，保存后也会对应新增一张贴图)，根据绘制贴图时的生长面_集合_描述名称，xgen中指定的贴图名称命名为：polySurfaceShape1_grass_col_grass_decmask_generator_grass)。</p></li><li><p>生长面跟随几何体放大缩小，但是毛发粗细不变(可写入表达式，待测试)。</p></li><li><p>确定了几何体、绑定几何体并生成生长面之后，不可以修改几何体的名称，指向文件(ptx，xuv等文件)记录的是以几何体命名的贴图名称，更改几何体命名称后，链接断开，指向文件失效。</p></li><li><p>使用相同几何体生成的不同描述，其生长面的名称为“几何体名称_描述名称”，不会重名</p></li><li><p>单个XGen文件的生长面、几何体可以改名;改完命名后直接更改其Xgen文件的几何体名称，另存文件即可;</p></li><li><p>使用几个几何体生成描述，集合下就拥有几个生长面(不建议使用多个几何体映射一个描述，最好先合并成一个几何体，方便管理)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排错记录 </tag>
            
            <tag> Xgen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deadline中调试编写的事件</title>
      <link href="/posts/20220721a1.html"/>
      <url>/posts/20220721a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h4><p style="text-indent:2em">Deadline 事件依赖于其软件框架，不能进行实时调试，但是可以通过 Console 窗口快速获取获取事件反馈信息。</p><span id="more"></span><p style="text-indent:2em">若想快速查看事件处理的过程，获取结果，首先通过Panels > Console 开启 Console 窗口。</p><p><img src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/Console.jpg" alt="Console图片" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/Console.jpg" class="lozad post-image"></p><p style="text-indent:2em">对于事件编写，除了要先配置正确的事件文件以外，还要在代码中加入打印（可通过 DeadlineEventListener 类的 self.LogInfo 或者 print 等方法将调试信息写入代码中，或通过ClientUtils.LogText(str)方法将信息写入 Deadline 的日志文件中），由于 Deadline 会每隔一段时间才会扫描储存库，扫描的默认值一般为5分钟，当扫描过程中发现事件脚本有新的修改时，才会将修改的事件脚本重新构建到任务中，所以，为了让 Deadline 后台及时更新并构建我们修改的事件脚本，我们需要通过Tools > Synchronize Monitor Script and Plugins 功能手动更新事件脚本。</p><p><img src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC.jpg" alt="同步脚本" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC.jpg" class="lozad post-image"></p><p style="text-indent:2em">此时，Console 窗口会提示：***事件脚本有修改，将重新构建事件脚本的提示语。如果你的脚本有语法错误，Console 窗口还会给你打印一条简短的报错信息。然后 Requeue 目标任务，再将任务切换到我们所要的任务状态（先更新脚本，再操作任务，不能先操作任务再更新脚本，否则，事件不会被更新到任务状态中），Deadline 便会通过当前执行任务的机器执行事件脚本，并在Console 窗口显示反馈信息。通过此方法，可以快速对我们的事件脚本进行编写和调试。</p><h4 id="关于事件脚本中使用中文"><a href="#关于事件脚本中使用中文" class="headerlink" title="关于事件脚本中使用中文"></a>关于事件脚本中使用中文</h4><p style="text-indent:2em">有时会在日志中打印中文信息，则我们需要将中文字符串编码为"gbk"（windows系统）的人类可读懂的代码。需要注意的是：</p><ul><li>需了解事件脚本在编写时，文本编辑器使用的编码格式是否为utf8，以及操作系统文件在编译中文时，使用的编码格式（Windows下控制台中的编码使用的是gbk）。因此，我们会在 python 脚本文件头部中加入 “# -<em>- coding:utf-8 -</em>-” 显式编码注释，文本编辑器在存储脚本时会做相应的修改。</li><li>中文字符很容易出错，导致插件执行被打断却没有任何反馈信息的假成功状态，这是由于当Deadline后台检测脚本有字符转换的错误时，它可不执行事件脚本。</li><li>测试 deadline 10.0.6.3 的 Python2 环境打印中文：中文字符串最后一个字符串不能为中文标点符号，否则会报语法错误（控制台在编码中文时，会将最后一个标点符号编码错误为一个‘？’号）。</li></ul>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-def __main__():    print(u&quot;测试中文打印&quot;.encode(&quot;gbk&quot;))    print(unicode(&quot;测试中文打印&quot;，&quot;utf-8&quot;).encode(&quot;gbk&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>测试在 deadline 10.1 的环境打印中文则很简单，和普通代码一样直接打印,字符串末尾可以有中文标点符号且不用进行字符编码，否则会报错：  <pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-def __main__():    print(&quot;测试中文打印。&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/2_Scripting%20Reference/index.html" title="" target="">1.官方文档中事件脚本文档</a></br><a href="http://www.mirrorcg.com/posts/20220306a1.html" title="" target="">2.往期相关文章：Deadline中的事件示例</a></br><a href="http://www.mirrorcg.com/posts/20220822a1.html" title="" target="">3.相关文章：Python代码中的字符编码</a>]]></content>
      
      
      <categories>
          
          <category> Deadline </category>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CG流程中的ACES概念解释</title>
      <link href="/posts/20220706a1.html"/>
      <url>/posts/20220706a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="ACES-一些散记"><a href="#ACES-一些散记" class="headerlink" title="ACES 一些散记"></a>ACES 一些散记</h4><p>  经过IDT转换的图片只能保证其在AECS色域中渲染的颜色信息和ACES相比较是正确的，不能保证渲染的效果和SRGB的原效果一致。<br>  线性图和非线性图的区别在于是否经过Gamma1.8到gamma2.2的曲线矫正,矫正的目的是为了迎合人眼观察的同时，方便使用8位图存储色彩信息。浮点图没有色彩存储空间不够的情况，因此浮点图一般是线性图。<br>  ACES推荐使用EXR、TIF、HDR等浮点图存储信息，最少使用16位(exr是HDR标准的图片格式，拥有多通道存储的能力，使用1位、5位、10位分段分别存储不同的信息)。<br>  CG流程中ODT用于ACES到SRGB色域的转换，通常是使用‘output_srgb’类型。<br>  Maya中输出的16位ACES图和32位图色彩信息有些许肉眼可见的不同。请自行测试。</p><h4 id="一些文章参考"><a href="#一些文章参考" class="headerlink" title="一些文章参考"></a>一些文章参考</h4><br><p style="text-indent:2em">国内网页：</p><a href="https://www.bilibili.com/video/BV1jM4y1N7yT?spm_id_from=444.41.top_right_bar_window_default_collection.content.click&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">ACES编码及色彩原理（CG）</a><br><a href="https://www.bilibili.com/video/BV1Fg411M7H6?p=1&share_medium=android&share_plat=android&share_session_id=665fc73f-fd8b-484a-9cb2-7bf453d6035e&share_source=WEIXIN&share_tag=s_i&timestamp=1656295742&unique_k=SDBzFDb&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">ACES通俗讲解</a><br><a href="https://www.bilibili.com/read/cv9842761" title="" target="">色彩原理</a><br><a href="https://www.bilibili.com/video/BV1dV411i7M1?spm_id_from=333.788.top_right_bar_window_default_collection.content.click&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">Nuke色彩空间（Gamma）的转换和原理</a><br><a href="https://www.shangyexinzhi.com/article/1960438.html" title="" target="">参考文章1</a><br><a href="https://www.toadstorm.com/blog/?p=694" title="" target="">参考文章2</a><br><a href="https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/" title="" target="">参考文章3</a><br><br><p style="text-indent:2em">以下需科学上网：</p><a href="https://www.youtube.com/watch?v=W9Z1Std_1Kc" title="" target="">ACES Workflow in Maya with Redshift and Arnold</a>]]></content>
      
      
      <categories>
          
          <category> Doc </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灯光合成 </tag>
            
            <tag> ACES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya中常用的部分环境变量</title>
      <link href="/posts/20220521a1.html"/>
      <url>/posts/20220521a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录 maya 中常用的部分环境变量。<span id="more"></span></p><ul><li>MAYA_ENABLE_LEGACY_RENDER_LAYERS      开启旧版灯光渲染分层系统（maya2017以后可使用）</li></ul><p>屏蔽 maya 连接网络</p><ul><li>MAYA_DISABLE_CIP &#x3D; 1</li><li>MAYA_DISABLE_CLIC_IPM &#x3D; 1</li><li>MAYA_DISABLE_CER &#x3D; 1</li></ul>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pipeline </tag>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows任务计划</title>
      <link href="/posts/20220510a1.html"/>
      <url>/posts/20220510a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>工作中有时需要定时执行一些规律性的脚本操作<span id="more"></span>，比如，清除磁盘垃圾、定时下载任务等。这些任务执行虽然简单，但是需要人力进行日常维护。通常有两种方式可以方便处理这类型任务：</p><ol><li>以本机作为脚本任务的执行者，开启电脑后，通过ide运行任务，但是每次开机都需要手动执行，或者将程序打包成exe程序再放入启动文件夹。</li><li>以本机作为服务器，通过任务计划的触发器，自动执行指定任务，不需要每次开机后再手动执行。</li></ol><p>下面将介绍第二种方式——任务计划</p><ul><li><p>打开计划任务程序</p><table><tr><td><img src="/images/Windows任务计划/打开管理工具.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Windows任务计划/打开管理工具.png" class="lozad post-image"></td><td><img src="/images/Windows任务计划/任务计划程序.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Windows任务计划/任务计划程序.png" class="lozad post-image"></td></tr></table></li><li><p>创建一个新的任务计划文件夹（推荐）或在“任务计划程序库”中创建基本任务:提一下”创建基本任务”和”创建任务”的区别是一个有引导界面，一个直接弹出设置界面直接设置。</p></li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1.png" alt="创建基本任务 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1.png" class="lozad post-image">  </p><ul><li>输入任务名称和描述。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%BE%93%E5%85%A5%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0.png" alt="输入任务名称和描述 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%BE%93%E5%85%A5%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0.png" class="lozad post-image">  </p><ul><li>选择触发器，修改触发器触发的时间和间隔，这里暂时只能创建一个触发器，我们可以创建完任务计划后进行添加或修改触发器。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="选择触发器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E8%A7%A6%E5%8F%91%E5%99%A8.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E4%BF%AE%E6%94%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E9%80%89%E9%A1%B9.png" alt="修改触发器选项 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E4%BF%AE%E6%94%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E9%80%89%E9%A1%B9.png" class="lozad post-image"> </p><ul><li>选择任务操作，并填入相关参数，这里很重要，它可以决定你的任务计划是否正常执行，原则上越简单越好（后面会进行详解）；然后点击完成。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C.png" alt="选择任务操作 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%84%9A%E6%9C%AC.png" alt="设置启动程序的脚本 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%84%9A%E6%9C%AC.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%AE%8C%E6%88%90%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1.png" alt="完成创建任务 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%AE%8C%E6%88%90%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1.png" class="lozad post-image"> </p><ul><li>“创建基本任务”完成后，我们还需要对其进行一些的修改；选择任务点击属性对任务进行修改。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%B8%B8%E8%A7%84%E8%AE%BE%E7%BD%AE.jpg" alt="常规设置 jpg" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%B8%B8%E8%A7%84%E8%AE%BE%E7%BD%AE.jpg" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="触发器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%A7%A6%E5%8F%91%E5%99%A8.png" class="lozad post-image"><br>  “操作”项暂不做修改；”条件”项也比较简单，都是字面意思，这里不做讲解；<br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E8%AE%BE%E7%BD%AE.jpg" alt="设置设置 jpg" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E8%AE%BE%E7%BD%AE.jpg" class="lozad post-image"><br>  note：每次手动运行任务后，若任务状态没有更改成预期状态，可通过右键任务选择“刷新”选项进行任务状态的刷新。</p><ul><li>关于”操作”项中的设置需要注意：由于我们使用的是.bat脚本中通过python程序调用.py脚本，因此这里的”程序或脚本”填入 XXX\test.bat(不加引号)，”添加参数（可选）”为空，“起始于（可选）”则是.py文件所在的目录，而不是执行程序或者.bat脚本所在的目录，否则执行的结果会出错；若不填(缺省状态)，那么自动将该处的目录位置定位到”程序或脚本”的目录位置。并且调用的程序需要传入参数，例如”程序或脚本”填入Python编译器路径 C:\Python27\python.exe ，而”添加参数（可选）”为.py文件，那么“起始于（可选）”则是.py文件所在的目录。最后说一下，任务计划中所用到的所有的文件最好放置在本地路径。</li></ul><h4 id="实践踩坑和解决办法"><a href="#实践踩坑和解决办法" class="headerlink" title="实践踩坑和解决办法"></a>实践踩坑和解决办法</h4><p style="text-indent:2em">在这次工作中由于需要每天调用pythonAPI对程序的服务端进行调整，因此使用了任务计划调用bat脚本的方式执行任务。该bat脚本中，仅简单的一句'XXX/python.exe XXX/XXX/xxx.py'---使用编译器编译python脚本，该任务在我本机上执行没有任务问题，于是将任务计划部署到农场机器上，此时任务就出现了问题：创建的任务不会成功执行，或者执行结果不为'成功执行（0X0）',或者执行结果为'成功执行（0X1）'（失败状态）或者直接失败，找了很久的原因，排除几乎所有的可能性（计算机休眠、计算机系统配置不对、任务权限不够、bat脚本有问题、.py脚本有问题、任务手动运行后状态没有及时切换导致新实例不能创建、不能访问网络盘资源、脚本“起始于（可选）”参数不对、执行程序带引号等等）。最后本着"越简单越好"的原则，直接将bat脚本拆开，将python编译器的位置填入"程序或脚本"，"添加参数（可选）"填入.py脚本，“起始于（可选）”填入.py脚本路径，问题才得到解决。</p><p style="text-indent:2em">猜测和计算机系统有关，由于我本机使用的是Windows10 的操作系统，而农场机使用的是Windows server2012 的操作系统。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>官方介绍：<a href="https://forsenergy.com/zh-cn/gpmc/html/688d2d42-454a-4e2e-90c0-557f959d49b0.htm">https://forsenergy.com/zh-cn/gpmc/html/688d2d42-454a-4e2e-90c0-557f959d49b0.htm</a><br>参考文章：<a href="https://www.jianshu.com/p/c627c77f6ea3">https://www.jianshu.com/p/c627c77f6ea3</a></p>]]></content>
      
      
      <categories>
          
          <category> Doc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排错记录 </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deadline如何使用PythonAPI</title>
      <link href="/posts/20220505a1.html"/>
      <url>/posts/20220505a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p style="text-indent:2em">本文介绍如何使用 Deadline 的 Python API 操作Deadline。<span id="more"></span>通过 Python API 可在 Python 中与 HTTP API 通信。</p><h4 id="拷贝-PythonAPI-模块"><a href="#拷贝-PythonAPI-模块" class="headerlink" title="拷贝 PythonAPI 模块"></a>拷贝 PythonAPI 模块</h4><p style="text-indent:2em">首先在使用 API 之前，需要配置python环境使我们可以调用到 API。我们需要安装和使用 python2.7.9或 3.7 以上的python版本，然后将 Deadline 储存库路径（//your/repository/api/python）下的整个“Deadline”文件夹复制到Python 安装路径下的的“site-packages”文件夹，API 即可调用。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E6%8B%B7%E8%B4%9DPythonAPI.png" alt="Deadline拷贝PythonAPI" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E6%8B%B7%E8%B4%9DPythonAPI.png" class="lozad post-image"></p><h4 id="开启-WebService-服务"><a href="#开启-WebService-服务" class="headerlink" title="开启 WebService 服务"></a>开启 WebService 服务</h4><p style="text-indent:2em">我们还需要通过 WebService 通信以发送和接收请求，因此，还要在 Deadline 管理的局域网中的任何一台可见的设备上运行 WebService服务，该服务为“C:\Program Files\Thinkbox\Deadline10\bin\deadlinewebservice.exe”，打开后，我们就可以通过该设备的设备名称或者Ip地址进行通讯，API访问的端口默认情况下为8082。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/DeadlineWebServer.png" alt="DeadlineWebServer" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/DeadlineWebServer.png" class="lozad post-image"></p><h4 id="使用-PythonAPI"><a href="#使用-PythonAPI" class="headerlink" title="使用 PythonAPI"></a>使用 PythonAPI</h4><p style="text-indent:2em">使用时，必须创建一个 DeadlineCon 对象。该对象用于与 WebService 通信以发送和接收请求，该对象需要两个参数：“运行 WebService 服务的设备名或IP地址”、“该设备上允许 WebService 通信的端口号（默认为8082）”，这两个参数可以从已经运行的 WebService 通讯服务上找到。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="Deadline设备名称和端口号" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" class="lozad post-image"></p><p>然后我们就可以使用API创建一个连接对象“connectionObject &#x3D; Deadline.DeadlineConnect.DeadlineCon(‘WebServiceName’, WebServicePortNumber)”， 通过该对象，我们可以查询、修改 Deadline 上的大部分信息。</p><p>示例代码1：查询作业组、暂停指定作业</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import Deadline.DeadlineConnect as Connect  # 导入 Deadline.DeadlineConnect 作为连接connectionObject &#x3D; Connect.DeadlineCon(&#39;DESKTOP-Mirror&#39;, 8082)print(connectionObject.Groups.GetGroupNames())#[&quot;group1&quot;,&quot;group2&quot;,&quot;group3&quot;]jobId &#x3D; &quot;622c38262812473ba4c08eca&quot;  #(有效的job ID号)print(connectionObject.Jobs.SuspendJob(jobId))# &#39;Success&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码2：提交作业</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import Deadline.DeadlineConnect as ConnectDeadline &#x3D; Connect.DeadlineCon(&#39;DESKTOP-Mirror&#39;, 8082)JobInfo &#x3D; &#123;    &quot;Name&quot;: &quot;Submitted via Python&quot;,    &quot;UserName&quot;: &quot;UserName&quot;,    &quot;Frames&quot;: &quot;0-1&quot;,    &quot;Plugin&quot;: &quot;VraySpawner&quot;&#125;PluginInfo &#x3D; &#123;    &quot;Version&quot;: &quot;Max2014&quot;&#125;try:    newJob &#x3D; connectionObject.Jobs.SubmitJob(JobInfo, PluginInfo)    print(newJob)except:    print(&quot;Sorry, Web Service is currently down!&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li>官方说明：<a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/3_Python%20Reference/index.html#intro_sec">https://docs.thinkboxsoftware.com/products/deadline/10.1/3_Python%20Reference/index.html#intro_sec</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Deadline </category>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya中材质文件和缓存文件相结合进行渲染的几种方式</title>
      <link href="/posts/20220503a6.html"/>
      <url>/posts/20220503a6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p style="text-indent:2em">本文记录材质文件和缓存文件相结合，组装渲染镜头文件的几种方式.<span id="more"></span></p><h3 id="缓存驱动材质文件进行渲染"><a href="#缓存驱动材质文件进行渲染" class="headerlink" title="缓存驱动材质文件进行渲染"></a>缓存驱动材质文件进行渲染</h3><p>使用缓存文件驱动材质文件的方式进行渲染。</p><h3 id="缓存文件直接替换材质文件的几何体进行渲染"><a href="#缓存文件直接替换材质文件的几何体进行渲染" class="headerlink" title="缓存文件直接替换材质文件的几何体进行渲染"></a>缓存文件直接替换材质文件的几何体进行渲染</h3><h3 id="缓存文件包裹材质文件进行渲染"><a href="#缓存文件包裹材质文件进行渲染" class="headerlink" title="缓存文件包裹材质文件进行渲染"></a>缓存文件包裹材质文件进行渲染</h3><h3 id="给缓存文件赋予材质进行渲染"><a href="#给缓存文件赋予材质进行渲染" class="headerlink" title="给缓存文件赋予材质进行渲染"></a>给缓存文件赋予材质进行渲染</h3>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pipeline </tag>
            
            <tag> 灯光 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya软件渲染问题集锦</title>
      <link href="/posts/20220503a5.html"/>
      <url>/posts/20220503a5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>渲染崩溃可能的问题：</p><ul><li>被赋予Arnold材质3s散射的物体是片，导致散射时不是在物体内部散射，而是在整个场景中散射，计算量特别大从而崩溃。</li><li>文件中毛发的密度太大导致渲染机内存不够用。</li><li>文件本身有问题。</li><li>具体问题，具体分析。</li></ul></li><li><p>Redshift:提示：’Mesh pCubeShape1 is instanced and uses adaptive tessellation, which isn’t supported. Disabling tessellation. If you need tessellation, please use fixed tessellation settings: i.e. disable ‘screen space adaptive’ and set ‘min edge length’ to zero to force a maximum tessellation level’。对象细分后在实例错误提示：对象在实例化后细分，被实例化对象在屏幕自适应时找不到细分对象，就不会进行细分。如果需要细分，就关闭屏幕自适应，并把最小边缘强度设置为零，以强制使用最大边缘强度，如图：</p><p> <img src="/images/Maya%E8%BD%AF%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/Redshift%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%86%E5%88%86.png" alt="Redshift实例对象自适应细分" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E8%BD%AF%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/Redshift%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%86%E5%88%86.png" class="lozad post-image"></p></li><li><p>农场机提示找不到可执行渲染的文件：“Katana render executable was not found in the semicolon separated list”（在分号分隔的列表中没有找到Katana渲染的可执行文件），该机器上没有安装相应的软件，或软件没有安装在默认的路径。</p></li><li><p>Cannot find procedure “pgYetiVRayPreRender”（或”pgYetiPreRender”）报错导致渲染暂停：渲染文件中没有Yeti毛发节点，却在渲染文件的渲染设置中填入了“pgYetiVRayPreRender”（或”pgYetiPreRender”）代码，导致渲染器找不到对应的节点而报错，我们只需要打开文件，删除渲染设置中的以下代码就行了（Render Settings &gt; Common &gt; Render Options，删除报错的MEL，一般情况下也可以全部删除）：</p> <table><tr> <td><img src="/images/Maya软件渲染问题集锦/Yeti报错.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/Yeti报错.png" class="lozad post-image"></td> <td><img src="/images/Maya软件渲染问题集锦/删除Yeti报错设置.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/删除Yeti报错设置.png" class="lozad post-image"></td> </tr></table></li><li><p>贴图文件正在上传或修改。日志出现：File“*******”was modified after being opened by OIIO，这是因为文件在渲染的时候，被文件IO读取的贴图文件还在上传或更新中<br> 解决办法：等待贴图上传完成后再渲染文件</p></li><li><p>盘符掉了或没有输出磁盘：<br> 解决办法：映射一个盘符</p> <pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">subst D: C:\D  ::映射D盘盘符到C盘的D文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Deadline农场渲染报错“defaultRenderLayer” is a layer from a referenced and is not allowed to be the current layer ,其可能是之一是：maya 的 renderLayerManage节点被改名导致 maya 不能生成默认的master layer渲染层（在.ma文件中的名称为defaultRenderLayer），因此可以将文件保存为.ma格式的文件，用文本的方式打开，将renderLayerManager节点的名称改为默认的’renderLayerManager’(没有任何修饰)，同时由于默认的renderLayerManager节点已经被修改过，默认的渲染层名称也发生了改变，导致渲染程序在调用的代码中，该层被判定为非默认的渲染层而报错“unable to modify overrides to the default layer”,因此，还需要将文件中的 defaultRenderLayer节点 (本问题记录时该节点名称为 defaultRenderLayer1 ),改为默认的名称defaultRenderLayer，即可。</p></li><li><p>maya动画文件直渲，后台批量渲染时，角色控制器带动角色模型不规则抖动的可能原因：这是旧版绑定系统的问题，这种问题一般可通过走 abc 流程规避，否则需要更新绑定的 cluster 节点选项。禁用”cluster.relative”，并将”cluster.angleInterpolation”的值设置为3，代码如下：</p> <pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">import maya.cmds as mcfor each in mc.ls(typ&#x3D;&quot;cluster&quot;):mc.setAttr(&quot;cluster1.relative&quot;, 0)mc.setAttr(&quot;cluster1.angleInterpolation&quot;, 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>maya动画文件直渲，后台批渲时，动画文件中的约束失效，例如角色对道具的约束丢失或者效果不对；可能原因：</p><ul><li>动画文件后台渲染其中的动力学不出缓存，会重新计算。</li><li>动画文件后台渲染时表达式会失效。<br>解决办法：（1）烘焙动画曲线：选择绑定组大组执行 Animation &gt; Key &gt; Bake Simulation 等待读条完成后会将控制器的每一帧都K上关键帧，然后再提交渲染即可；（2）在Premel中填入可拖动时间滑块到当前帧的mel表达式，该表达式会在渲染开始前对镜头中的帧进行切换，从开始帧逐渐切换至当前帧，相当于对文件中的控制器进行了一次”脏”运算。达到数据正确的目的。（3）走 abc 流程。</li></ul></li><li><p>maya 创建polygon报错：error line0:connection not made :”****.instObjGroup[0]”-initalShaderGroup.dagSetMembers[-1].destination is locked:可能原因：</p><ul><li>相关节点被锁</li><li>相关属性被锁<br>解决办法：解锁相关节点或相关属性，或者重启 Maya 可解决问题。</li></ul></li><li><p>后台渲染丢材质报错：[mtoa][translator polymesh] ShadingGroup ******:*****SG has no faceShader input …。可能原因：材质没有连接上对应模型或制作过程中切换过不同的渲染器，导致材质与物体mesh的链接断开；<br>解决办法：修改材质文件中的材质链接或重新连接材质，注意查看材质文件的材质、渲染器输出信息；或先赋予Lambert材质,再重新赋予原来的材质。</p></li><li><p>后台渲染和前台渲染的exr图片颜色空间不一致，或颜色不一致。可能原因：</p><ol><li>首选项中勾选了的 Preferences &gt; Output color preferences &gt; Apply Output Transform to Render ，并将Output Transform 设置为 Use View Transform ,该选项会应用 Preferences &gt; Color Transform Preferences 中的 View Transform 值到输出图片，该选项的作用是将渲染预览的结果转换并应用到输出图片（包括色彩空间），如果渲染预览的图片为sRGB编码的色彩空间图，则输出图片也会转换为sRGB色彩空间的图（如下图左1）。</li><li>渲染器驱动节点的”defaultArnoldDriver.colorManagement”渲染设置为了 Use View Transform ，其默认值为 Use Output Transform，原因和 1 一致（正确设置如下图右1所示）。<br>选中驱动节点代码：<pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">mc.select(&quot;defaultArnoldDriver.colorManagement&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><tr><td><img src="/images/Maya软件渲染问题集锦/渲染空间不一致首选项设置 .png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/渲染空间不一致首选项设置 .png" class="lozad post-image"></td><td><img src="/images/Maya软件渲染问题集锦/渲染空间不一致节点选项设置.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/渲染空间不一致节点选项设置.png" class="lozad post-image"></td></tr></table></li></ol></li><li><p>同一个场景代理文件，渲染颜色不一致、闪烁，可能原因：代理文件导入maya后，其材质网络被修改过，使两个aistand_in使用相同的代理颜色却不一样，从而产生错误（原因未知）。解决办法：1.改会原来的材质。2.修改使用两个不同的代理文件。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排错记录 </tag>
            
            <tag> 锦囊小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya软件小知识点</title>
      <link href="/posts/20220503a4.html"/>
      <url>/posts/20220503a4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>贴图色彩空间被锁定的情况，解锁所有节点贴图的贴图色彩空间选项：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmdsfor i in cmds.ls(type&#x3D;&#39;file&#39;):    cmds.connectAttr(&quot;:defaultColorMgtGlobals.cme&quot;,i+&quot;.cme&quot;,f&#x3D;1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>脚本切换渲染器:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">cmds.setAttr(&quot;defaultRenderGlobals.currentRenderer&quot;, &quot;arnold&quot;, type&#x3D;&quot;string&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取当前视图快照拍屏：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">ws &#x3D; cmds.workspace(q &#x3D; True, fullName &#x3D; True)wsp &#x3D; ws + &quot;&#x2F;&quot; + &quot;images&quot;imageSnapshot &#x3D; wsp + &quot;&#x2F;&quot; + &quot;endSnapshot.jpg&quot;cmds.refresh(cv&#x3D;True, fe &#x3D; &quot;jpg&quot;, fn &#x3D; imageSnapshot)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>脚本设置渲染设置的输出序列图选项：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">mc.setAttr(&quot;defaultRenderGlobals.animation&quot;, True)  # 开启动画帧序列mc.setAttr(&quot;defaultRenderGlobals.animationRange&quot;,1)  # 开启动画帧的范围mc.setAttr(&quot;defaultRenderGlobals.outFormatControl&quot;, 1)  # 设置帧格式mc.setAttr(&quot;defaultRenderGlobals.putFrameBeforeExt&quot;, 1) # 设置图片格式在数字后面（name.#.ext）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建多相机渲染：</p><ul><li>选择相机&gt;AtteibutsEdit&gt;OutputSettings&gt;Renderable(勾选)</li><li>RenderSetting&gt;RednderableCamera&gt;Add RenderableCamera</li></ul></li><li><p>Arnold开关运动模糊要同时设置运动模糊可见性:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">mc.setAttr(&quot;defaultRenderGlobals.motionBlur&quot;, 0) #关闭运动模糊（针对于Arnold）mc.setAttr(&quot;defaultArnoldRenderOptions.motion_blur_enable&quot;, 0) #关闭运动模糊可见性mc.setAttr(&quot;defaultRenderGlobals.motionBlur&quot;, 1) #开启运动模糊mc.setAttr(&quot;defaultArnoldRenderOptions.motion_blur_enable&quot;, 1) #开启运动模糊可见性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>脚本打印部分渲染节点属性名称和值的方式:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds render_glob &#x3D; &quot;defaultRenderGlobals&quot;list_Attr &#x3D; cmds.listAttr(render_glob, r&#x3D;True, s&#x3D;True)for attr in list_Attr:    get_attr_name &#x3D; &quot;%s.%s&quot;%(render_glob, attr)    print &quot;setAttr %s %s&quot;%(get_attr_name, cmds.getAttr(get_attr_name))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>mtoa 创建和访问AOV:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import mtoa.aovs as aovs# 添加aovaovs.AOVInterface().addAOV(&#39;aov名称&#39;, aovType&#x3D;&#39;float&#39;)# 列出活动状态的aovsaovs.AOVInterface().getAOVs()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Arnold代码加载arnold渲染器并创建默认节点：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcimport mtoa.coremc.setAttr(&quot;defaultRenderGlobals.currentRenderer&quot;,&quot;arnold&quot;,typ&#x3D;&quot;string&quot;)mtoa.core.createOptions()  # 创建ar默认节点网络<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看 mel 函数帮助：<br>使用 “whatIs ‘mel命令’;” 可以查看mel函数帮助。</p></li><li><p>设置maya视图窗口为非显卡（不使用显卡）支持的窗口模式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcdef switch_preview():    all_model_panel &#x3D; mc.getPanel(typ&#x3D;&quot;modelPanel&quot;)    for each in all_model_panel:        mc.modelEditor(each,e&#x3D;True,rnm&#x3D;&quot;base_OpenGL_Renderer&quot;)  # 查询可用的渲染器名称 mc.modelEditor(each,q&#x3D;True,rendererList&#x3D;True) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Xgen相关:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import xgenm.xmaya.xgmExternalAPI as xgenmExternalAPIimport xgenm as xgpalettes &#x3D; xg.palettes()  # 获取Xgen 所有描述if not (xgenmExternalAPI.xgg.DescriptionEditor is None):    xgenmExternalAPI.xgg.DescriptionEditor.refresh(&quot;Full&quot;)  # 刷新所有Xgen面板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>开启软件时关闭材质刷新</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cmds.scriptJob(event&#x3D;(&#39;SceneOpened&#39;,&#39;cmds.renderThumbnailUpdate(False)&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>添加回调</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.OpenMaya as OpenMayaOpenMaya.MSceneMessage().addCallback(37, funcName)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>清除进程任务</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymel.core.language as pcl_jobs &#x3D;pcl.scriptJob(lj&#x3D;1)#.清除内存任务 if._jobs:for _job in _jobs:    job_id &#x3D; int(_job.split(&#39;:&#39;)[0])    print(u&#39;清除进程任务:%s&#39; % _job)     try:        pcl.scriptJob(kill&#x3D;job_id, force&#x3D;True)    except:        pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排错记录 </tag>
            
            <tag> 锦囊小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya软件小问题集锦</title>
      <link href="/posts/20220503a3.html"/>
      <url>/posts/20220503a3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了一些Maya中出现的一些小问题：<span id="more"></span></p><ol><li><p>AOV无法正常创建</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcmc.lockNode(&#39;initialParticleSE&#39;,l&#x3D;0,lu&#x3D;0)mc.lockNode(&#39;initialShadingGroup&#39;,l&#x3D;0,lu&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Maya 操作总是提示 “&#x2F;&#x2F; Error: line 1: Cannot find procedure “onModelChange3dc”. &#x2F;&#x2F;“，这可能是模型制作的时候打开了某个窗口，maya在关闭的时候会保存一份配置在maya文件里，可以从Expression Editor的By Script Node Name里看到，虽然没什么影响，但是真的很烦。解决办法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymel.core as pm# 获取Maya中的所有模型编辑器并重置 editorChanged 事件for item in pm.lsUI(editors&#x3D;True):   if isinstance(item, pm.ui.ModelEditor):       pm.modelEditor(item, edit&#x3D;True, editorChanged&#x3D;&quot;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>RenderSetting渲染面板内容空白，执行mel脚本:</p><pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">deleteUI unifiedRenderGlobalsWindow;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>关闭“cannot find procedrure ‘look’”：</p><ul><li><p>执行mel脚本:</p><ul><li>方法一：<pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>方法二：<pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">global proc look()&#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>执行python脚本:</p> <pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">maya.mel.eval(&#39;outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;&#39;) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>删除TurtleDefaultBakeLayer层：</p><ul><li><p>执行mel脚本</p> <pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">&#x2F;&#x2F;删除海龟渲染 mel脚本lockNode -l off TurtleDefaultBakeLayer;delete TurtleDefaultBakeLayer;lockNode -l off TurtleRenderOptions;delete TurtleRenderOptions;lockNode -l off TurtleBakeLayerManager;delete TurtleBakeLayerManager;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行python脚本</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">def delTurtleRender():    if mc.objExists(&#39;TurtleRenderOptions&#39;):        mc.lockNode(&#39;TurtleRenderOptions&#39;, &#39;TurtleUIOptions&#39;, &#39;TurtleBakeLayerManager&#39;, &#39;TurtleDefaultBakeLayer&#39;, lock&#x3D;0)        mc.delete(&#39;TurtleRenderOptions&#39;, &#39;TurtleUIOptions&#39;, &#39;TurtleBakeLayerManager&#39;, &#39;TurtleDefaultBakeLayer&#39;)        print u&quot;海龟渲染节点清理完成&quot;    else:        print u&quot;场景中海龟渲染节点已清理干净&quot;delTurtleRender()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Maya Arnold不能渲染:<br> &#x2F;&#x2F; Rendering with Arnold Renderer… &#x2F;&#x2F;<br> &#x2F;&#x2F; Result: Rendering Completed. See mayaRenderLog.txt for information. &#x2F;&#x2F;<br> 是因为Maya 的mtoa环境变量丢失，导致渲染器使用的部分文件没有调用到，因此直接结束渲染。<br> 解决办法：<br> <a href="https://support.solidangle.com/display/AFMUG/Batch+Rendering">https://support.solidangle.com/display/AFMUG/Batch+Rendering</a> 的Batch Render Flags   提到了解决问题的办法，就是在环境变量中增加如下环境变量（对应maya版本号）：<br> MAYA_RENDER_DESC_PATH&#x3D;C:\solidangle\mtoadeploy\对应maya版本号<br> 然后，重新打开maya渲染。或者，重新安装渲染器，此办法有概率解决问题。</p></li><li><p>高版本Maya(2020以上)不能加载Arnold渲染器的问题：需要打补丁程序VC_redist.x64.exe。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排错记录 </tag>
            
            <tag> 锦囊小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya文件打开慢或者崩溃的检查办法</title>
      <link href="/posts/20220503a2.html"/>
      <url>/posts/20220503a2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目制作过程中常常会遇到制作文件打不开或者打开慢的情况，对于此类问题：<span id="more"></span></p><ol><li><p>如果是’.mb’文件，会比较麻烦些，需要在打开文件时不加载引用文件，然后一个一个加载引用文件，根据引用文件的加载情况进行判断是否有引用文件有问题。一般会出现：单个引用文件加载崩溃、单个引用文件加载慢、所有引用文件加载都没问题，但是保存后还是打开有问题，这时就需要分别尝试打开带有加载不同引用文件的maya文件。（之前碰到过引用文件中有的节点有冲突：相同的引用文件单独加载都没问题，但保存后加载会崩溃，然后逐步定位加载有问题的文件一步一步排除，最后将有冲突的节点重建才解决问题。）</p></li><li><p>如果是’.ma’文件：</p><ul><li>使用上面的’.mb’文件的办法。</li><li>在文件中插入 mel 脚本，在打开脚本的同时，执行mel脚本，通过脚本的日志内容情况来判断是什么文件导致的‘.ma’文件打不开，或者打开慢的情况。</li></ul></li></ol><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import codecsdef checkMayaAsciiFile(source_file, target_file, log_file):    &quot;&quot;&quot;    1. 用于检查 Maya Ascii 文件打开崩溃    2. - - - - - - - - - - - - - -耗时    Args:        source_file: ma 文件        target_file: 修改后的文件        log_file: logging    Returns: none    &quot;&quot;&quot;    # # 记录打不开的ma文件是从哪一行崩溃的    # __startMel &#x3D; &#39;&#39;&#39;python(&quot;logFile&#x3D;&#39;%s&#39;;ff &#x3D; open(logFile,&#39;w&#39;);ff.write(&#39; &#39;);ff.close();&quot;);&#39;&#39;&#39; % log_file    # __proc &#x3D; &#39;&#39;&#39;python(&quot;ff &#x3D; open(logFile,&#39;a&#39;);ff.write(&#39;%s - &#123;0&#125;\\\\n&#39;.format(comp_time));ff.close();&quot;);\n&#39;&#39;&#39;    # __endMel &#x3D; &quot;&quot;    # 记录打开文件时的耗时信息    __startMel &#x3D; &#39;&#39;&#39;python(&quot;from datetime import datetime;import time;line_time&#x3D;datetime.now();time.sleep(0.002);threshold_time&#x3D;datetime.now() - line_time;start_time&#x3D;line_time;logging&#x3D;list();logFile&#x3D;&#39;%s&#39;&quot;);&#39;&#39;&#39; % log_file    __proc &#x3D; &#39;&#39;&#39;python(&quot;comp_time &#x3D; datetime.now() - line_time;logging.append(&#39;%s - &#39;+ str(comp_time)) if comp_time &gt; threshold_time else None;line_time &#x3D; datetime.now();&quot;);\n&#39;&#39;&#39;    __endMel &#x3D; &#39;&#39;&#39;python(&quot;logging.append(&#39;\\\\n\\\\nStart Time - &#39;+ str(start_time) + &#39;\\\\nEnd Time - &#39;+ str(line_time) + &#39;\\\\nTotal Time - &#39; + str(line_time - start_time));ff &#x3D; open(logFile,&#39;w&#39;);[ff.write(line+&#39;\\\\n&#39;) for line in logging];ff.close();&quot;);&#39;&#39;&#39;    with codecs.open(source_file, &quot;r&quot;, &quot;gbk&quot;) as f:        aLines &#x3D; f.readlines()    fileter &#x3D; (&quot;select&quot;, &quot;connectAttr&quot;, &quot;dataStructure&quot;, &quot;createNode&quot;, &quot;requires&quot;, &quot;currentUnit&quot;)    # other relationship fileInfo    rule &#x3D; 1    for num, line in enumerate(aLines):        line_add &#x3D; &quot;&quot;.join([aLines[num - 1][:-1], __proc % str(num)])        if rule:  # 文件开头的 file 每一行都加 mel            if __startMel:  # 文件开头结尾初始化命令                aLines[num] &#x3D; __startMel + line                if __endMel:                    aLines[num - 1] &#x3D; __endMel + aLines[num - 1]                __startMel &#x3D; 0                continue            if &quot;file&quot; in line:  # 可能有的设置里会有file字符串,所以这里要独立规则                if &quot;;\n&quot; not in aLines[num - 1]:                    continue                aLines[num - 1] &#x3D; line_add            if &quot;requires&quot; in line:  # requires 之后改变规则                rule &#x3D; 0        # 在 fileter 参数里的,对它的前一行添加 mel        # setAttr 用的是 .attr 的方式,在它之后加 mel 会影响下一个 setAttr 所以这里添加这个过滤        for _ in fileter:            if _ in line:                if &quot;;\n&quot; in aLines[num - 1]:                    aLines[num - 1] &#x3D; line_add    with codecs.open(target_file, &quot;w&quot;, &quot;gbk&quot;) as ff:        for lines in aLines:            ff.write(lines)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    srcFile &#x3D; r&quot;E:\test\shot00401.ma&quot;    srcFile &#x3D; srcFile.replace(&quot;\\&quot;, &quot;&#x2F;&quot;)    sourceFile &#x3D; srcFile    targetFile &#x3D; srcFile[:-3] + &quot;_v01.ma&quot;    logFile &#x3D; srcFile[:-3] + &quot;_v01.txt&quot;    # print(sourceFile, targetFile, logFile)    checkMayaAsciiFile(sourceFile, targetFile, logFile)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，需要将”E:\test\shot00401.ma”替换成你的‘.ma’文件路径，执行完成后，会在同级文件目录下生成一个版本号为‘-v01’的‘.ma’文件，使用Maya打开该文件，打开文件的同时会执行文件中的mel脚本保存日志信息，文件读取完成后，也会在统计目录下生成一个版本号为‘-v01’的txt日志文件，打开文件分析即可。</p><h4 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h4><p>部分内容转载自：<a href="https://ruben.blog.csdn.net/article/details/90082639">https://ruben.blog.csdn.net/article/details/90082639</a></p>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 检查 </tag>
            
            <tag> 排错记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya中在物体的点上创建跟踪对象</title>
      <link href="/posts/20220503a1.html"/>
      <url>/posts/20220503a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">之前做测量相机焦距工具的时候发现不能把焦距添加约束到物体上的点，尤其是做了abc缓存之后，由于并没有对点进行编辑，不管是在自身空间还是世界空间中，点的位置在数值上都没有变换，被约束的相机的焦点依旧保持在原地，因此对点添加普通的的约束并不能达到效果，我们需要换一种方式进行约束。<span id="more"></span></p><p style="text-indent:2em">可以使用给点创建毛囊的办法，利用uv映射的点的位置始终保持不变，但是物体的世界矩阵在变化的原理，将点世界坐标的信息传递给毛囊，毛囊会一直跟着点的，此时我们只需要约束毛囊就能达到我们想要的效果了。</p><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-# !&#x2F;usr&#x2F;bin&#x2F;env python27# @Author: Mirror# @Time: 2022-03-15# description: 该脚本用于在选中点的位置上创建定位毛囊，该毛囊通过UV点定位，所有使用后不能调整点所在的UV# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;import maya.cmds as mcdef buildFollicle(points):    if not points:        return    if type(points).__name__ &#x3D;&#x3D; &quot;str&quot;:        points &#x3D; [points]    for point in points:        poly_transform &#x3D; mc.listRelatives(mc.listRelatives(point, p&#x3D;True, s&#x3D;True)[0], p&#x3D;True, s&#x3D;True)[0]        point_uvVertex &#x3D; mc.polyListComponentConversion(point, fv&#x3D;True, tuv&#x3D;True)        point_uvposition &#x3D; mc.polyEditUV(point_uvVertex[0], q&#x3D;1)        follicle &#x3D; mc.createNode(&quot;follicle&quot;, n&#x3D;&quot;follicle_%s&quot; % point.replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;, &quot;&quot;).replace(&quot;.&quot;, &quot;_&quot;))        follicle_transform &#x3D; mc.listRelatives(follicle, p&#x3D;True)[0]        mc.connectAttr(poly_transform + &quot;.worldMatrix[0]&quot;, follicle + &quot;.inputWorldMatrix&quot;)        mc.connectAttr(poly_transform + &quot;.outMesh&quot;, follicle + &quot;.inputMesh&quot;)        mc.connectAttr(follicle + &quot;.outTranslate&quot;, follicle_transform + &quot;.translate&quot;)        mc.connectAttr(follicle + &quot;.outRotate&quot;, follicle_transform + &quot;.rotate&quot;)        mc.setAttr(follicle_transform + &quot;.parameterU&quot;, point_uvposition[0])        mc.setAttr(follicle_transform + &quot;.parameterV&quot;, point_uvposition[1])if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    vertexs &#x3D; mc.ls(sl&#x3D;True,fl&#x3D;True)    buildFollicle(vertexs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：在添加了定位的毛囊之后，不能修改UV，否则毛囊会回到原点，约束失效，需要重新创建毛囊和约束。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>官网中相关的介绍：<a href="https://help.autodesk.com/view/MAYAUL/2018/CHS/?guid=GUID-A0D2DD53-FE41-4244-8635-CD4651ABF97F">https://help.autodesk.com/view/MAYAUL/2018/CHS/?guid=GUID-A0D2DD53-FE41-4244-8635-CD4651ABF97F</a></p>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灯光 </tag>
            
            <tag> UV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些好用的网站</title>
      <link href="/posts/20220501a2.html"/>
      <url>/posts/20220501a2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">本文推荐一些多快好省的网站、技术大佬的博客网站、专业网站。<span id="more"></span></p><ol><li><p>图标下载</p><ul><li>Icon图标下载：<a href="https://icon-icons.com/zh/">https://icon-icons.com/zh/</a></li><li>阿里巴巴矢量图库：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></li><li>图片格式转换： <a href="https://www.butterpig.top/ico/">https://www.butterpig.top/ico/</a></li></ul></li><li><p>影视行业软件下载网站：</p><ul><li>画忆大佬的软件下载网站(无毒无公害)：<a href="http://www.iiicg.com/">www.iiicg.com</a></li><li>nuke插件网 站：<a href="http://www.nukepedia.com/">www.nukepedia.com</a></li></ul></li><li><p>技术大佬们的博客网页</p><ul><li>TD手册：<a href="https://cg-td-course.readthedocs.io/zh_CN/latest/index.html">https://cg-td-course.readthedocs.io/zh_CN/latest/index.html</a></li><li>凌云大佬技术博客分享：<a href="https://lingyunfx.com/">https://lingyunfx.com/</a></li><li>汝小右大佬博客：<a href="https://ruben.blog.csdn.net/?type=blog">https://ruben.blog.csdn.net/?type=blog</a></li></ul></li><li><p>行业官网</p><ul><li>Maya2022 用户文档：<a href="https://help.autodesk.com/view/MAYAUL/2022/CHS/">https://help.autodesk.com/view/MAYAUL/2022/CHS/</a></li><li>Yeti 用户文档：<a href="https://support.peregrinelabs.com/support/solutions/66000172201">https://support.peregrinelabs.com/support/solutions/66000172201</a></li><li>Arnold 用户文档：<a href="https://www.arnoldrenderer.com/news/">https://www.arnoldrenderer.com/news/</a></li><li>Nuke 用户文档：<a href="https://learn.foundry.com/nuke/13.1/content/learn_nuke.html">https://learn.foundry.com/nuke/13.1/content/learn_nuke.html</a></li><li>Katana 用户文档：<a href="https://learn.foundry.com/katana/5.0/Content/learn_katana.html">https://learn.foundry.com/katana/5.0/Content/learn_katana.html</a></li><li>Deadline 用户文档：<a href="https://docs.thinkboxsoftware.com/">https://docs.thinkboxsoftware.com/</a></li><li>Pyside2 用户文档：<a href="https://wiki.qt.io/Main">https://wiki.qt.io/Main</a></li><li>ShotGrid 用户文档：<a href="https://help.autodesk.com/view/SGSUB/CHS/">https://help.autodesk.com/view/SGSUB/CHS/</a></li><li>AutoIt3 用户文档：<a href="https://www.autoitscript.com/autoit3/docs/">https://www.autoitscript.com/autoit3/docs/</a></li><li>USD 用户文档：<a href="https://graphics.pixar.com/usd/release/index.html">https://graphics.pixar.com/usd/release/index.html</a></li><li>UE4 官网：<a href="https://www.unrealengine.com/zh-CN">https://www.unrealengine.com/zh-CN</a></li><li>ACES 用户手册：<a href="https://acescentral.com/knowledge-base-2/">https://acescentral.com/knowledge-base-2/</a></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Doc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT中的系统托盘图标和系统消息推送</title>
      <link href="/posts/20220501a1.html"/>
      <url>/posts/20220501a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">本文记录: 使用 PySide2 编写工具界面时，需要为工具创建系统托盘图标以及推送消息的方法。<span id="more"></span>以方便用户对工具进行操作。</p><p style="text-indent:2em">通过 PySide2 创建系统托盘，需要使用 PySide2.QtWidgets.QSystemTrayIcon 这个类。这个类中需要使用了以下常用方法，就可以创建最基本的系统托盘图标：</p><ul><li>QSystemTrayIcon   创建一个系统托盘对象</li><li>QSystemTrayIcon.setContextMenu    添加右键菜单(QMenu)</li><li>QSystemTrayIcon.showMessage   在右下角弹出要提示消息</li><li>QObject.connect 连接信号和槽</li></ul><p>使用上面的方法，可以完成：</p><ol><li>在系统托盘中创建一个程序图标。</li></ol><p><img src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87.png" alt="创建的系统托盘图标.png" srcset="/images/home/Myhead.jpg" data-src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87.png" class="lozad post-image">  </p><ol start="2"><li>在程序创建完成托盘图标后，推送一条提示程序已经启动的系统消息。</li></ol><p><img src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E6%8E%A8%E9%80%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF.png" alt="推送的系统消息.png" srcset="/images/home/Myhead.jpg" data-src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E6%8E%A8%E9%80%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF.png" class="lozad post-image">  </p><ol start="3"><li>鼠标点击图标时的左右键功能。</li></ol><p><img src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E5%B7%A6%E5%8F%B3%E9%94%AE%E5%8A%9F%E8%83%BD.png" alt="点击图标左右键功能.png" srcset="/images/home/Myhead.jpg" data-src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E5%B7%A6%E5%8F%B3%E9%94%AE%E5%8A%9F%E8%83%BD.png" class="lozad post-image">  </p><p>代码示例如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import sysfrom PySide2.QtWidgets import QApplication, QAction, QMenu, QSystemTrayIconfrom PySide2.QtCore import SIGNAL, QObjectfrom PySide2.QtGui import QIcondef close():    print(&quot;close&quot;)def restart():    print(&quot;restart&quot;)def show():    print(&quot;show&quot;)app &#x3D; QApplication(sys.argv)exit &#x3D; QAction(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu.ico&quot;), &quot;Exit&quot;, )QObject.connect(exit, SIGNAL(&quot;triggered()&quot;), close)res &#x3D; QAction(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu1.ico&quot;), &quot;Restart&quot;, )QObject.connect(res, SIGNAL(&quot;triggered()&quot;), restart)menu &#x3D; QMenu()  # 创建菜单，添加菜单选项menu.addAction(exit)menu.addAction(res)trayIcon &#x3D; QSystemTrayIcon(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu4.ico&quot;))  # 创建系统托盘trayIcon.setContextMenu(menu)QObject.connect(trayIcon, SIGNAL(&quot;activated(QSystemTrayIcon::ActivationReason)&quot;), show)trayIcon.show()trayIcon.setToolTip(&quot;启动器&quot;)trayIcon.showMessage(&quot;启动器已经启动!&quot;, &quot;左击显示窗口\n右击显示菜单&quot;, QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu_Note1.ico&quot;))sys.exit(app.exec_())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行代码后，会在电脑桌面系统托盘创建一个本程序的图标，同时会推送一条启动信息，该信息会自动收回。<br>上面的代码没有判断点的是左还是右键，所以只要鼠标点击图标都会先打印一遍 “show”,请自行判断。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> QT事件 </tag>
            
            <tag> 信号&amp;槽 </tag>
            
            <tag> 系统托盘图标和消息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USD框架的搭建</title>
      <link href="/posts/20220421a1.html"/>
      <url>/posts/20220421a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天来介绍一下 windows 环境下 USD 的独立安装过程。<span id="more"></span><br>首先，我们需要了解几个网站：</p><p style="text-indent:2em">USD 的帮助文档 ：https://graphics.pixar.com/usd/release/index.html</p><p style="text-indent:2em">USD 的Github仓库 ：https://github.com/PixarAnimationStudios/USD</p><h4 id="安装准备："><a href="#安装准备：" class="headerlink" title="安装准备："></a>安装准备：</h4><p>需要准备：Python2、Cmake、NASM、Microsoft Visual Studio2017、Microsoft Visual Studio Code</p><p style="text-indent:2em">1. 确认环境中有Python2。在 windows 上安装 USD 需要我们的环境中有 Python， 由于 USD 目前还不支持Python3 ，因此我使用的是 Python2.7.16 ,没有Python2 的小伙伴可以从<a href="https://www.python.org/downloads/release/python-2710/" title="" target="">官网下载</a>，下载安装好后，需要调整一下环境变量的顺序，将Python2的相关环境变量提升到Python3的前面，这样可以在后面安装的时候直接调用Python2的环境,就不会出现一些奇怪的问题导致安装失败，如下图。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E5%89%8D%E7%BD%AEpython2%E7%9A%84%E7%8E%AF%E5%A2%83.png" alt="前置python2的环境" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E5%89%8D%E7%BD%AEpython2%E7%9A%84%E7%8E%AF%E5%A2%83.png" class="lozad post-image"></p><p style="text-indent:2em">2. 安装CMAKE工具，如果电脑上没有CMAKE，可以<a href="https://cmake.org/download/" title="" target="">从这里下载</a>，往下翻，找到相应的平台和系统版本，下载到一个可安装的文件，使用默认安装就好。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDCMAKE.png" alt="下载CMAKE" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDCMAKE.png" class="lozad post-image"></p><p style="text-indent:2em">3. 安装NASM，如果电脑上也没有NASM，则可以<a href="https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=D" title="" target="">从这里下载</a>，打开链接后选择一个合适的版本，我使用的是2.15.05版本的NASM，双击文件夹，选择自己系统对应的文件夹，再次双击，可以看到一个安装程序，点击即可下载，没有特殊需求的话，尽量使用默认安装。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDNASM.png" alt="下载NASM" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDNASM.png" class="lozad post-image"></p><p style="text-indent:2em">4. 安装Microsoft Visual Studio，USD 暂时不支持较新的版本，本案例使用的是VS2017版本，可以<a href="https://my.visualstudio.com/Downloads?q=visual%20studio%202017&wt.mc_id=o~msft~vscom~older-downloads" title="" target="">从这里下载</a>，选择一个合适的版本，安装过程中选择使用C++的桌面开发。</p><p style="text-indent:2em">5. 安装Microsoft Visual Studio Code，如果没有VSCode，可以<a href="https://code.visualstudio.com/download" title="" target="">从这里下载</a>，选择一个合适的版本，下载后默认安装好，打开下载Python拓展插件，并将上面安装的Python2的执行程序路径填入对应位置，如下图所示。</p><table><tr><td><img src="/images/USD框架的搭建/下载VSCode.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/USD框架的搭建/下载VSCode.png" class="lozad post-image"></td><td><img src="/images/USD框架的搭建/安装Python插件.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/USD框架的搭建/安装Python插件.png" class="lozad post-image"></td></tr></table>接下来我们还需要为Python2安装一些功能模块：PySide、pyd、pyopengl、Jinja2，在cmd中依次执行下面的指令即可<p style="text-indent:2em">pip install PySide</p><p style="text-indent:2em">pip install pyd</p><p style="text-indent:2em">pip install pyopengl</p><p style="text-indent:2em">pip install Jinja2</p>注：这里如果出现“pip Fatal error in launcher: Unable to create process...”错误，可以通过python安装文件的修复功能来解决，点击repair。<h4 id="构建-USD"><a href="#构建-USD" class="headerlink" title="构建 USD"></a>构建 USD</h4><p style="text-indent:2em">先从USD 的Github仓库<a href="https://github.com/PixarAnimationStudios/USD" title="" target="">下载 USD 源码</a>到本地，打开“x86 Native Tools Command Prompt VS 2017”界面，这里不能使用x64,并且对于高版本的VS,不管是"X64" 还是 "x86" 均不能安装成功。输入 python "你的USD源码下载位置"\build_scripts\build_usd.py "C:\USD" ，其中"C:\USD"是你的安装位置（安装位置中似乎不能有空格，我尝试了几次将usd安装在带空格的"Program Files (x86)"中，都没有成功）。程序会自动为你安装zlib，boost，TBB，OpenSubdiv用来构建USD环境。这个过程只有简单的几条语句提示，没有进度条，并且可能会报错或者安装不成功（也许是下载速度的原因），多执行几次上面的构建指令就好了，我也是安装了三次才成功。成功后会提示你，需要将 "C:\USD\lib\python"添加进系统变量PYTHONPATH中，再在系统变量 PATH 中添加 "C:\USD\bin" 和 "C:\USD\lib"两个路径，如下图所示。<p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E6%9E%84%E5%BB%BA%E7%95%8C%E9%9D%A2.png" alt="构建界面" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E6%9E%84%E5%BB%BA%E7%95%8C%E9%9D%A2.png" class="lozad post-image"></p><p>至此USD环境就搭建好了。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>打开一个cmd窗口，cd 进入你的USD源代码目录,然后输入指令：“usdview .\extras\usd\tutorials\convertingLayerFormats\Sphere.usd”，出现下面的界面就表示成功了。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/USD%E7%95%8C%E9%9D%A2.png" alt="USD界面" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/USD%E7%95%8C%E9%9D%A2.png" class="lozad post-image"></p><p>接下来就可以愉快地<a href="https://graphics.pixar.com/usd/release/tut_usd_tutorials.html#" title="" target="">学习案例</a>了！！！</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol><li><a href="https://zhuanlan.zhihu.com/p/437422802">https://zhuanlan.zhihu.com/p/437422802</a></li><li><a href="https://github.com/PixarAnimationStudios/USD/blob/release/README.md#getting-and-building-the-code">https://github.com/PixarAnimationStudios/USD/blob/release/README.md#getting-and-building-the-code</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Doc </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USD </tag>
            
            <tag> Pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT中的异形窗口</title>
      <link href="/posts/20220326a2.html"/>
      <url>/posts/20220326a2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录一下 QT 中异形窗口的创建。<span id="more"></span></p><h4 id="主要标志"><a href="#主要标志" class="headerlink" title="主要标志"></a>主要标志</h4><p>在 QWidget 中，通过给窗口设置特定的标志，可以将窗口设置为不同的形状，比如让窗口无标题，或者直接让主窗口透明</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">setWindowFlags(Qt.FramelessWindowHint)      # 去掉标题栏setMask(QPixmap(img).mask())                # 设置图片透明的地方为穿透setAttribute(Qt.WA_TranslucentBackground)   # 设置窗口透明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当为窗口设置了使用图片作为 Mask 遮罩后，Qt.FramelessWindowHint 标志会自动指定。</p><h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><h5 id="创建一个基本窗口"><a href="#创建一个基本窗口" class="headerlink" title="创建一个基本窗口"></a>创建一个基本窗口</h5><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># Author: Mirrorimport sysfrom PySide2.QtWidgets import QApplication, QWidgetfrom PySide2.QtCore import Qtfrom PySide2.QtGui import QPixmapclass MainWindow(QWidget):    def __init__(self,):        super().__init__()if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app &#x3D; QApplication(sys.argv)    form &#x3D; MainWindow()  # 实例化窗口小部件    form.show()    sys.exit(app.exec_())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>窗口效果<br><img src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E5%8E%9F%E7%AA%97%E5%8F%A3.png" alt="原窗口.png" srcset="/images/home/Myhead.jpg" data-src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E5%8E%9F%E7%AA%97%E5%8F%A3.png" class="lozad post-image"></p><h5 id="设置窗口标志"><a href="#设置窗口标志" class="headerlink" title="设置窗口标志"></a>设置窗口标志</h5><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">self.setWindowFlags(Qt.FramelessWindowHint)  # 去掉标题<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>窗口效果<br>窗口会变成一块没有标题的白板<br><img src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E6%97%A0%E6%A0%87%E9%A2%98%E7%AA%97%E5%8F%A3.png" alt="无标题窗口.png" srcset="/images/home/Myhead.jpg" data-src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E6%97%A0%E6%A0%87%E9%A2%98%E7%AA%97%E5%8F%A3.png" class="lozad post-image"></p><h5 id="设置窗口Mask"><a href="#设置窗口Mask" class="headerlink" title="设置窗口Mask"></a>设置窗口Mask</h5><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">self.starticon &#x3D; QPixmap(r&quot;ImagePath&quot;)self.setMask(self.starticon.mask())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>窗口效果窗口会根据你使用的 Mask 图片进行裁剪<br><img src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E8%AE%BE%E7%BD%AEMask%E7%9A%84%E7%AA%97%E5%8F%A3.png" alt="设置Mask的窗口.png" srcset="/images/home/Myhead.jpg" data-src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E8%AE%BE%E7%BD%AEMask%E7%9A%84%E7%AA%97%E5%8F%A3.png" class="lozad post-image"></p><h4 id="窗口重写事件"><a href="#窗口重写事件" class="headerlink" title="窗口重写事件"></a>窗口重写事件</h4><p>由于窗口被设置为无标题窗口后，鼠标不能对窗口进行移动，因此，我们还需要将窗口的鼠标事件进行重写。<br>完整代码：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># !&#x2F;user&#x2F;bin&#x2F;python37# -*- coding: utf-8 -*-# Author:Mirror# Time: 2022&#x2F;03&#x2F;26# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;import sysfrom PySide2.QtWidgets import QApplication,QWidgetfrom PySide2.QtCore import Qtfrom PySide2.QtGui import QPixmap, QCursorclass MainWindow(QWidget):    def __init__(self,):        super().__init__()        self.setWindowFlags(Qt.FramelessWindowHint)  # 去掉标题（还有一些别的窗口类型选择，请自行查阅）        self.starticon &#x3D; QPixmap(r&quot;E:\Python_study\startLauncher\Icon\startBackgroundMask.svg&quot;)        self.setMask(self.starticon.mask())    # 鼠标按下    def mousePressEvent(self, event):        if event.button() &#x3D;&#x3D; Qt.LeftButton:            self.m_drag &#x3D; True  # 鼠标按下或抬起标志位            self.m_DragPosition &#x3D; event.globalPos() - self.pos()  # 当前单击点相对于窗口本身的坐标(只检测窗口中的点击)            self.setCursor(QCursor(Qt.SizeAllCursor))  # 设置光标形状 小手抓取        if event.button() &#x3D;&#x3D; Qt.RightButton:  # 按下右键 取消左键按下，结束鼠标移动时间            if self.m_drag &#x3D;&#x3D; True:                self.m_drag &#x3D; False    # 鼠标移动    def mouseMoveEvent(self, QMouseEvent):        if Qt.LeftButton and self.m_drag:            # 当左键移动窗体修改偏移值            self.move(QMouseEvent.globalPos() - self.m_DragPosition)    # 鼠标抬起    def mouseReleaseEvent(self, QMouseEvent):        self.m_drag &#x3D; False        self.setCursor(QCursor(Qt.ArrowCursor))if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app &#x3D; QApplication(sys.argv)    form &#x3D; MainWindow()    form.show()    sys.exit(app.exec_())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的代码，我们就可以获得一个可以被鼠标移动的异形窗口啦。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> QT事件 </tag>
            
            <tag> 异形窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT中QToolButton的双击事件</title>
      <link href="/posts/20220326a1.html"/>
      <url>/posts/20220326a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p style="text-indent:2em">写工具界面的时候，发现 QPushButton 按钮不能被图标完全覆盖，而选择使用 QToolButton 按钮，但是 QToolButton 按钮本身是没有双击事件的，我在写工具的时候又对这个双击事件很执着，就自己实现一下<span id="more"></span>，并为该结果做记录。</p><h4 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><p style="text-indent:2em">要实现 QToolButton 按钮的双击事件：需要新建一个继承于 QToolButton 的子类，该类继承 QToolButton 的 click 鼠标单击事件，添加 singleClicked 和 doubleClicked 两个信号用于发送我们想要的单/双击信号，并在子类中添加一个 Qtimer 作为判断依据：将 QTimer 设置为单次触发, 并为QTimer 设定一个较短的时间，在该时间内，click信号链接到事件判断函数，如果再次点击该按钮则判断为双击事件，同时将 QTimer 停止；反之 QTimer 超时，QTimer 发送超时信号到单击事件函数，也需要将Qtimer 停止。当实例化这个子类后，点击按钮，该 click 信号即在实例内部进行判断。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># !&#x2F;user&#x2F;bin&#x2F;python37# -*- coding: utf-8 -*-# Author:Mirror# Time: 2022&#x2F;03&#x2F;26# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;import sysfrom PySide2.QtWidgets import QApplication, QToolButtonfrom PySide2.QtCore import Qt, Signal, QTimerclass DccButton(QToolButton):    &quot;&quot;&quot;定义ToolButton按钮双击事件&quot;&quot;&quot;    doubleClicked &#x3D; Signal()  # 双击信号    singleClicked &#x3D; Signal()  # 单击信号    def __init__(self):        super(DccButton, self).__init__()        self.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)  # 设置图标在字体之上        self.timer &#x3D; QTimer()  # 创建触发器        self.timer.setSingleShot(True) # 仅单次触发        self.timer.setInterval(200) # 触发间隔，用于判断是否为双击        self.timer.timeout.connect(self.singleClick) # 超时信号连接至单击        self.clicked.connect(self.checkDoubleClick) # 连接至成员函数判断是否为双击    def singleClick(self):        &quot;&quot;&quot;            发送单击信号        &quot;&quot;&quot;        self.timer.stop()        self.setDown(False)        self.singleClicked.emit()        print(&quot;单击&quot;)    def checkDoubleClick(self):        &quot;&quot;&quot;            判断是否为双击信号，否则信号超时        &quot;&quot;&quot;        if not self.isDown():            self.setDown(True)        if self.timer.isActive():            self.timer.stop()            self.setDown(False)            self.doubleClicked.emit()            print(&quot;双击&quot;)            return        else:            self.timer.start()if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app &#x3D; QApplication(sys.argv)    form &#x3D; DccButton()    form.show()    sys.exit(app.exec_())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> QT事件 </tag>
            
            <tag> 信号&amp;槽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rez安装使用</title>
      <link href="/posts/20220314a1.html"/>
      <url>/posts/20220314a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Rez 是一个跨平台程序包管理器，通过它可以给程序配置独立的环境<span id="more"></span>，每个独立环境中只是引用了这些包。所以它的环境配置是轻量级的，与其它程序包环境管理不同的是，所有的程序包都安装在一个中央统一的位置，尽管有几百个包，通常也只需要几秒就可以进行配置。将 Rez 作为工作室 DCC 软件启动器依赖项，是个不错的选择。下面将简单介绍 Windows 环境下，Rez 包管理器如何安装使用。</p><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><p>从 GitHub 上拉取 <a href="https://github.com/nerdvegas/rez" title="" target="">Rez 原项目的的相关仓库</a>，然后打开CMD<br>进入拉取仓库所在的目录中执行(建议在C盘根目录)：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">python .&#x2F;install.py </code></pre><p>这将会把包安装在当前位置的 &#x2F;opt&#x2F;rez 目录下<br>也可以使用Pip进行安装：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">pip install rez</code></pre><p>但使用 pip 的安装方式并不能很好的用在生产环境中,使用 install 脚本安装是推荐的方法，它可以保证 Rez 拥有独立 python 于的环境独立运行。<br>安装完成后，cmd中会出现提示信息。然后，需要在环境变量 PATH 中添加值 ‘安装rez的路径’&#x2F;opt&#x2F;rez&#x2F;bin&#x2F;rez。</p><h4 id="创建基本的-Rez-包"><a href="#创建基本的-Rez-包" class="headerlink" title="创建基本的 Rez 包"></a>创建基本的 Rez 包</h4><p>这里需要使用管理员权限去安装包，rez-bind 工具创建基于已安装在系统上的软件的 Rez 包：（–quickstart是以标准形式安装包）</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-bind --quickstart</code></pre><p>你也可以分开安装</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-bind platformrez-bind archrez-bind osrez-bind python</code></pre><p>安装好之后，会在 %userprofile%&#x2F;packages 目录下找到已经安装的 Rez 包</p><h4 id="验证安装结果"><a href="#验证安装结果" class="headerlink" title="验证安装结果"></a>验证安装结果</h4><p>为了验证是否安装成功，可以使用下面的命令：（其中 “which python”是你的python版本）</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-env python-which python</code></pre><p>使用 exit 退出环境。</p><h4 id="构建第一个包"><a href="#构建第一个包" class="headerlink" title="构建第一个包"></a>构建第一个包</h4><p>.需要确认%userprofile%&#x2F;packages 存在且可写入<br>.需要确认cmake 工具安装且可用（注：官方文档中会使用这个工具在ios系统上安装下面的包，但我还未在Windows10系统上成功安装该包，似乎有些依赖包的冲突问题，但好像不影响使用，正在求证中。。。）<br>rez-build 工具用于构建包并在本地安装它们（%userprofile%&#x2F;packages下）。 完成后，您可以通过 rez-env 使用它们，就像任何其他软件包一样：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">cd example_packages&#x2F;hello_worldrez-build --install</code></pre><h4 id="测试构建的包"><a href="#测试构建的包" class="headerlink" title="测试构建的包"></a>测试构建的包</h4><p>使用rez-env命令来请求一个（或多个）你已经安装的软件包环境</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-env hello_world</code></pre><p>提示符前的插入符号 (&gt;) 是一个视觉提示，告诉你现在位于 rez 配置的子 shell 中。 Rez 不会更新当前环境，而是配置一个子shell 并将你置于其中。<br>如果你已经在rez shell的配置环境中，并且忘记了当前可用的软件包列表。可以使用 rez-context 工具查看：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-context</code></pre><p>退出这个环境，使用exit命令。</p><p>你还可以创建一个已配置的环境并在其中运行一个命令，只需一个命令。 当您使用这种形式时，shell 会在命令运行后立即退出：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-env hello_world -- hello </code></pre><h4 id="软件包命令"><a href="#软件包命令" class="headerlink" title="软件包命令"></a>软件包命令</h4><p>查看搜索路径:</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-config</code></pre><p>查看当前配置环境：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-context</code></pre><h4 id="在共享路径下搜索插件包"><a href="#在共享路径下搜索插件包" class="headerlink" title="在共享路径下搜索插件包"></a>在共享路径下搜索插件包</h4><p>首先，需要为系统设置配置文件的用户环境变量 REZ_CONFIG_FILE 指向 rezconfig.py文件；为系统用户的环境变量中添加环境变量 REZ_CONFIG_FILE ，并且值为”S:\opt\rez\Lib\site-packages\rez\rezconfig.py”(本文将 rez安装在S盘，对应安装的根目录即可)，然后添加插件包的存放路径即可，若不添加环境变量，则默认从安装路径获取配置文件信息。<br>下面是配置文件中，通过修改packages_path变量修改获取共享路径中的插件路径：</p><pre class="language-python" data-language="python"><code class="language-python"># The package search path. Rez uses this to find packages. A package with the# same name and version in an earlier path takes precedence.packages_path &#x3D; [    &quot;~&#x2F;packages&quot;,           # locally installed pkgs, not yet deployed    &quot;~&#x2F;.rez&#x2F;packages&#x2F;int&quot;,  # internally developed pkgs, deployed    &quot;~&#x2F;.rez&#x2F;packages&#x2F;ext&quot;,  # external (3rd party) pkgs, such as houdini, boost    &quot;S:&#x2F;rez&#x2F;packages&#x2F;dcc&quot;,  # dcc软件共享路径    &quot;S:&#x2F;rez&#x2F;packages&#x2F;plugins&quot;,  # 插件共享路径    &quot;S:&#x2F;rez&#x2F;packages&#x2F;third_party&quot;, # 第三方插件路径    &quot;S:&#x2F;rez&#x2F;packages&#x2F;tools&quot; # 自定义工具路径]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Rez </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pipeline </tag>
            
            <tag> 包管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CG流程中&quot;USD&quot;的探索与运用</title>
      <link href="/posts/20220307a1.html"/>
      <url>/posts/20220307a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>USD部分名词中文概述<a href="https://szxk.github.io/docs.usd/" title="" target="">点击这里</a>查看。</li><li>maya输出USD：当一个USD文件输出错误，不能用于reference要重新输出USD文件时，需将错误的文件删除再输出USD文件（覆盖无效依旧会使用内存中暂存的USD数据），若不删除，即使设置正确，输出的数据依旧是错误的（maya2023.0测试结果）。</li><li>从maya导出usd,不勾选任何材质球，导入后即为干净的模型USD文件。</li><li>导出设置“Create USD Parent Scope”可用于编辑Layerusd时，识别usd文件中的prom模型分类，在USD文件中会将defaultPrim值设置为“Create USD Parent Scope”的值，并且会在xfrom外多定义一层Scope。</li></ul><p><img src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E2%80%9DUSD%E2%80%9C%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%BF%90%E7%94%A8/%E5%AF%BC%E5%87%BA%E6%97%B6%E8%AE%BE%E7%BD%AEcreateUseParentScope%E5%B1%9E%E6%80%A7%E6%95%88%E6%9E%9C.png" alt="导出时设置createUseParentScope属性效果 png" srcset="/images/home/Myhead.jpg" data-src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E2%80%9DUSD%E2%80%9C%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%BF%90%E7%94%A8/%E5%AF%BC%E5%87%BA%E6%97%B6%E8%AE%BE%E7%BD%AEcreateUseParentScope%E5%B1%9E%E6%80%A7%E6%95%88%E6%9E%9C.png" class="lozad post-image"></p><ul><li>maya2023 自身的USD导出的USD数据，其中材质网络的部分虽有记录但不能在maya中直接使用。</li><li>maya2023 自身的USD导出的USD数据，可以reference但是没材质，不能用于Arnold的StandIn;arnold插件导出的USD数据，携带ArnoldOptions设置。其可以用于StandIn，也可以用于USD层编辑器，但是不能reference。</li><li>目前maya 2023 自身的USD功能以及Arnold的USD功能还不完善，还有许多功能需要开发才能用于项目流程中。</li></ul><p>————— 更新于2022-06-01 —————</p>]]></content>
      
      
      <categories>
          
          <category> Doc </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USD </tag>
            
            <tag> Pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deadline中的事件示例</title>
      <link href="/posts/20220306a1.html"/>
      <url>/posts/20220306a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此文章是记录Deadline农场管理软件中的消息事件插件编写的示例。<span id="more"></span></p><h3 id="事件插件的作用和执行顺序"><a href="#事件插件的作用和执行顺序" class="headerlink" title="事件插件的作用和执行顺序"></a>事件插件的作用和执行顺序</h3><p>Deadline 的所有插件都是Python写的，事件插件可用于更新新快照或任务的状态，或者可用于在一个作业状态更改时处理相关的作业。并且插件都是以非交互式的方式执行，编写插件时不应该包含阻塞操作(如无限循环)或需要用户输入的界面。当我们的事件插件被执行时，日志中会显示插件是从哪里加载的。<br>Deadline中有很多事件，事件插件的触发是按顺序的，并且顺序是可配置的：</p><p><img src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E9%A1%BA%E5%BA%8F%E4%BF%AE%E6%94%B9.png" alt="event顺序修改" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E9%A1%BA%E5%BA%8F%E4%BF%AE%E6%94%B9.png" class="lozad post-image"></p><h3 id="创建事件脚本"><a href="#创建事件脚本" class="headerlink" title="创建事件脚本"></a>创建事件脚本</h3><p>首先要在存储库的custom\events文件夹中创建一个文件夹，并为其命名您的事件插件，如：</p><p><img src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="event创建事件文件夹" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9.png" class="lozad post-image"></p><p>创建好文件夹后，我们需要新建一个和该文件夹相同明明的 .py 文件，并在文件中写入相应的基本内容（导入deadline事件命名空间；GetDeadlineEventListener()函数获取MyEvent类的一个实例，没有会报错；MyEvent类将需要基于想要响应的事件实现某些回调；当不再使用该事件插件，CleanupDeadlineEventListener()函数进行自动清理。）：</p><p><img src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6.png" alt="event创建事件脚本文件" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6.png" class="lozad post-image"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from Deadline.Events import *def GetDeadlineEventListener():    &quot;&quot;&quot;This is the function that Deadline calls to get an instance of the    main DeadlineEventListener class.    &quot;&quot;&quot;    return MyEvent()def CleanupDeadlineEventListener(deadlinePlugin):    &quot;&quot;&quot;This is the function that Deadline calls when the event plugin is    no longer in use so that it can get cleaned up.    &quot;&quot;&quot;    deadlinePlugin.Cleanup()class MyEvent(DeadlineEventListener):    &quot;&quot;&quot;This is the main DeadlineEventListener class for MyEvent&quot;&quot;&quot;    # TODO: Place code here to replace &quot;pass&quot;    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们完成上述脚本文件的内容后，我们将会得到下面的脚本内容：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python3# -*- coding:utf-8 -*-# @Auther: Mirror# @Time: 2020&#x2F;07&#x2F;01# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;from System import *from System.Collections.Specialized import *from System.IO import *from System.Text import *from Deadline.Scripting import *from Deadline.Events import *import time######################################################################## This is the function that Deadline calls to get an instance of the## main DeadlineEventListener class.######################################################################def GetDeadlineEventListener():    return MyEvent()######################################################################## This is the function that Deadline calls when the event plugin is## no longer in use so that it can get cleaned up.######################################################################def CleanupDeadlineEventListener(deadlinePlugin):    deadlinePlugin.Cleanup()######################################################################## This is the main DeadlineEventListener class for MyEvent.######################################################################class MyEvent(DeadlineEventListener):    def __init__(self):        # Set up the event callbacks here        self.OnJobFinishedCallback +&#x3D; self.OnJobFinished        self.OnJobFailedCallback +&#x3D; self.OnJobFailed    def Cleanup(self):        del self.OnJobFinishedCallback        del self.OnJobFailedCallback    def OnJobFinished(self, job):        # TODO: Connect to pipeline site to notify it that the job for a particular        # shot or task is complete.        job_name &#x3D; job.JobName        job_mach &#x3D; job.GetJobInfoKeyValue(&quot;MachineName&quot;)        job_user &#x3D; job.JobUserName        if job_mach.lower() &#x3D;&#x3D; &quot;renderfarm&quot;:            slaves &#x3D; None        else:            slaves &#x3D; [job_mach]        if slaves:            for each in slaves:                curr_time &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))                slave &#x3D; each                massages &#x3D; &quot;Cur_time:  &#123;curtime&#125;\nJob_user:  &#123;user&#125;\n\nmassages:  Job named \&#39;&#123;jobname&#125;\&#39; had been complate&quot;.format(                    curtime&#x3D;curr_time, user&#x3D;job_user, jobname&#x3D;job_name)                self.sendmessages(slave, massages)        print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)        self.LogInfo(&quot;\&#39;%s\&#39; is complated&quot; % job_name)        self.LogInfo(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)    def OnJobFailed(self, job):        &quot;&quot;&quot;        Deadline will to do sometion when job or task is faild        :param job: which Work being monitored        :return: None        &quot;&quot;&quot;        job_name &#x3D; job.JobName        job_mach &#x3D; job.GetJobInfoKeyValue(&quot;MachineName&quot;)        job_user &#x3D; job.JobUserName        if job_mach.lower() &#x3D;&#x3D; &quot;renderfarm&quot;:            slaves &#x3D; [&quot;DESKTOP-Mirror&quot;]        else:            if job_mach &#x3D;&#x3D; &quot;DESKTOP-Mirror&quot;:                slaves &#x3D; [job_mach]            else:                slaves &#x3D; [job_mach, &quot;DESKTOP-Mirror&quot;]        for each in slaves:            curr_time &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))            slave &#x3D; each            massages &#x3D; &quot;Cur_time:  &#123;curtime&#125;\nJob_user:  &#123;user&#125;\nmassages:  Job named \&#39;&#123;jobname&#125;\&#39; had been failed&quot;.format(                curtime&#x3D;curr_time, user&#x3D;job_user, jobname&#x3D;job_name)            self.sendmessages(slave, massages)        print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)        self.LogInfo(&quot;\&#39;%s\&#39; is failed&quot; % job_name)        self.LogInfo(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)    def sendmessages(self, slaves, messages):        &quot;&quot;&quot;        :param            slaves: machines&#96;s machines name or IP address.            messages: the messages which is send by current serve]        :return            cmd is executed by system        &quot;&quot;&quot;        args &#x3D; StringCollection()        args.Add(&quot;-SendPopupMessage&quot;)        args.Add(&quot;%s&quot; % slaves)        args.Add(&quot;%s&quot; % messages)        ClientUtils.ExecuteCommand(args)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建事件参数文件"><a href="#创建事件参数文件" class="headerlink" title="创建事件参数文件"></a>创建事件参数文件</h3><p>创建完事件插件的脚本后，我们需要在上述文件夹中为事件插件添加与文件夹同名的参数文件（.param）供 Deadline 进行读取，创建参数界面：</p><p><img src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6.png" alt="event创建事件参数文件" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6.png" class="lozad post-image"><br>参数文件内容：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">[State]Type=EnumItems=Global Enabled;Opt-In;DisabledCategory=OptionsCategoryOrder=0Index=0Label=StateDefault=DisabledDescription=How this event plug-in should respond to events. If Global, all jobs and slaves will trigger the events for this plugin. If Opt-In, jobs and slaves can choose to trigger the events for this plugin. If Disabled, no events are triggered for this plugin.[EventCallbacks]Type=LabelDescription=The Event Callbacks that this Event Plugin subscribes to.Default=OnJobFailed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它将声明 Monitor 用来生成用户界面的属性，该用户界面用于修改数据库中的自定义设置，创建该文件后，打开监视器并进入超级用户模式。然后选择Tools -&gt; Configure Events，在左边的列表中查找该事件插件。</p><p><img src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E4%BA%8B%E4%BB%B6%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE.png" alt="event事件插件配置" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E4%BA%8B%E4%BB%B6%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE.png" class="lozad post-image"></p><p>至此，在 Deadline 中创建自定义任务消息失败&#x2F;成功的事件已经完成，每当Deadline 中有任务失败时&#x2F;成功时，Deadline 会自动给任务的提交者发送一条相关的消息弹框，用于给制作人员反馈及时的渲染消息。</p><p>注意：需要注意 Deadline 当前使用的 Python 版本，避免出现不兼容的情况</p><p>咱们有空可以看看<a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/1_User%20Manual/manual/event-plugins.html" title="" target="">官方文档</a>是怎么说的，里面有更加详细的内容哦。</p><a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/2_Scripting%20Reference/index.html" title="" target="">官方文档中事件脚本文档</a>]]></content>
      
      
      <categories>
          
          <category> Deadline </category>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建个人博客</title>
      <link href="/posts/20220302a2.html"/>
      <url>/posts/20220302a2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">作为一名学习任何技术都习惯做笔记的好学生，还在使用思维导图记录知识点？或是用word写文档，甚至是"白纸黑字"码字！！！都2202年了，是不是该寻找一种既方便自己随时查找翻看，又可以和小朋友们一起分享知识和经验的方式呢？这时，拥有一个属于自己的个人博客，实属是一个迫在眉睫的需求。于是，我有了自己的博客。接下来将介绍从无到有搭建属于自己的个人博客过程。<span id="more"></span></p><h4 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h4><p>1.一台能联网、没有脑梗的计算机<br>2.Windows系统（我就只会用“窗口”）<br>3.git包管理工具<br>4.一个知道账号和密码的github账号<br>5.记住这个网址，一会儿要用：<a href="https://www.nodejs.org/">https://www.nodejs.org/</a><br>6.随时准备问候度娘，因为我也不清楚你会遇到些什么疑难杂症</p><h4 id="开始搭建本地环境"><a href="#开始搭建本地环境" class="headerlink" title="开始搭建本地环境"></a>开始搭建本地环境</h4><p style="text-indent:2em">首先，点击<a href="https://git-scm.com/download/win" title="" target="">下载git</a>，下载适合自己系统的最新git版本安装包，以默认方式安装。 </p><p style="text-indent:2em">然后，我们再在电脑上访问刚才让你记住的<a href="https://www.nodejs.org/" title="" target="">网址</a>，从网址上下载我们需要的LTS版node.js安装包，直接双击安装它。不出意外的话，安装好的node.js会给你反馈安装了两个组件（node.js和npm包管理工具），我们可以直接去cmd中验证。</p><p style="text-indent:2em">打开cmd,利用npm包管理工具安装今天的主角Hexo博客，先输入命令行安装cnpm的同时将镜像源指向淘宝：</p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">安装hexo-cli：</p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">cnpm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">找个你觉得合适的位置创建一个文件夹，用于存放你的博客产生的所有文件，在cmd中将路径切换到创建的文件夹：</p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">cd &#x2F;d &quot;你刚刚创建的文件夹路径&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">初始化咱们的博客目录：</p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">hexo init <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">启动我们的Hexo本地服务，可在https://localhost:4000访问，但博客中只有一篇和hexo用户指南相关的文章：</p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">如果网页打不开，win10执行下面代码后再重复上一步： </p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">npm install hexo-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">创建新的博客文章： </p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">hexo new &quot;我的第一篇博客文章&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">创建好后，在刚刚创建的博客文件夹的\source\_posts\路径下能看到刚才创建的"我的第一篇博客文章.md"文件，用文本编辑器即可对内容进行编辑，然后刷新https://localhost:4000，就能看到刚刚创建的博客文章出现在网页上，ctrl + C 退出本地服务，。</p><p style="text-indent:2em">清除产生的静态博客文件(public)文件夹： </p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="构建存储库"><a href="#构建存储库" class="headerlink" title="构建存储库"></a>构建存储库</h4><p style="text-indent:2em">登录github,创建一个新的仓库用于存储从本地推送的静态博客文件：repository neme 必须是："GitHub昵称加.github.io"，description添加自定义描述，创建库。</p><p style="text-indent:2em">cmd下载hexo插件：</p><pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">cnpm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">文本打开博客文件夹根目录下的"_config.yml"文件，在文件尾部添加在文件尾部添加：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">## 添加储存库配置deploy:  type: git  repo: (你的储存库地址)  branch: master ## 注意：冒号后面有空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p style="text-indent:2em">要将博客部署到github上，需要先配置git全局用户名和邮箱：</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git config --global user.email &quot;github中的邮箱地址&quot;git config --global user.name &quot;github中的用户名&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p style="text-indent:2em">从22021年8月14日(七夕)那天开始，推送代码到GitHub需要使用token登录而不是密码，因此，我们需要先<a href="https://docs.github.com/cn/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token" title="" target="">获取token</a>。</p><p style="text-indent:2em">使用git生成SSH，运行 git Bash 客户端，检测是否存在ssh文件,换句话说就是检查是否存在 id_rsa.pub 或 id_dsa.pub 文件,如果存在可以跳过下面两步，输入如下代码：</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">cd ~&#x2F;.sshls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p style="text-indent:2em">创建SSH：</p><pre class="line-numbers language-hexo" data-language="hexo"><code class="language-hexo">ssh-keygen -t rsa -C &quot;你的邮箱&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">等待一会儿，当看到"Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:............."内容时，表示创建成功。在C盘User文件夹（可能会在桌面）可以找到ssh文件夹， 需要把id_rsa.pub文件中的内容添加到github。步骤是 Settings-->SSH and GPG Keys --->News SSH key，然后把id_rsa里的内容复制进去。</p><p style="text-indent:2em">回到cmd,部署博客到Github,两次输入都需要输入用户名和令牌(令牌不要手动输入，可以直接复制粘贴，尽管看不到粘贴内容，但还是要操作，才能成功):</p><pre class="line-numbers language-hexo" data-language="hexo"><code class="language-hexo">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">稍等两分钟，就可以访问博客页啦：https://github昵称加.github.io</p><p>note: 若推送过程中出现下列警告：</p><blockquote><p>warning: LF will be replaced by CRLF in tags&#x2F;XXXX&#x2F;index.html.<br>The file will have its original line endings in your working directory</p></blockquote><p>这只是一个警告，我们直接忽略就好。或者，可使用全局配置来禁用自动转换：</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git config --global core.autocrlf false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p style="text-indent:2em">可以 <a href="https://hexo.io/themes/" title="" target="">点击这里</a> 获取更多主题仓库地址，克隆主题到本地：</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;主题名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">修改博客根目录_config.yml文件，修改theme字段后的内容为 “主题名称”。</p><p style="text-indent:2em">清理hexo目录：</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">重新生成hexo静态博客文件夹及其内容：</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">推送远端：</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p style="text-indent:2em">大佬的博客搭建教程视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=3925172907707222671&spm_id_from=333.337.0.0" title="" target="">点击这里</a>，更多的部署细节可在视频中找到哦。</p><h2 id="博客评论"><a href="#博客评论" class="headerlink" title="博客评论"></a>博客评论</h2><h3 id="在cleanCloud上托管valine评论"><a href="#在cleanCloud上托管valine评论" class="headerlink" title="在cleanCloud上托管valine评论"></a>在cleanCloud上托管valine评论</h3><h3 id="通过cleanCloud发送邮件"><a href="#通过cleanCloud发送邮件" class="headerlink" title="通过cleanCloud发送邮件"></a>通过cleanCloud发送邮件</h3><p><a href="https://github.com/DesertsP/Valine-Admin.git">https://github.com/DesertsP/Valine-Admin.git</a> 远程库<br><a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a>  评论邮箱通知</p><p><a href="https://to35uwtu.lc-cn-n1-shared.com/">https://to35uwtu.lc-cn-n1-shared.com</a>   Request 接口<br>AKISMET_KEY  e79de4c39e2c  垃圾评论过滤器键值</p><p><a href="http://www.cimoc.cn/2022/02/16/hexo-next-valine-leancloud/">http://www.cimoc.cn/2022/02/16/hexo-next-valine-leancloud/</a><br><a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a></p>]]></content>
      
      
      <categories>
          
          <category> Doc </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CG流程中使用ACES色彩管理</title>
      <link href="/posts/20220302a1.html"/>
      <url>/posts/20220302a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>构建CG流程中的ACES色彩管理流程 <span id="more"></span>,为什么要构建呢？因为：1.色域更高，能容纳更多的色彩，显示的色彩更丰富；2.能接受更高的灯光强度，画面比较不会过曝（不要调皮地将灯光强度调的特别高哦）;3.更物理更真实，颜色会随着亮度地提升，饱和度逐渐降低。相对的就会有些缺点：图片占用存储空间会变大(对影视动画没什么影响)。</p><p>在CG流程中的大概过程就是，sRGB图片进入DCC软件被AECScg线性转换函数转换编码到ACES色域中被管理&gt;渲染器处理贴图信息后生成ACES色域图片&gt;经过编码转换到视图中显示或输出为指定色域的图片用于存储(srgb或ACES)、进一步编辑（ACES）</p><h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><pre><code>Substance painter 7.1 + Doc 2020.4 + Nukel2.3 + ACES1.1</code></pre><h4 id="SP软件配置"><a href="#SP软件配置" class="headerlink" title="SP软件配置"></a>SP软件配置</h4><p style="text-indent:2em">由于SP要在7.4版本以后才支持 OCIO 配置文件，并且目前大部分资产贴图都采用sRGB色域编码，因此默认使用传统 SP(sRGB)到 MAYA(ACES) 中进行 sRGB 色域空间转换到 ACES 色域空间的方式。传统SP流程可以通过LMT(外观转换)的LUT(查找表)文件用于显示（只是看起来和AECES差不多，但实际上还是SRGB色域的图片）具体方法是：file > import resource > 添加资源 > 选择Lut文件 > 修改定义为 colorLut > 导入到"工具架" > 导入，然后在显示设置中将 activate post effects恢复默认,勾选activate post effects，勾选activate post effects > tone mapping(色调映射),将 activate post effects > tone mapping > function(功能)设置为log(日志)，并勾选activate color porfile > porfile 修改为 ACES_Standard_log,white_Point 设置为默认值，此时我们从SP软件的视口中看见的色彩在视觉上基本等同ACES色域图显示的效果。</p><h4 id="May启动时配置-ACES-色彩管理"><a href="#May启动时配置-ACES-色彩管理" class="headerlink" title="May启动时配置 ACES 色彩管理"></a>May启动时配置 ACES 色彩管理</h4><p style="text-indent:2em">Maya中使用 ACES 色彩管理空间，在具备有效的 config.ocio 配置文件的情况下，为 Maya 设置环境变量"OCIO = 文件全路径",此时Maya中的色彩管理空间将使用 OCIO 配置文样中的设置，该设置会在基于ACES 色彩管理的基础上自动修改渲染预览界面和视图界面的色彩空间，我们在显示器中看到的色彩信息并非线性空间的色彩信息，Maya后台输出的图片也是经 ACES 色彩空间编码后的图片，此时将渲染图片放入使用相同 ACES 配置文件的 Nuke 软件中，即可直接对 ACES 图片进行线性数据的操作。</p><p><img src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Maya%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86%E4%B8%AD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE.png" alt="Maya色彩管理中环境变量设置" srcset="/images/home/Myhead.jpg" data-src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Maya%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86%E4%B8%AD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE.png" class="lozad post-image"></p><h4 id="Maya-应用-OCIO-输入色彩空间规则到图片"><a href="#Maya-应用-OCIO-输入色彩空间规则到图片" class="headerlink" title="Maya 应用 OCIO 输入色彩空间规则到图片"></a>Maya 应用 OCIO 输入色彩空间规则到图片</h4><p style="text-indent:2em">使用 OCIO 配置文件后，若勾选"使用 OCIO 输入颜色空间规则"则会使用"OCIO Standard Rule"对输入的文件进行色彩空间的转换，若不使用，则需要手动制定规则（自定义的配置不起作用时，可尝试将软件切成英文版)，然后将自定义的标准的色彩管理策略导出为 CM 文件,并添加环境变量"MAYA_COLOR_MANAGEMENT_POLICY_FILE=CM文件全路径"、"MAYA_COLOR_MANAGEMENT_POLICY_LOCK=1",用以全局配置所有渲染制作机，使保持相同的色彩配置，手动指定规则将按照规则的从上往下的顺序应用规则，由匹配成功的第一个规则指定输入的色彩空间。</p><p><img src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Maya%E4%B8%AD%E4%BD%BF%E7%94%A8OCIO%E9%85%8D%E7%BD%AE.png" alt="Maya中使用OCIO配置" srcset="/images/home/Myhead.jpg" data-src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Maya%E4%B8%AD%E4%BD%BF%E7%94%A8OCIO%E9%85%8D%E7%BD%AE.png" class="lozad post-image"></p><h4 id="色彩空间管理的其他设置"><a href="#色彩空间管理的其他设置" class="headerlink" title="色彩空间管理的其他设置"></a>色彩空间管理的其他设置</h4><p style="text-indent:2em">Ui 设置:启用后 Maya中的色彩盒子会显示得较灰一些，但不影响 ACES 色域着色。<p><img src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Maya%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84UI%E8%AE%BE%E7%BD%AE.png" alt="Maya色彩管理中的UI设置" srcset="/images/home/Myhead.jpg" data-src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Maya%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84UI%E8%AE%BE%E7%BD%AE.png" class="lozad post-image"><br>浮点渲染目标:开启色彩管理后，该选项也应该开启,才能在 Maya2020 中查看到正确的显示结果，并且应该使用32位格式，否则可能会出现色彩信息的裁剪，显示不正确，吸管吸取不到正确的色彩信息等情况。<br><img src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Maya%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E8%AE%A1%E7%AE%97.png" alt="Maya色彩管理中的浮点计算" srcset="/images/home/Myhead.jpg" data-src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Maya%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E8%AE%A1%E7%AE%97.png" class="lozad post-image"><br>导出 CM 首选项：将自定义的色采管理首选项导出到指定的 CM 文件中，可用于软件启动的环境变量。</p><br><img src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Maya%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84CM%E7%AD%96%E7%95%A5.png" alt="Maya色彩管理中的CM策略" srcset="/images/home/Myhead.jpg" data-src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Maya%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84CM%E7%AD%96%E7%95%A5.png" class="lozad post-image"></p><h4 id="Nuke-中配置使用-ACES-色彩管理"><a href="#Nuke-中配置使用-ACES-色彩管理" class="headerlink" title="Nuke 中配置使用 ACES 色彩管理"></a>Nuke 中配置使用 ACES 色彩管理</h4><p>手动配置：</p><p style="text-indent:2em">仅为当前项目配置 ACES:</p><p style="text-indent:2em">打开软件后，按S键进行项目配置：点击 project setting >color栏，将"color management"修改为"OCIO",将COIO_config 修改为"custom", 然后将 OCIO 配置文件填入“custom_OCIO_config"选项中（需保证Nuke中使用的 OCIO 配置文件和 MAYA 中使用的保持一致)或选择 Nuke 自带的 OCIO 配置文件，然后Nuke 即可自动设置部分常用的色彩空间编码设置。对于实拍源素材需要单独配置 Lut格式。</p><p><img src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Nuke%E4%B8%AD%E9%85%8D%E7%BD%AEACES.png" alt="Nuke中配置ACES" srcset="/images/home/Myhead.jpg" data-src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84ACES%E8%89%B2%E5%BD%A9%E7%AE%A1%E7%90%86/Nuke%E4%B8%AD%E9%85%8D%E7%BD%AEACES.png" class="lozad post-image">  </p><p>为 Nuke 默认启动配置 ACES</p><p style="text-indent:2em">为软件默认配置:</p><p style="text-indent:2em">1.打开Nuke首选项:选择 Color Management 选择 Nuke 自带的 OCIO 配置或使用自己的 OCIO 配置，即可为软件配置 ACES 色彩管理空间，重启软件即可生效。2.环境变量配置，启动环境中添加环境变量：OCIO = 文件位置</p><h4 id="Nuke-输出sRGB素材"><a href="#Nuke-输出sRGB素材" class="headerlink" title="Nuke 输出sRGB素材"></a>Nuke 输出sRGB素材</h4><p style="text-indent:2em">对于使用EXR输出作为合成过程的中间素材，使用默认的 ACES 色域编码的exr格式文件，保持图片信息的完整，勾选"输出保持ACES 兼容的EXR"；输出序列时，则直接转回sRGB色域编码（使用output_srgb编码方式输出）</p><table><tr><td><img src="/images/CG流程中的ACES色彩管理/Nuke中ACES输出EXR.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/CG流程中的ACES色彩管理/Nuke中ACES输出EXR.png" class="lozad post-image"></td><td><img src="/images/CG流程中的ACES色彩管理/Nuke中ACES输出sRGB序列.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/CG流程中的ACES色彩管理/Nuke中ACES输出sRGB序列.png" class="lozad post-image"></td></tr></table><h4 id="相关软件插件下载链接"><a href="#相关软件插件下载链接" class="headerlink" title="相关软件插件下载链接"></a>相关软件插件下载链接</h4><p>Substance Painter插件滤镜：<a href="https://pan.baidu.com/s/1FFpBeih902gMJWVQrzEwbw">https://pan.baidu.com/s/1FFpBeih902gMJWVQrzEwbw</a> 提取码: anqq<br>OCIO配置文件下载地址：<a href="https://github.com/colour-science/OpenColorIO-Configs/tree/feature/aces-1.2-config">https://github.com/colour-science/OpenColorIO-Configs/tree/feature/aces-1.2-config</a></p>]]></content>
      
      
      <categories>
          
          <category> Doc </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灯光合成 </tag>
            
            <tag> ACES </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya获取选中相机视角中的所有对象</title>
      <link href="/posts/20220228a1.html"/>
      <url>/posts/20220228a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">从Maya视图窗口中获取相机视角中所有的对象，可以利用OpenMaya和OpenMayaUI两个模块来完成此功能，<span id="more"></span>首先需要指定相机，并通过遍历相机视口，来获取相机视口中的对象：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-# @Auth0r: Mirror# @Time: ----# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;import maya.cmds as cmdsimport maya.OpenMaya as OpenMayaimport maya.OpenMayaUI as OpenMayaUIdef getObjInView(cam):    # 添加相机到 MDagPath    mdag_path &#x3D; OpenMaya.MDagPath()    sel &#x3D; OpenMaya.MSelectionList()    sel.add(cam)    sel.getDagPath(0, mdag_path)    # 遍历视口    draw_traversal &#x3D; OpenMayaUI.MDrawTraversal()    # 创建视锥    draw_traversal.setFrustum(mdag_path, cmds.getAttr(&quot;defaultResolution.width&quot;),cmds.getAttr(&quot;defaultResolution.height&quot;))    draw_traversal.traverse()    frustum_objs &#x3D; []    # Loop through obiects within frustum    for i in range(draw_traversal.numberOfItems()):        # 先返回shape, 所以需要先获取它的transforn        shape_dag_path &#x3D; OpenMaya.MDagPath()        draw_traversal.itemPath(i, shape_dag_path)        transform_dag_path &#x3D; OpenMaya.MDagPath()        OpenMaya.MDagPath.getAPathTo(shape_dag_path.transform(), transform_dag_path)        # 获取物体的长名并且确保它是有效的transform        obj &#x3D; transform_dag_path.fullPathName()        if cmds.objExists(obj):            frustum_objs.append(obj)            cmds.select(frustum_objs)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    # 需要指定相机    cam &#x3D; &#39;persp&#39;  # 指定相机    getObjInView(cam)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenMaya </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya获取指定物体到Camera焦点平面的距离</title>
      <link href="/posts/20220227a1.html"/>
      <url>/posts/20220227a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="文章介绍"><a href="#文章介绍" class="headerlink" title="文章介绍"></a>文章介绍</h3><p style="text-indent:2em">在Maya中获取物体到相机焦点所在平面的距离，并将获取到的距离写入相机的焦距属性，使用Arnold渲染。<span id="more"></span></p><p style="text-indent:2em">本文介绍两种获取相机焦距的方法提供参考：一种是利用向量计算的办法计算向量之间的投射长度获取焦距，另一种是使用约束的方式获取焦距。</p><h3 id="方法一：计算向量"><a href="#方法一：计算向量" class="headerlink" title="方法一：计算向量"></a>方法一：计算向量</h3><p style="text-indent:2em">在三维空间中，已知相机单位向量、位置和物体坐标，可计算出相机焦点到物体的距离（该距离并非我们所要求的焦点平面到物体的距离），得到一个空间中存在的长方体，经过对物体和相机两点之间构成的向量投射到相机单位向量方向上的投影长度，即我们所求的相机焦点平面到物体的距离。如下图所示，空间中，我们需要获取线段ob之间的距离，其中线段oa之间的距离可根据相机和物体的坐标计算得出，相机法向量v可从相机中获取，由此我们可计算得出线段oa在向量v方向的投影。</p><p><img src="/images/Maya%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E7%89%A9%E4%BD%93%E5%88%B0Camera%E7%84%A6%E7%82%B9%E5%B9%B3%E9%9D%A2%E7%9A%84%E8%B7%9D%E7%A6%BB/%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE2.jpg" alt="空间示意图" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E7%89%A9%E4%BD%93%E5%88%B0Camera%E7%84%A6%E7%82%B9%E5%B9%B3%E9%9D%A2%E7%9A%84%E8%B7%9D%E7%A6%BB/%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE2.jpg" class="lozad post-image"></p><p style="text-indent:2em">首先，我们需要通过xfrom方法获取相机的法向量：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Cam &#x3D; mc.xform(cam.name(), q&#x3D;True, ws&#x3D;True, m&#x3D;True)[8:11]  # 数组第8到第10位为相机法向量Cam_vector &#x3D; np.array(Cam) * -1   # 由于取出的数据是列表，这里需要转换成向量再取反，即为相机单位向量方向<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p style="text-indent:2em">获取相机的坐标和物体的坐标，计算得出向量oa：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def getVector(locatorP, camP):    &quot;&quot;&quot;计算向量坐标        locatorP: 物体坐标        camP：相机坐标    &quot;&quot;&quot;    newVector &#x3D; (locatorP[0] - camP[0], locatorP[1] - camP[1], locatorP[2] - camP[2])    return newVector<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p style="text-indent:2em">由于需要区分向量之间的夹角，若为锐角，焦距为正，反之为负：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def judgeAngle(_ang):    &quot;&quot;&quot;计算向量角度为锐角还是钝角&quot;&quot;&quot;    _flag &#x3D; (_ang * 180.0) &#x2F; pi    print(u&quot;向量间的角度为: %s 度(角度制)&quot; % _flag)    if (_flag &gt; 90) and (_flag &lt;&#x3D; 180):        return -1    elif (_flag &lt; 90) and (_flag &gt;&#x3D; 0):        return 1    elif _flag &#x3D;&#x3D; 90:        return 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p style="text-indent:2em">使用上面获得的数据，即可求出相机焦点平面到物体的距离。以下为工具完整脚本：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-# @Author: MirrorCG# @Time: 2021&#x2F;12&#x2F;28# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;import maya.cmds as mcimport pymel.core as pmimport maya.mel as melfrom math import pi, cosimport numpy as npdef getVector(locatorP, camP):    &quot;&quot;&quot;计算向量坐标&quot;&quot;&quot;    newVector &#x3D; (locatorP[0] - camP[0], locatorP[1] - camP[1], locatorP[2] - camP[2])    return newVectordef squareRVector(_vector):    &quot;&quot;&quot;计算平方根，向量长度&quot;&quot;&quot;    AB &#x3D; (_vector[0] * _vector[0] + _vector[1] * _vector[1] + _vector[2] * _vector[2]) ** 0.5    return ABdef judgeAngle(_ang):    &quot;&quot;&quot;计算向量角度为锐角还是钝角&quot;&quot;&quot;    _flag &#x3D; (_ang * 180.0) &#x2F; pi    print(u&quot;向量间的角度为: %s 度(角度制)&quot; % _flag)    if (_flag &gt; 90) and (_flag &lt;&#x3D; 180):        return -1    elif (_flag &lt; 90) and (_flag &gt;&#x3D; 0):        return 1    elif _flag &#x3D;&#x3D; 90:        return 0def getCam(camName):    &quot;&quot;&quot;获取选中的相机，填入窗口&quot;&quot;&quot;    try:        cam &#x3D; pm.ls(sl&#x3D;True)[0].getChildren()[0]  # 选择相机    except IndexError as e:        mc.warning(u&quot;未选中对象&quot;)        return    if (not cam) or (cam.nodeType() !&#x3D; &quot;camera&quot;):        mc.warning(u&quot;未选中相机&quot;)        return    _camName &#x3D; cam.longName()    mc.textField(camName, e&#x3D;True, tx&#x3D;_camName)def createLocator(locName, camName):    &quot;&quot;&quot;创建&#x2F;获取locator,移动至相机位置，并将改1ocator填入窗口中&quot;&quot;&quot;    try:        cam &#x3D; pm.ls(mc.textField(camName, q&#x3D;True, tx&#x3D;True))[0].getParent()    except IndexError as e:        mc.warning(u&quot;请选择并添加相机&quot;)        return    camP &#x3D; cam.getTranslation().get()  # 相机坐标    if mc.objExists(&quot;find_focous&quot;) and pm.nodeType(pm.ls(&quot;find_focous&quot;)[0].getChildren()[0]) &#x3D;&#x3D; &quot;locator&quot;:        loc &#x3D; pm.ls(&quot;find_focous&quot;)[0]    else:        loc &#x3D; pm.createNode(&quot;locator&quot;).getParent()        loc.rename(&quot;find_focous&quot;)    loc.setAttr(&quot;translate&quot;, camP)    mc.textField(locName, e&#x3D;True, tx&#x3D;loc.name())def getInstance(instName, camName, locName, *args):    &quot;&quot;&quot;计算焦距，判断距离方向&quot;&quot;&quot;    if (not mc.textField(camName, q&#x3D;True, tx&#x3D;True)) or (not mc.textField(locName, q&#x3D;True, tx&#x3D;True)):        mc.warning(u&quot;请填入相机或locator(&#96;find_focous&#96;)&quot;)        return    cam &#x3D; pm.ls(mc.textField(camName, q&#x3D;True, tx&#x3D;True))[0].getParent()    camP &#x3D; cam.getTranslation().get()    loc &#x3D; pm.ls(mc.textField(locName, q&#x3D;True, tx&#x3D;True))[0]    cam_vector &#x3D; np.array(mc.xform(cam.name(), q&#x3D;True, ws&#x3D;True, m&#x3D;True)[8:11]) * -1  # 获取相机单位向量(从maya获取的向量需要取反    locatorP &#x3D; loc.getAttr(&quot;translate&quot;)  # 定位器坐标    AB_vector &#x3D; getVector(locatorP, camP)    AB &#x3D; squareRVector(AB_vector)  # 定位器距离相机距离    print(u&quot;定位器距离相机: %s 个单位&quot; % AB)    x &#x3D; np.array(cam_vector)    y &#x3D; np.array(AB_vector)    lx &#x3D; np.sqrt(x.dot(x))    ly &#x3D; np.sqrt(y.dot(y))    cos_angle &#x3D; x.dot(y) &#x2F; (lx * ly)    _angle &#x3D; np.arccos(cos_angle)    _flag &#x3D; judgeAngle(_angle)    if AB &#x3D;&#x3D; 0:        focus &#x3D; 0.1    else:        focus &#x3D; abs(cos(_angle) * AB)    if _flag &#x3D;&#x3D; 1:        pass    elif _flag &#x3D;&#x3D; -1:        focus &#x3D; (-1 * focus)    elif _flag &#x3D;&#x3D; 0:        focus &#x3D; 0.1    print(u&quot;相机焦距为: %s 个单位&quot; % focus)    mc.textField(instName, e&#x3D;True, tx&#x3D;&quot;%s&quot; % focus)    try:        cam.setAttr(&quot;focusDistance&quot;, focus)    except RuntimeError as e:        print(u&quot;焦距小于默认最小值,设定为0.1&quot;)    cam.setAttr(&quot;focusDistance&quot;, 0.1)    print(&quot;&#x3D;&quot; * 40)def toolDoc(winName):    &quot;&quot;&quot;工具帮助&quot;&quot;&quot;    win_name &#x3D; u&quot;工具帮助&quot;    if mc.window(win_name, q&#x3D;True, ex&#x3D;True):        mc.deleteUI(win_name, window&#x3D;True)    helpWin&#x3D; mc.window(u&quot;工具帮助&quot;, t&#x3D;u&quot;工具帮助&quot;, wh&#x3D;(700, 70), p&#x3D;winName)    mc.paneLayout()    mc.textScrollList(&quot;line&quot;,                      append&#x3D;[u&quot;1.选择相机：先选择要测量焦距的相机，再点击按钮(相机名可以手动填入，但相机名为长名，防止错误选择相机)&quot;,                              u&quot;2.创建locator：点击后创建定位器，或手动填入已有的locator(默认创建的1ocator为&#39;find_focous&#39;,手动填入不用点击)&quot;,                              u&quot;3.计算焦距按钮：先移动调整好位置的1ocator，点击&#39;移动locator，计算焦距&#39;按钮，即可测出想要的焦距&quot;,                              u&quot;4.帮 助：本工具的使用说明&quot;])    mc.textScrollList(&quot;line&quot;, edit&#x3D;True, lf&#x3D;[(1, &quot;fixedWidthFont&quot;), (2, &quot;fixedWidthFont&quot;), (3, &quot;fixedWidthFont&quot;), (4, &quot;fixedWidthFont&quot;)])    mc.showWindow(helpWin)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    win_name &#x3D; u&quot;测量相机焦距&quot;    if mc.window(win_name, q&#x3D;True, ex&#x3D;True):        mc.deleteUI(win_name, window&#x3D;True)    win &#x3D; mc.window(win_name, title&#x3D;u&quot;测量相机焦距&quot;, iconName&#x3D;u&quot;Short_Name&quot;, widthHeight&#x3D;(400, 110))    mc.columnLayout(adjustableColumn&#x3D;True, rs&#x3D;2)    mc.rowColumnLayout(numberOfColumns&#x3D;3, columnAttach&#x3D;(1, &quot;right&quot;, 0), columnWidth&#x3D;[(1, 60), (2, 240), (3, 100)])    mc.text(label&#x3D;u&#39;相 机 名:&#39;, align&#x3D;&#39;left&#39;)    camName &#x3D; mc.textField()    mc.button(label&#x3D;u&#39;选择相机&#39;, command&#x3D;&quot;getCam(camName)&quot;)    mc.setParent(&#39;..&#39;)    mc.rowColumnLayout(numberOfColumns&#x3D;3, columnAttach&#x3D;(1, &#39;right&#39;, 0), columnWidth&#x3D;[(1, 60), (2, 240), (3, 100)])    mc.text(label&#x3D;u&#39;locator: &#39;, align&#x3D;&#39;left&#39;)    locName &#x3D; mc.textField()    mc.button(label&#x3D;u&#39;创建1ocator&#39;, command&#x3D;&quot;createLocator(locName,camName)&quot;)    mc.setParent(&#39;..&#39;)    mc.button(label&#x3D;u&quot;移动locator,计算距离&quot;, command&#x3D;&quot;getInstance(instName, camName, 1ocName)&quot;, bgc&#x3D;(1, 0.73, 0.14))    mc.rowColumnLayout(numberOfColumns&#x3D;4, columnAttach&#x3D;(1, &#39;right&#39;, 0), columnWidth&#x3D;[(1, 60), (2, 200), (3, 100), (4, 40)])    mc.text(label&#x3D;u&#39;焦  距:&#39;, align&#x3D;&#39;left&#39;)    instName &#x3D; mc.textField(ed&#x3D;False, bgc&#x3D;(0.64, 0.79, 10.48))    mc.text(label&#x3D;u&quot; &quot;, align&#x3D;&#39;left&#39;)    mc.button(label&#x3D;u&#39;帮助&#39;, command&#x3D;&quot;toolDoc(win)&quot;)    mc.setParent(&quot;..&quot;)    mc.setParent(&quot;..&quot;)    mc.showWindow(win)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p style="text-indent:2em">若要动态获取相机焦距，可将下面的脚本修改后填入相机属性的表达式中。</p><pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">vector $camP &#x3D; &#96;getAttr camera1.translate&#96;; &#x2F;&#x2F;相机坐标float $camVct[16] &#x3D; &#96;xform -q -m -ws camera1&#96;; &#x2F;&#x2F;相机世界空间矩阵vector $camVector &#x3D; &lt;&lt;$camVct [8],$camVct[9],$camVct [10]&gt;&gt;*-1;  &#x2F;&#x2F;从maya中获取的相机向量，需要取反vector $locP &#x3D; &#96;getAttr find_focous.translate&#96;;vector $lcInstance &#x3D; $locP - $camP;float $inst &#x3D; mag($locP - $camP); &#x2F;&#x2F;物体距离相机的距离float $_angle &#x3D; angle($camVector,$lcInstance); &#x2F;&#x2F;向量间的夹角float $_focus &#x3D; cos($_angle)*$inst; &#x2F;&#x2F;焦距float $flag &#x3D; ($_angle*180)&#x2F;3.141592657;if ($flag &gt;&#x3D; 90)&#123;    $focus &#x3D; 0.1;&#125;print $_focus;cameraShape1.focusDistance &#x3D; $_focus;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="方法二：添加约束"><a href="#方法二：添加约束" class="headerlink" title="方法二：添加约束"></a>方法二：添加约束</h3><p style="text-indent:2em">在相机位置创建两个定位器：其中一号定位器p到相机上，使用二号定位器约束一号定位器的Z轴，并设置Z轴数值的最大值（因为方向是反的，所以设置最大值，可以自己尝试一下），将二号定位器移动到物体的位置并添加约束，此时，一号定位器的Z轴数值即是相机焦距，将此属性连接到相机的aifocus属性即可动态获取相机焦距，如下图所示：</p><p><img src="/images/Maya%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E7%89%A9%E4%BD%93%E5%88%B0Camera%E7%84%A6%E7%82%B9%E5%B9%B3%E9%9D%A2%E7%9A%84%E8%B7%9D%E7%A6%BB/%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE3.jpg" alt="空间示意图" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E7%89%A9%E4%BD%93%E5%88%B0Camera%E7%84%A6%E7%82%B9%E5%B9%B3%E9%9D%A2%E7%9A%84%E8%B7%9D%E7%A6%BB/%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE3.jpg" class="lozad post-image"></p><p style="text-indent:2em">约束工具如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-# @Auth0r: MirrorCG# @Time: 2021&#x2F;12&#x2F;28# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;import maya.cmds as mcimport pymel.core as pmclass getDistance():    def __init__(self):        win_name &#x3D; u&quot;测量相机焦距&quot;        if mc.window(win_name, q&#x3D;True, ex&#x3D;True):            mc.deleteUI(win_name, window&#x3D;True)        self.win &#x3D; mc.window(win_name, title&#x3D;u&quot;测量相机焦距&quot;, iconName&#x3D;u&#39;short Name&#39;, widthHeight&#x3D;(400, 120))        mc.columnLayout(adjustableColumn&#x3D;True, rs&#x3D;2)        mc.rowColumnLayout(numberOfColumns&#x3D;3, columnAttach&#x3D;(1, &#39;right&#39;, 0), columnWidth&#x3D;[(1, 60), (2, 240), (3, 100)])        mc.text(label&#x3D;u&quot;相 机 名:&quot;, align&#x3D;&#39;left&#39;)        self.camName &#x3D; mc.textField()        mc.button(label&#x3D;u&quot;选择相机&quot;, command&#x3D;lambda x: self.getCam(self.camName))        mc.setParent(&#39;..&#39;)        mc.rowColumnLayout(numberOfColumns&#x3D;3, columnAttach&#x3D;(1, &#39;right&#39;, 0), columnWidth&#x3D;[(1, 60), (2, 240), (3, 100)])        mc.text(label&#x3D;u&quot;locator:&quot;, align&#x3D;&#39;left&#39;)        self.locName &#x3D; mc.textField()        mc.button(label&#x3D;u&quot;创建locator&quot;, command&#x3D;lambda x: self.createLocators(self.locName))        mc.setParent(&quot;..&quot;)        mc.rowColumnLayout(numberOfColumns&#x3D;3, columnWidth&#x3D;[(1, 180), (2, 40), (3, 180)])        mc.button(label&#x3D;u&quot;约束到选择的物体&quot;, command&#x3D;lambda x: self.addCtrlWithObj(), bgc&#x3D;(1, 0.73, 0.14))        mc.text(label&#x3D;u&#39; &#39;, align&#x3D;&#39;right&#39;)        mc.button(label&#x3D;u&quot;清除产生的对象&quot;, command&#x3D;lambda x: self.cleanAll(), bgc&#x3D;(1, 0.73, 0.14))        mc.setParent(&quot;..&quot;)        mc.rowColumnLayout(numberOfColumns&#x3D;2, columnAttach&#x3D;(1, &#39;right&#39;, 0), columnWidth&#x3D;[(1, 360), (2, 40)])        mc.text(label&#x3D;u&#39; &#39; * 8, align&#x3D;&#39;left&#39;)        mc.button(label&#x3D;u&quot;帮助&quot;, command&#x3D;lambda x: self.toolDoc())        mc.setParent(&#39;..&#39;)        mc.setParent(&#39;..&#39;)        mc.showWindow(self.win)    def getCam(self, *args):        &quot;&quot;&quot;获取选中的相机，填入窗口&quot;&quot;&quot;        try:            cam &#x3D; pm.ls(sl&#x3D;True)[0].getChildren()[0]  # 选择相机        except IndexError as e:            mc.warning(u&quot;未选中对象&quot;)            return        if (not cam) or (cam.nodeType() !&#x3D; &quot;camera&quot;):            mc.warning(u&quot;未选中相机&quot;)            return        _camName &#x3D; cam.longName()        mc.textField(self.camName, e&#x3D;True, tx&#x3D;_camName)    def connectParm(self, loc_a):        &quot;&quot;&quot;连接相机属性&quot;&quot;&quot;        cam &#x3D; pm.ls(mc.textField(self.camName, q&#x3D;True, tx&#x3D;True))[0]        # cam.setAttr(&quot;aiEnableDOF&quot;,1)        node_name &#x3D; &quot;distance_data&quot;        if mc.objExists(node_name):            mc.delete(node_name)        mc.createNode(&quot;floatMath&quot;, n&#x3D;node_name)        mc.setAttr(node_name + &quot;.operation&quot;, 2)        mc.setAttr(node_name + &quot;.floatB&quot;, -1)        mc.connectAttr(loc_a.name() + &quot;.translateZ&quot;, node_name + &quot;.floatA&quot;, f&#x3D;True)        mc.connectAttr(node_name + &quot;.outFloat&quot;, cam.name() + &quot;.aiFocusDistance&quot;, f&#x3D;True)    def addCtrl(self, loc_m, loc_a):        &quot;&quot;&quot;m添加约束和设置可见性&quot;&quot;&quot;        cam &#x3D; mc.textField(self.camName, q&#x3D;True, tx&#x3D;True)        mc.parent(loc_a.name(), cam)        mc.transformLimits(loc_a.name(), tz&#x3D;(-1, -0.02), etz&#x3D;(0, 1))        mc.setAttr(loc_a.fullPath() + &quot;.visibility&quot;, 0)        mc.setAttr(loc_a.fullPath() + &quot;.visibility&quot;, lock&#x3D;True)        mc.parentConstraint(loc_m.name(), loc_a.name(), mo&#x3D;True, st&#x3D;[&quot;x&quot;, &quot;y&quot;], sr&#x3D;[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])    def createLocators(self, *args):        &quot;&quot;&quot;创建 &#x2F; 获取1ocator, 移动至相机位置，并将该主1ocator填入窗口中&quot;&quot;&quot;        try:            cam &#x3D; pm.ls(mc.textField(self.camName, q&#x3D;True, tx&#x3D;True))[0].getParent().fullPath()        except IndexError as e:            mc.warning(u&quot;请选择并添加正确的相机&quot;)            return        cam_p &#x3D; mc.xform(cam, q&#x3D;True, ws&#x3D;True, t&#x3D;True)  # 相机世界坐标        if mc.objExists(&quot;find_focus&quot;):  # 用于移动的locator            loc_m &#x3D; pm.ls(&quot;find_focus&quot;)[0]            pm.delete(loc_m)        loc_m &#x3D; pm.createNode(&quot;locator&quot;).getParent()        loc_m.rename(&quot;find_focus&quot;)        if mc.objExists(&quot;cam_center&quot;):            loc_a &#x3D; pm.ls(&quot;cam_center&quot;)[0]            pm.delete(loc_a)        loc_a &#x3D; pm.createNode(&quot;locator&quot;).getParent()        loc_a.rename(&quot;cam_center&quot;)        loc_m.setAttr(&quot;translate&quot;, cam_p)        loc_a.setAttr(&quot;translate&quot;, cam_p)        mc.textField(self.locName, e&#x3D;True, tx&#x3D;loc_m.name())        self.addCtrl(loc_m, loc_a)  # 添加约束和设置可见性        self.connectParm(loc_a)    def addCtrlWithObj(self, *args):        &quot;&quot;&quot;约束到物体&quot;&quot;&quot;        try:            loc_m &#x3D; pm.ls(mc.textField(self.locName, q&#x3D;True, tx&#x3D;True))[0].fullPath()        except IndexError as e:            mc.warning(u&quot;未创建或填入定位器&quot;)            return        obj &#x3D; &quot;&quot;        for i in mc.ls(sl&#x3D;True):            if &quot;find focus&quot; not in i:                obj &#x3D; i                break            continue        if not obj:            mc.warning(u&quot;未选择约束物体，或约束物体名称中含有&#39;find_focus&#39;字符串&quot;)        mc.parentConstraint(obj, loc_m, mo&#x3D;True, sr&#x3D;[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])    def cleanAll(self, *arqs):        &quot;&quot;&quot;清除本工具产生的所有节点&quot;&quot;&quot;        node_list &#x3D; [&quot;distance_data&quot;, &quot;find_focus&quot;, &quot;cam_center&quot;]        for i in node_list:            if mc.objExists(i):                mc.delete(i)    def toolDoc(self):        &quot;&quot;&quot;工具帮助&quot;&quot;&quot;        win_name &#x3D; u&quot;工具帮助&quot;        if mc.window(win_name, q&#x3D;True, ex&#x3D;True):            mc.deleteUI(win_name, window&#x3D;True)        help_win &#x3D; mc.window(u&quot;工具帮助&quot;, t&#x3D;u&quot;工具帮助&quot;, wh&#x3D;(640, 100), p&#x3D;self.win)        mc.paneLayout()        mc.textScrollList(&quot;line&quot;, append&#x3D;[u&quot;1.选择相机:先选择要测量焦距的相机，再点击按钮(相机名可以手动填入，但相机名为长名，防止错误选择相机)&quot;,                                          u&quot;2,创建locator:点击后，在相机处创建定位器，创建的1ocator名称为&#39;find focous&#39;&quot;,                                          u&quot;3.约束到选择物体:先调整好locator(find focous)的位置，选择约束物体，点击&#39;约束到选择物体&#39;，即测出想要的焦距，属性将自动连接&quot;,                                          u&quot;4.清除对象，清除本工具产生的相关节点&quot;, u&quot;5.帮助:本工具的使用说明&quot;])        mc.textScrollList(&quot;line&quot;, edit&#x3D;True, lf&#x3D;[(1, &quot;fixedWidthFont&quot;), (2, &quot;fixedWidthFont&quot;), (3, &quot;fixedWidthFont&quot;),                                                 (4, &quot;fixedWidthFont&quot;), (5, &quot;fixedWidthFont&quot;)])        mc.showWindow(help_win)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    tool &#x3D; getDistance()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灯光 </tag>
            
            <tag> 向量计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Aitoon材质灯光分层的探索</title>
      <link href="/posts/20220226a2.html"/>
      <url>/posts/20220226a2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p style="text-indent:2em">前段时间，开始对在 Maya 中进行三渲二的渲染分层有了兴趣。于是，我就尝试自己探索一下：在 Maya 中使用 Aitoon 材质进行三渲二的灯光分层，以及在 Nuke中进行合成的流程。<span id="more"></span>现在的三渲二影视作品普遍采用亮面、暗面加边缘光的方式进行灯光分层，部分镜头需要以亮面、灰面和暗面加边缘光的方式进行灯光分层，灯光师仅完成灯光角度的设计即可，最终画面氛围和效果需要合成师完成，这种分层方式使用aitoon材质球可以很容易地完成。</p><p>测试环境:maya 2018.5+Arnold 6.0.1.0<br>测试角色:不要钱的派大星</p><h3 id="一-材质相关"><a href="#一-材质相关" class="headerlink" title="一. 材质相关"></a>一. 材质相关</h3><p style="text-indent:2em">前期部门仅制作卡通材质，不需要在材质球中为rim、highlight 指定灯光。材质球的base 权重需要设定为1（下图1），关闭材质的能量守恒选项和间接反射（下图2），材质的baseTonemap属性都链接ramp节点并保持只有两个点。调节材质、线框效果与贴图的阴影融合等步骤需要前期部门调整到最终效果。如果做了材质阴影融合，材质部门需要提供另一套只带有阴影贴图的 aimatte 材质球用于切换，供灯光部门渲染阴影通道使用。</p><table><tr><td><img src="/images/关于Aitoon材质灯光分层的探索/图1-1.png" border=1 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图1-1.png" class="lozad post-image"></td><td><img src="/images/关于Aitoon材质灯光分层的探索/图1-2.png" border=1 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图1-2.png" class="lozad post-image"></td></tr></table><h3 id="二．灯光环节流程"><a href="#二．灯光环节流程" class="headerlink" title="二．灯光环节流程"></a>二．灯光环节流程</h3><pre><code>1.灯光使用要求</code></pre><p style="text-indent:2em">由于卡通材质的特殊性，灯光渲染需要至少一盏光源即可区分亮暗，根据官方介绍虽然 aitoon 材质并不挑剔灯光类型，但由于面光源和skydome等灯光的性质，可能会导致受光面的强度大于1，从而导致莫名的错误，灯光的要求使用平行光、点光源或者聚光灯，并且这三种光源对于风格化高光的形成效果较好，可控性更高。</p>    2.Aov及渲染分层<p style="text-indent:2em">通过对aitoon材质的渲染，我们可以获取Arnold提供的所有的Aov通道，但由于aitoon材质球并非基干物理的材质球，并不能按照LPE的方式进行分层，传统的分成方式需要考虑灯光的强度和颜色对贴图的影响以及材质之间的影响，而卡通渲染并不计算diffuse的灯光颜色信息，因此我们可以采用diffusealbedo+主光照射范围+暗部颜色+平面反射+透射的方式进行分层，此方法能保持合成的可调性的同时也最大限度保留了材质的效果。通过读取模型的材质信息，给模型添加附加属性，用aiuserdata节点传递已经记录的每个模型的材质球信息，即可确认模型被灯光照射的亮暗面的范围，最终输出通道，具体方式如下：</p>    (1)主光照射范围+暗部颜色<p style="text-indent:2em">给每一个材质为aitoon的物体添加Arnold额外属性(color1,color2.pos1,pos2.interpolation)用于记录数据（下图左一），该属性记录材质球的basetonemap中ramp 的信息（下图右一），其中颜色数据使用vector类型 ，位置数据使用float类型，ramp的过度类型使用int类型，这三种类型分别可对应用户数据节点的 aiUserDataColor、aiUserDataFloat、aiUserDatalnt。</p><table><tr><td><img src="/images/关于Aitoon材质灯光分层的探索/图2-1.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图2-1.png" class="lozad post-image"></td><td><img src="/images/关于Aitoon材质灯光分层的探索/图2-2.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图2-2.png" class="lozad post-image"></td></tr></table><p style="text-indent:2em">以 toon_key 为例创建自定义 aov（下图左一），通过创建自定义的aov，将aov色器选择为新创建的 aitoon 卡通材质球 关闭该aitoon 材质球的能量守恒，边缘，高光。将basecolor调为1，并给basetonemap链接一个默认的ramp节点。创建2个aiUserDataColor2个aiUserDataFloat1个aiUserDatalnt节点，并将color1、color2分别填入aiUserDataColor，pos1、pos2分别填入aiUserDataFloat，interpolation填入aiUserDatalnt，将五个节点链接到上一步的ramp中即可渲染出，所需要的包含有灯光照射的两部范围信息的aov，该aov的色彩信息为仅为灯光照射的亮面（toon_key）(不含材质信息)，以此类推，可获得暗面的颜色（toon_env），渲染出的aov（下图右一）</p><table><tr><td><img src="/images/关于Aitoon材质灯光分层的探索/图2-3.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图2-3.png" class="lozad post-image"></td><td><img src="/images/关于Aitoon材质灯光分层的探索/图2-4.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图2-4.png" class="lozad post-image"></td></tr></table><p>至此，我们获得需要的灯光层，该灯光层保留材质的 ramp 亮暗面信息和亮暗部区域(非aitoon 材质渲染为黑色。</p>    (2) Diffuse abedle、高光和透射<p style="text-indent:2em">材质本身的高光和透射可利用maya自身的aov输出，分别为specular direct、specular indirect，transmission direct， transmission indirect。</p>    (3) edge<p style="text-indent:2em">物体的边缘线输出，需要通过自定义edge aov进行输出，需要将aov的filter设定为 contour类型否则渲染不出线框（如下图）。</p><table><tr><td><img src="/images/关于Aitoon材质灯光分层的探索/图2-5.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图2-5.png" class="lozad post-image"></td><td><img src="/images/关于Aitoon材质灯光分层的探索/图2-6.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图2-6.png" class="lozad post-image"></td></tr></table>    (4) 边缘光和风格化高光<p style="text-indent:2em">为了便于调节，aitoon材质的rim边缘光和风格化高光可通过单独分层并对层中的物体进行材质覆盖的方式进行提取aov，单独分层也有利于控制效果。</p>    (5) 其他需要的aov<p style="text-indent:2em">除上述aov外,其他一些aov可根据需求添加，本文考虑使用的辅助aov包括:N、 fresnel、OCC、RBzd、P、crypto_matte(三种)、direct和indirect 可在含有非aitoon材质时输出，用于调整非aitoon材质物体。</p>    (6)文件分层<p style="text-indent:2em">文件的分层方式通过maya的renderSetup分层方式进行分层，最后以模板的形式导出渲染层，供流程使用。使用render Setup的方 式分层可以很方便地对模型进行材质覆盖、属性覆盖和导出自定义aov的操作，以边光和风格化层高光为例，为保持物体边缘光的统一性，需要整体赋予一个aitoon材质球，用于调整边缘光效果;而材质球的边缘光和风格化高光属性是没有填入对应灯光的shape名称的，因此可以在覆盖材质或者属性的基础上，统一给相关的模型覆盖属性或材质球，达到渲染效果。</p><h3 id="三．合成"><a href="#三．合成" class="headerlink" title="三．合成"></a>三．合成</h3><p style="text-indent:2em">通过上面的方法，我们可以得到合成所需要的aov，通过合成树即可还原灯光渲染的效果（合成树中的图片不是本例的图片，此处仅做示范），并在此基础上由合成师进行环境氛围和灯光效果的调整即可（如下图）。</p><table><tr><td><img src="/images/关于Aitoon材质灯光分层的探索/图3-1.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图3-1.png" class="lozad post-image"></td><td><img src="/images/关于Aitoon材质灯光分层的探索/图3-2.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图3-2.png" class="lozad post-image"></td></tr></table><h3 id="四．写在最后"><a href="#四．写在最后" class="headerlink" title="四．写在最后"></a>四．写在最后</h3><p style="text-indent:2em">此方法按照aitoon材质球的非基于物理渲染的特性，以basetonemap的ramp与贴图相乘得出最终颜色信息的特点，进行aov分层;它相对于单纯使用aitoon材质球对物体进行材质覆盖的方式进行亮暗部区分的优点在于，不以单一的材质覆盖的亮暗部过度信息、能更准确地保留材质的亮暗部范围和过度方式、能分别获取到材质的亮暗部rgb信息。相对于传统基于物理的分层方式，能单独调整亮暗面颜色信息，由于三渲二不能在灯光中处理氛围，此方式在合成中可调性更高。</p><p>注意：在输出AOV通道时，若自定义的AOV和Arnold渲染器自带的AOV一起渲染出图时，会导致Arnold渲染器自带的Aov渲染错误，不渲染出正确的信息，因此，自定义的AOV需要单独分层渲染。</p>]]></content>
      
      
      <categories>
          
          <category> Maya </category>
          
          <category> arnold </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灯光 </tag>
            
            <tag> Aitoon </tag>
            
            <tag> aiUserData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客文章语法示例</title>
      <link href="/posts/20220220a2.html"/>
      <url>/posts/20220220a2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是文章摘要 <span id="more"></span>，下面是废话</p><p>文件最上方以 — 分隔的区域称为”Front_matter”</p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h3><p style="text-indent:2em">内容</p><h3 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h3><p>段落没有特殊的格式，直接编写文字就好，<br>段落的换行是使用两个以上空格加上回车，</p><p>也可以在段落后面使用一个空行来表示重新开始一个段落</p><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><h4 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h4><hr><hr><hr><hr><hr><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p><del>BAIDU.COM</del></p><h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><p><u>带下划线文本</u></p><h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>[^要注明的文本]</p><h3 id="这是引用块"><a href="#这是引用块" class="headerlink" title="这是引用块"></a>这是引用块</h3><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io/">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://www.baidu.com">www.baidu.com</a></cite></footer></blockquote><h3 id="这是文字链接"><a href="#这是文字链接" class="headerlink" title="这是文字链接"></a>这是文字链接</h3><a href="https://git-scm.com/download/win" title="" target="">下载git</a><p>这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a><br>或直接使用网址 <a href="https://www.runoob.com/">https://www.runoob.com</a></p><h3 id="这是代码块"><a href="#这是代码块" class="headerlink" title="这是代码块"></a>这是代码块</h3><pre class="language-none"><code class="language-none">alert(&#39;Hello World!&#39;);</code></pre><pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">[rectangle setX: 10 y: 10 width: 20 height: 20];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><div class="caption"><span>Array.map</span></div><code class="language-none">array.map(callback[, thisArg])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><div class="caption"><span>_.compact</span><a href="http://underscorejs.org/#compact">Underscore.js</a></div><code class="language-none">_.compact([0, 1, false, 2, &#39;&#39;, 3]);&#x3D;&gt; [1, 2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是反引号代码块</p><pre class="line-numbers language-语言名称" data-language="语言名称"><div class="caption"><span>标题</span></div><code class="language-语言名称">array.map(callback[, thisArg])print(11111)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>pull quote</p><blockquote class="pullquote [class]"><p>content<br>sss<br>sss<br>sss</p></blockquote><h3 id="这是jsFiddle-jsFiddle是一个在线的shell编辑器"><a href="#这是jsFiddle-jsFiddle是一个在线的shell编辑器" class="headerlink" title="这是jsFiddle(jsFiddle是一个在线的shell编辑器)"></a>这是jsFiddle(jsFiddle是一个在线的shell编辑器)</h3><iframe scrolling="no" width="[width]" height="[height]" src="https://jsfiddle.net/shorttag/embedded/[tabs]/[skin]" frameborder="0" loading="lazy" allowfullscreen></iframe><h3 id="在文章中插入指定大小的图片"><a href="#在文章中插入指定大小的图片" class="headerlink" title="在文章中插入指定大小的图片"></a>在文章中插入指定大小的图片</h3><img src="/images/%E6%B5%B7.jpg" class="[文章jpg] lozad post-image" width="200" height="100" title="title text" alt="alt text" srcset="/images/home/Myhead.jpg" data-src="/images/%E6%B5%B7.jpg"><p><img src="/images/%E6%B5%B7.jpg" alt="img jpg" srcset="/images/home/Myhead.jpg" data-src="/images/%E6%B5%B7.jpg" class="lozad post-image">  </p><h3 id="html支持的使用表放置图片的方式"><a href="#html支持的使用表放置图片的方式" class="headerlink" title="html支持的使用表放置图片的方式"></a>html支持的使用表放置图片的方式</h3><table><tr><td><img src="/images/关于Aitoon材质灯光分层的探索/图2-3.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图2-3.png" class="lozad post-image"></td><td><img src="/images/关于Aitoon材质灯光分层的探索/图2-4.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/关于Aitoon材质灯光分层的探索/图2-4.png" class="lozad post-image"></td></tr></table><h3 id="这是视频"><a href="#这是视频" class="headerlink" title="这是视频"></a>这是视频</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/lJIrF4YjHfQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>这是文本引用</p><a href="#">Post not found: hexo-4-released How to use <b> tag</b> in title</a><h3 id="这是数据引用"><a href="#这是数据引用" class="headerlink" title="这是数据引用"></a>这是数据引用</h3><p>&lt;% for (var link in site.data.menu) { %&gt;<br>  <a href="<%= site.data.menu[link] %>"> &lt;%&#x3D; link %&gt; </a><br>&lt;% } %&gt;</p><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>这是表格示例，使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><ul><li>无标区块1</li></ul><ul><li>无标区块2</li></ul><ol><li>有标区块</li></ol><p>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><blockquote><p>嵌套标区块1</p><blockquote><p>嵌套区块2</p><blockquote><p>嵌套区块3</p></blockquote></blockquote><ul><li>嵌套区块4</li></ul></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><ul><li>第一项</li></ul><ul><li>第二项</li></ul><ul><li>第三项</li></ul><p>嵌套列表<br>列表嵌套只需在子列表中的选项前面添加两个或四个空格即可</p><ol><li>第一项<ul><li>嵌套的第一个元素</li></ul></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codesheep.cn/">www.codesheep.cn</a></p><!-- 下面是评论界面 --><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script type="text/javascript">var gitalk = new Gitalk({    id: '',    clientID: '',    clientSecret: '',    repo: 'gitalk',    owner: 'JairusTse',    admin: ['JairusTse'],    labels: ['Gitalk'],    perPage: 50})gitalk.render('gitalk-container')</script>]]></content>
      
      
      <categories>
          
          <category> Doc </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文档</title>
      <link href="/posts/20220220a1.html"/>
      <url>/posts/20220220a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. <span id="more"></span>If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Doc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
