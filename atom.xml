<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mirror的个人博客</title>
  
  <subtitle>Mirror的博客</subtitle>
  <link href="http://mirrorcg.github.io/atom.xml" rel="self"/>
  
  <link href="http://mirrorcg.github.io/"/>
  <updated>2022-08-14T11:46:35.000Z</updated>
  <id>http://mirrorcg.github.io/</id>
  
  <author>
    <name>Mirror</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ShotGrid的API使用示例</title>
    <link href="http://mirrorcg.github.io/posts/20220814a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220814a1.html</id>
    <published>2022-08-14T10:46:39.000Z</published>
    <updated>2022-08-14T11:46:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">本文为 ShotGrid 的 Python API 学习笔记。<span id="more"></span></p><h3 id="注册网站"><a href="#注册网站" class="headerlink" title="注册网站"></a>注册网站</h3><p>如果已经有了自己可操作的 ShotGrid 网站页面，就直接开始吧。没有的话需要在 Autodesk 官网下找到<a href="https://www.shotgridsoftware.com/trial/" title="" target="">ShotGrid 注册</a>自己的 ShotGrid 网站页面，设置邮箱和电话号码后，获取登录账户和密码（可以获得30天的试用时间），就可以开始下面的操作了。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h5 id="最低要求"><a href="#最低要求" class="headerlink" title="最低要求"></a>最低要求</h5><ul><li>Python 2.7 或 Python 3.7</li></ul><h5 id="下载并写入Python搜索路径"><a href="#下载并写入Python搜索路径" class="headerlink" title="下载并写入Python搜索路径"></a>下载并写入Python搜索路径</h5><ul><li>手动下载<ul><li>下载 PythonAPI 库到本地：<a href="https://github.com/shotgunsoftware/python-api/releases" title="" target="">从这下载</a>最新版本到本地。</li><li>将下载的 PythonAPI 加入到 PYTHONPATH 环境变量中，用于我们在代码中可搜索到对应的模块。</li></ul></li><li>pip下载<ul><li>安装最新版本<pre class="language-dos" data-language="dos"><code class="language-dos">pip install git+https:&#x2F;&#x2F;github.com&#x2F;shotgunsoftware&#x2F;python-api.git</code></pre></li><li>安装特定版本<pre class="language-dos" data-language="dos"><code class="language-dos">pip install git+https:&#x2F;&#x2F;github.com&#x2F;shotgunsoftware&#x2F;python-api.git@v3.0.26</code></pre></li></ul></li></ul><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>直接使用用户名和密码，用户身份登录的脚本操作，会生成事件，其中存储了一些额外的元数据，EventLogEntry用于标识事件是由代表用户的脚本创建的。<br><img src="/images/ShotGrid%E7%9A%84API%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/%E4%BA%8B%E4%BB%B6%E7%94%9F%E6%88%90%E6%8E%A7%E5%88%B6.png" alt="事件生成控制 png" srcset="/images/home/Myhead.jpg" data-src="/images/ShotGrid%E7%9A%84API%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/%E4%BA%8B%E4%BB%B6%E7%94%9F%E6%88%90%E6%8E%A7%E5%88%B6.png" class="lozad post-image"><br>而使用脚本身份验证登录前，必须在Shotgun 中注册 (User&gt;Scripts)并具有有效的 API 密钥 (密钥需要在创建的时候记录下来，创建完后不再显示).</p><ul><li><p>基于用户名登陆验证</p><pre class="language-none"><code class="language-none">sg &#x3D; shotgun_api3.Shotgun(&quot;https:&#x2F;&#x2F;piedpiper.shotgunstudio.com&quot;,                        login&#x3D;&quot;rhendriks&quot;,                        password&#x3D;&quot;c0mPre$Hi0n&quot;)</code></pre></li><li><p>基于脚本登录验证</p><pre class="language-none"><code class="language-none">sg &#x3D; shotgun_api3.Shotgun(&quot;https:&#x2F;&#x2F;piedpiper.shotgunstudio.com&quot;,                        login&#x3D;&quot;rhendriks&quot;,                        password&#x3D;&quot;c0mPre$Hi0n&quot;)</code></pre></li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>ShotGrid 官方文档：<a href="https://github.com/shotgunsoftware/python-api">https://github.com/shotgunsoftware/python-api</a></p>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-indent:2em&quot;&gt;本文为 ShotGrid 的 Python API 学习笔记。</summary>
    
    
    
    <category term="ShotGrid" scheme="http://mirrorcg.github.io/categories/ShotGrid/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/ShotGrid/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="API" scheme="http://mirrorcg.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Nuke学习笔记4_回调函数</title>
    <link href="http://mirrorcg.github.io/posts/20220807a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220807a1.html</id>
    <published>2022-08-07T12:41:35.000Z</published>
    <updated>2022-08-07T12:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h3 id="Nuke-API-文档"><a href="#Nuke-API-文档" class="headerlink" title="Nuke API 文档"></a>Nuke API 文档</h3><ul><li>本地文档：C:\Program Files\Nuke12.2v2\Documentation</li><li>在线文档：<a href="https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html">https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html</a><ul><li>Nuke Python Developers Guide: 案例教程</li><li>Python Scripting Reference： API 参考文档</li><li>TCL Scripting Reference: TCL 表达式参考文档</li></ul></li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>部分回调函数的使用</p><ul><li>添加回调函数<ul><li>nuke.toNode(“节点名”)[“knobChanged”].setValue(回调函数) 仅对选择的节点生效，此处回调函数是字符串格式</li><li>nuke.addOnCreate(callable,args&#x3D;(),kwargs&#x3D;{},nodeClass&#x3D;”*”)</li><li>callable 可调用对象</li><li>args 不定长位置参数列表</li><li>kwargs 不定长关键字参数字典</li><li>nodeClass 默认值是星号，指无论当前节点是什么，在事件发生时都会执行这个回调函数，需自定义</li></ul></li><li>删除回调函数</li><li>事件函数<ul><li><p>knobChanged 用户在打开的面版中改变knob后执行事件，可实现联动事件</p><ul><li>nuke.thisNode() 该控件在打开、关闭面板或输入端改变时，分别指向showPanel、hidePanel、inputChange事件，这三个控件使用代码获取不到，但可以在knobChange中使用控件名<pre class="language-Python" data-language="Python"><code class="language-Python">def testevent():    &quot;&quot;&quot;如果打开面板，打印内容&quot;&quot;&quot;    k&#x3D;nuke.thisKnob()    if k.name() &#x3D;&#x3D; &quot;showPanel&quot;:        print(&quot;show&quot;)nuke.addKnobChanged(testevent, nodeClass&#x3D;&quot;NoOp&quot;)</code></pre></li></ul></li><li><p>updateUI 任意UI发生变化后触发，比knobChange优先级低，不应在其中添加任何和回调结构有关的操作</p></li><li><p>autolabel 在updateUI之后执行，用于为节点设置在Node Grape中显示的文本 ，按照函数添加的顺序，从后往前执行，只要那个函数的返回值不是None，那么这个返回值就用于该节点的显示文本，若没有返回值或返回值为None,则使用节点名显示，该显示的文本和label标签不同。</p></li></ul></li></ul><p>回调函数执行顺序：<br>可以通过控件设置的回调函数 &gt; 使用注册回调函数添加的回调函数<br>使用注册回调函数添加的回调函数的优先级依赖注册的先后顺序，并先执行指定了nodeClass参数的回调，再执行满足所有类型的回调。addAutolabel()和addFilenameFilter()是特里，它们恰恰与之相反。<br>onCreate 对于Group节点，会先执行其中的内部节点，然后再在Group节点上执行一遍回调<br>onDestory事件和onCreate事件相反<br>onUserCreate执行优先级 &gt; onCreate执行优先级 </p><h3 id="部分回调函数"><a href="#部分回调函数" class="headerlink" title="部分回调函数"></a>部分回调函数</h3><table><tr><td><img src="/images/Nuke学习笔记4_回调函数/回调函数1.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记4_回调函数/回调函数1.png" class="lozad post-image"></td><td><img src="/images/Nuke学习笔记4_回调函数/回调函数2.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记4_回调函数/回调函数2.png" class="lozad post-image"></td></tr></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nuke学习笔记</summary>
    
    
    
    <category term="Nuke" scheme="http://mirrorcg.github.io/categories/Nuke/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Nuke/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Nuke学习笔记3_菜单的加载和界面</title>
    <link href="http://mirrorcg.github.io/posts/20220801a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220801a1.html</id>
    <published>2022-07-31T16:19:20.000Z</published>
    <updated>2022-07-31T16:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h3 id="Nuke-API-文档"><a href="#Nuke-API-文档" class="headerlink" title="Nuke API 文档"></a>Nuke API 文档</h3><ul><li>本地文档：C:\Program Files\Nuke12.2v2\Documentation</li><li>在线文档：<a href="https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html">https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html</a><ul><li>Nuke Python Developers Guide: 案例教程</li><li>Python Scripting Reference： API 参考文档</li><li>TCL Scripting Reference: TCL 表达式参考文档</li></ul></li></ul><h3 id="工具加载"><a href="#工具加载" class="headerlink" title="工具加载"></a>工具加载</h3><p>开启 nuke 时，系统会加载两个安装目录的Plugins文件夹下的两个文件：</p><ul><li>init.py : 用于Nuke的环境设置、系统选项和默认参数，不能包含任何界面相关操作，命令行模式和GUI模式下均加载。</li><li>menu.py ：用于跟界面相关的设置、自定义菜单、工具架，仅GUI模式加载。<br>位于用户文件夹下存放用户预设的.nuke文件夹，其下的init.py和menu.py用于存放用户预设。</li></ul><p>加载工具方式</p><ul><li>加载工具不运行：仅需要在init.py导入模块的主函数即可，再通过工具界面去调用主函数</li></ul><h3 id="加载工具相关函数"><a href="#加载工具相关函数" class="headerlink" title="加载工具相关函数"></a>加载工具相关函数</h3><ul><li>获取插件和图标的搜索路径 nuke.pluginPath()</li><li>向系统搜索路径添加路径到开头,并加载路径下的init.py nuke.pluginAddPath(“pathstr or pathList”)</li><li>向系统搜索路径添加路径到结尾,但不加载路径下的init.py nuke.pluginAppendPath(“pathstr or pathList”)</li><li>检测指定的函数或插件是否存在 nuke.pluginExists(“pluginName or path or fileName”)</li><li>返回所有已经加载的插件的文件路径列表 nuke.pligins(num,”re表达式过滤”，”re表达式过滤”，…)  num为 0，1，2，3</li></ul><h3 id="Nuke环境变量"><a href="#Nuke环境变量" class="headerlink" title="Nuke环境变量"></a>Nuke环境变量</h3><p>NUKE_PATH、OFX_PLUGIN_PATH都是列表后面的路径先加载，以反向解析加载路径的方式进行的，因此涉及继承和覆盖的通用配置需要放在列表后面，特殊和本地的配置放在列表开头。nuke.pluginPath是正向解析加载方式。</p><ul><li>NUKE_PATH 搜索 Nuke 的init.py 和menu.py文件的路径，可以将插件放在不同的位置，并且每一个插件都有各自的init.py和menu.py文件，就不用将所有插件都写入 .nuke 文件夹下的文件中，实现分布式管理</li><li>OFX_PLUGIN_PATH 用来设置和加载ofx插件的位置，指向ofx的安装路径</li></ul><h3 id="自定义菜单常用类型"><a href="#自定义菜单常用类型" class="headerlink" title="自定义菜单常用类型"></a>自定义菜单常用类型</h3><p>Nuke的菜单界面和Qt是两套体系,Nuke 界面不属于Qt范畴</p><ul><li>菜单栏工具<ul><li>nuke.menu(“Nuke”)</li></ul></li><li>工具栏工具<ul><li>nuke.menu(“Nodes”)</li></ul></li><li>NodeGraph中右键工具<ul><li>nuke.menu(“Node Graph”)</li></ul></li></ul><h3 id="自定义菜单函数"><a href="#自定义菜单函数" class="headerlink" title="自定义菜单函数"></a>自定义菜单函数</h3><ul><li><p>nuke.Menu 菜单类型</p><ul><li>nuke.menu(“Nuke”).findItem(“菜单项名称”) 查找指定菜单项 <ul><li>菜单项名称可以是相对于顶级菜单项的名称 nuke.menu(“Nuke”).findItem(“菜单项1&#x2F;菜单项2&#x2F;菜单项3”)</li></ul></li><li>nuke.menu(“Nuke”).menu(“菜单项名称”) 查找指定菜单项</li><li>nuke.Menu.items() 返回查询到的菜单项</li><li>nuke.menu(“Nuke”).addMenu(“新加项”，icon&#x3D;””,tooltip&#x3D;””,index&#x3D;””) 创建新菜单，其中新加项也是相对路径，index添加位置，默认为-1，只对要添加的最后一级菜单项有效  </li><li>nuke.menu(“Nuke”).addcommand(“新加项”,”脚本字符串”，“快捷键”，”icon”,”tooltip”，”index”) 添加菜单项命令，其中 “脚本字符串”可以为可执行的Python语句，或lambda函数，若没有指定命令，则会默认为创建一个名为新加项的节点。</li><li>nuke.menu(“Nuke”).removeItem(“删除项”) 删除指定的菜单，其中删除项不为相对路径，要删除指定项，需要从指定级的上一级删除，空菜单会自动删除</li><li>nuke.menu(“Nuke”).clearMenu() 删除菜单下的所有菜单项，也不支持相对路径，不会删除当前空菜单</li></ul></li><li><p>nuke.MenuItem 创建菜单项类</p><ul><li>nuke.menu(“Nuke”).findItem(“菜单项”).action() 获取QAction对象,其父对象是QMainWindow</li><li>nuke.menu(“Nuke”).findItem(“菜单项”).invoke() 直接执行menuItem，等同于nuke.menu(“Nuke”).findItem(“菜单项”).action().trigger()</li><li>nuke.menu(“Nuke”).findItem(“菜单项”).script() 返回对应的字符串，如果是lambda函数，其返回值是空</li><li>nuke.menu(“Nuke”).findItem(“菜单项”).setScript() 重新设置字符串</li></ul></li><li><p>nuke.menu(“菜单名”) 获取指定的根菜单，以下列出部分菜单名</p><ul><li>Nuke 菜单栏</li><li>Nodes 工具栏</li><li>Node Graph NodeGraph中的右键菜单</li><li>Viewer Viewer菜单</li><li>Properties 节点属性对话框中的右键菜单</li><li>Animation 动画控件和曲线编辑器右键菜单</li><li>Pane 界面中面板布局右键菜单</li><li>Axis 坐标右键菜单</li></ul></li></ul><h3 id="获取当前软件QT对象"><a href="#获取当前软件QT对象" class="headerlink" title="获取当前软件QT对象"></a>获取当前软件QT对象</h3><pre class="line-numbers language-pyhton" data-language="pyhton"><code class="language-pyhton">from Pyside2 import QtWidgetsallWin &#x3D; [w for w in QtWidgets.QApplication.instance().topLevelWidgets() if w.windowTitle() &#x3D;&#x3D; &quot;窗口提示&quot;]allMenu &#x3D; [w for w in allWin[0]children() if isinstance(w,QtWidgets.QMenuBar)]menubar &#x3D; allMenu[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nuke学习笔记</summary>
    
    
    
    <category term="Nuke" scheme="http://mirrorcg.github.io/categories/Nuke/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Nuke/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Nuke学习笔记2_节点与Knob</title>
    <link href="http://mirrorcg.github.io/posts/20220731a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220731a1.html</id>
    <published>2022-07-31T07:23:52.000Z</published>
    <updated>2022-07-31T16:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h3 id="Nuke-API-文档"><a href="#Nuke-API-文档" class="headerlink" title="Nuke API 文档"></a>Nuke API 文档</h3><ul><li>本地文档：C:\Program Files\Nuke12.2v2\Documentation</li><li>在线文档：<a href="https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html">https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html</a><ul><li>Nuke Python Developers Guide: 案例教程</li><li>Python Scripting Reference： API 参考文档</li><li>TCL Scripting Reference: TCL 表达式参考文档</li></ul></li></ul><h3 id="节点创建和删除"><a href="#节点创建和删除" class="headerlink" title="节点创建和删除"></a>节点创建和删除</h3><p>nuke节点的有可能有不同的版本，比如”Text”和”Text2”、 “Merge”和”Merge2”、”Tracher”和”Tracher3”以及”Tracher4”，默认情况下使用的是新版。右键 &gt; Other &gt; All Plugin &gt; Update，这个操作会扫面并加载所有可用的节点。bezier节点不能被扫描出来，可使用Roto代替,若一定要使用，可使用代码创建或使用 Comp Script Command（TCL） 快捷键（X）创建想要的节点。节点参数的键可以在Nuke中将鼠标悬停在参数选项上，显示的提示框的第一句就是参数的名称，参数的值可复制节点到文本编辑器中查询，有时参数可能设置不上，是Nuke的一些bug,需要寻找别的手段设置。前台模式适合在Gui模式下交互，并且创建的节点会默认连接到当前选择的节点下，若没有选中节点，则创建在鼠标最后一次点击的位置；后台模式更适合后台运行脚本，创建的节点的位置随机。</p><ul><li>创建节点：<ul><li>前台模式：nuke.createNode(“节点类型”) </li><li>后台模式：nuke.nodes.Read()</li></ul></li><li>创建节点时不弹出参数设置对话框：nuke.createNode(“节点类型”，inpanel&#x3D;False)</li><li>创建节点时设置参数：<ul><li>前台模式：nuke.createNode(“Text2”,”message ‘test’ yjustify center”)</li><li>后台模式：nuke.nodes.Read(message&#x3D;’test’, yjustify&#x3D;center)</li></ul></li><li>获取选中节点类型名：<ul><li>nuke.getNodeClassName()(选中状态的节点)</li><li>node &#x3D; createNode(“Text2”);node.Class()</li></ul></li><li>获取节点名：node.name()</li><li>删除节点：<ul><li>前台模式：nuke.delete(node)</li><li>后台模式：nuke.nodeDelete()(选中状态的节点)</li></ul></li></ul><h3 id="选择和链接节点"><a href="#选择和链接节点" class="headerlink" title="选择和链接节点"></a>选择和链接节点</h3><ul><li>获取节点：nuke.toNode(“节点名”)</li><li>获取节点输入：<ul><li>获取所有输入端：nuke.inputs()</li><li>获取指定输入端：nuke.input(端口数字)</li></ul></li><li>链接节点：nuke.setInput(端口数字，nuke.toNode(“节点名”)) </li><li>获取所有节点：nuke.allNodes()</li><li>获取选中节点：<ul><li>仅返回最后一个被选中的节点 nuke.selectedNode() </li><li>返回主节点树中所有选中的节点 nuke.selectedNodes()</li></ul></li><li>选中以获得的节点<ul><li>将节点设置为选中状态 node &#x3D; createNode(“Text2”);node.setSelect(是否选中) 也可以传递参数设置选中状态</li><li>将当前节点设置为整个节点树中唯一被选中的状态 node.selectOnly()</li></ul></li><li>选中所有节点 nuke.selectAll()</li><li>选中满足模糊搜索节点名称的节点：nuke.selectPattern() 仅能在GUI模式下使用</li><li>选中与当前选中节点类似的节点：nuke.selectSimilar(“要匹配的类型”)<ul><li>选中有相似的类型 nuke.selectSimilar(nuke.MATCH_CLASS)</li><li>选中有相似的label标签 nuke.selectSimilar(nuke.MATCH_LABEL)</li><li>选中有相似的颜色 nuke.selectSimilar(nuke.MATCH_COLOR)</li></ul></li><li>将选中节点的上下游都设置为选中状态 nuke.selectConnectedNodes()</li><li>判断是否有被选中的节点 nuke.nodesSelected()</li><li>反向选择 nuke.invertSelection()</li><li>将节点从选中的节点中脱离出来 nuke.extractSelected()</li><li>克隆选中的节点 nuke.cloneSelected()</li><li>以递归形式清除节点的选中状态 nukescript.misc.clear_selection_recursive() 包括Gizmo 和 Group 中选中的节点也会被清除选中。</li></ul><h3 id="节点位置和布局"><a href="#节点位置和布局" class="headerlink" title="节点位置和布局"></a>节点位置和布局</h3><p> NodeGraph 的坐标轴方向是X轴向右，Y轴向下；节点的位置指的是节点左上角的位置.<br> 位置相关方法,node &#x3D; createNode(“Text2”)：</p><ul><li>获取位置<ul><li>node.xpos()、node.ypos()</li><li>node[“xpos”].value、node[“ypos”].value</li></ul></li><li>设置位置<ul><li>node.setXpos(“value”)、node.setYpos(“value”)、node.setXYpos(“value1”,”value2”)</li><li>node[“xpos”].setValue(“value”)、node[“ypos”].setValue(“value”)</li></ul></li><li>获取节点长宽<ul><li>node.screenWidth()、node.screenHeight()</li></ul></li><li>自动布局到选中节点的下方 node.autoplace()</li><li>NodeGraph 缩放比 <ul><li>查询缩放比 nuke.zoom()</li><li>设置缩放比 nuke.zoom(倍数，[焦距的位置X,焦距的位置Y])</li><li>聚焦到指定节点 nuke.zoom(倍数，[node.xpos(),node.ypos()])</li></ul></li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>打开新Nuke工程 nuke.scriptNew() ctrl+N</li><li>打开指定Nuke工程 nuke.scriptOpen(“存在的Nuke工程路径”) </li><li>将已有的Nuke工程导入到当前的Nuke工程中<ul><li>nuke.scriptSource()</li><li>nuke.scriptRendFile()</li></ul></li><li>清空当前NodeGraph:<ul><li>直接放弃修改，无返回值 nuke.scriptClear()</li><li>提示是否保存更改，有返回值 nuke.scriptClose()</li></ul></li><li>退出Nuke nuke.scriptExit()</li><li>获取当前文件名称 <ul><li>nuke.scriptName()</li><li>nuke.Root().name()</li><li>nuke.Root()[“name”].value()</li><li>nuke.Root().knob(“name”).value()</li></ul></li><li>从节点中进入节点树环境.使用上下文管理器with ‘with nuke.Root()’</li><li>返回当前工程所在的文件夹的路径<ul><li>nuke.utils.script_directory()</li><li>nukescripts.script_directory()（该方法调用上面的方法）</li></ul></li><li>复制和粘贴<ul><li>从字符串创建一个节点 nuke.scriptReadText(“表示节点的字符串，超麻烦”)</li><li>将选中的节点暂存到文本名或粘贴板名的文件中 nuke.nodeCopy(“文件路径或临时起名的粘贴板中”)</li><li>将粘贴板中的内容粘贴到nuke中 nuke.nodePaste(“文件路径或临时起名的粘贴板中”)  # %clipboard% 可表示系统粘贴板</li></ul></li><li>保存工程 <ul><li>直接保存 nuke.scriptSave()</li><li>另存为 nuke.scriptSaveAs(“文件名”)</li><li>另存时不修改Root节点中的路径 nuke.scriptSaveToTemp(“文件名”)</li><li>保存文件后清空nuke工程 nuke.scriptSaveAndClear()</li></ul></li></ul><h3 id="Nuke中的控件（Knob）"><a href="#Nuke中的控件（Knob）" class="headerlink" title="Nuke中的控件（Knob）"></a>Nuke中的控件（Knob）</h3><p>Nuke中的文本框、下拉菜单、复选框、滑块等基本控件，以及色彩设置<br>图片尺寸、坐标值等 专属控件都称为Knob。<br>node &#x3D; nuke.toNode(“Read”)</p><ul><li>获取所有的控件 <ul><li>node.allKnobs() 所有控件列表</li><li>node.knobs() 所有控件字典</li></ul></li><li>获取特定的控件对象 <ul><li>根据控件名获取<ul><li>node.knob(“控件名”) 没找到指定对象返回None</li><li>node[“控件名”] 没找到指定对象会报错</li><li>node.knobs().get(“控件名”) 根据控件名获取控件对象</li></ul></li><li>根据序号获取<ul><li>node.numKnobs() 返回当前节点中所有控件的总数量</li><li>node.knob(控件序号)</li></ul></li></ul></li><li>获取当前用户操作的控件 nuke.thisNode() </li><li>控件状态 <ul><li>node.knob(“控件名”).enable() 是否启用</li><li>node.knob(“控件名”).enable()setEnable() 设置启用状态</li><li>node.knob(“控件名”).enable()visible() 是否可见</li><li>node.knob(“控件名”).enable()setVisible() 设置可见状态</li></ul></li><li>返回标签名、控件名、提示信息 label()、name()、tooltip()</li><li>设置标签名、控件名、提示信息 setLabel()、setName()、setTooltip()</li><li>获取控件值<ul><li>value() 控件会根据需要进行继承和修改函数</li><li>getValue(oc) 获取特定帧或特定视图下的值</li><li>getValueAt()</li><li>defaultValue() 获取默认值</li></ul></li><li>设置控件的值  <ul><li>setValue(value,view&#x3D;”default”) 控件会根据需要进行继承和修改函数</li><li>setValueAt()</li><li>setDafaultValue() 设置控件的默认值</li><li>nuke.knobDefault(“节点名.控件名”，”参数”) 对节点的参数设置全局默认值</li></ul></li><li>控件值是否不为默认值 notDefault()</li></ul><p>format_knob 参数默认值来源于Root节点的format值</p><ul><li>获取值 node.knob(“format控件名”).value() </li><li>设置值 node.knob(“format控件名”).setValue()</li><li>新建默认format值 nuke.addFormat(“新建format值”) 新建format值为TCL表达式，其至少要包含 宽度，高度，格式名三项，每项用空格分隔，名称不能用数字开头</li></ul><p>TCL表达式相关函数：</p><ul><li>node.knob(“format控件名”).fromScript(“tcl表达式”) 接受tcl表达式并赋值给对象</li><li>node.knob(“format控件名”).toScript(bool,time) 将值输出为TCL表达式 bool为Ture，结果两侧加大括号，反之不加，time为具体帧，则仅设置该帧，若为None，则设置所有帧</li><li>node.knob(“format控件名”).readKnobs(“tcl表达式”) 使用tcl表达式为一个或多个节点控件赋值</li><li>node.knob(“format控件名”).writeKnobs(value) 将控件值以tcl表达式方式输出,value需要根据常量获取，详情见文档</li></ul><h3 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h3><p>UI交互式创建</p><table><tr><td><img src="/images/Nuke学习笔记2_节点与Knob/编辑控件.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记2_节点与Knob/编辑控件.png" class="lozad post-image"></td><td><img src="/images/Nuke学习笔记2_节点与Knob/创建控件.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记2_节点与Knob/创建控件.png" class="lozad post-image"></td></tr></table><p>代码创建<br>可使用NoOp节点进行自定义<br>node &#x3D; nuke.toNode(“Read”)</p><ul><li>添加控件 node.addKnob(控件对象)</li><li>移除控件 node.removeKnob(控件对象)</li><li>pythonScript中获取当前节点 nuke.thisNode()</li></ul><h3 id="Gizmo操作"><a href="#Gizmo操作" class="headerlink" title="Gizmo操作"></a>Gizmo操作</h3><p>将具有特定功能的节点组打包成一个节点，可用于别的nuke工程</p><ul><li>查询节点全路径 nuke.thisNode().fullName()</li><li>查询组内的节点 <ul><li>nuke.node(“组名”).node(“内部节点名”)[“knob名”].value()</li><li>nuke.node(“组名.组内节点名”)[“knob名”].value()</li></ul></li><li>在组织间进行代码操作<ul><li>node.begin() 代码开始</li><li>node.end() 代码结束</li></ul></li><li>转换正确导入的Gizmo为Group nuke.toNode(“Group”).makeGroup()</li></ul><h4 id="导入-导出gizmo"><a href="#导入-导出gizmo" class="headerlink" title="导入\导出gizmo"></a>导入\导出gizmo</h4><p>在组节点或者Gizmo节点下面，点击Node &gt; Export gizmo\Copr as Group<br>不能直接import Gizmo 节点使用，这样导入的节点是不完整的，只能使用nuke标准环境加载的方式进行应用。或将gizmo文件以文本的方式打开，将其中的Gizmo 替换为Group,这样也可以正确导入节点组。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nuke学习笔记</summary>
    
    
    
    <category term="Nuke" scheme="http://mirrorcg.github.io/categories/Nuke/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Nuke/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Nuke学习笔记1_环境与命令行</title>
    <link href="http://mirrorcg.github.io/posts/20220730a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220730a1.html</id>
    <published>2022-07-30T13:47:04.000Z</published>
    <updated>2022-07-31T07:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h4 id="Nuke-脚本编辑窗口相关快捷键和操作"><a href="#Nuke-脚本编辑窗口相关快捷键和操作" class="headerlink" title="Nuke 脚本编辑窗口相关快捷键和操作"></a>Nuke 脚本编辑窗口相关快捷键和操作</h4><p>tab键   自动代码补全    输入部分脚本后，可获取相关的方法</p><p style="text-indent:2em">Edit > Preferences > ScriptEditor > echo python commands to output window 将输出常用操作的 Nuke Python API 代码显示在代码执行结果显示区。</p><p><img src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9CPython%E4%BB%A3%E7%A0%81%E5%88%B0%E8%84%9A%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="输出操作Python代码到脚本编辑器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9CPython%E4%BB%A3%E7%A0%81%E5%88%B0%E8%84%9A%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8.png" class="lozad post-image"> </p><h4 id="搭建-Pycharm-IDE-开发环境"><a href="#搭建-Pycharm-IDE-开发环境" class="headerlink" title="搭建 Pycharm IDE 开发环境"></a>搭建 Pycharm IDE 开发环境</h4><p style="text-indent:2em">在 Pycharm 中新建一个项目，用于开发Nuke插件,必须使用Nuke本身的Python编译器 "C:\Program Files\Nuke版本\python.exe"，该python编译器拥有完整的Nuke开发环境。</p><p style="text-indent:2em">关于 nukescripts 模块的使用，需要将“C:\Program Files\Nuke版本号\plugins”加入搜索路径</p><p style="text-indent:2em">关于 Pyside2 模块的使用，需要将“C:\Program Files\Nuke版本号\pythonextensions\site-packages”加入搜索路径</p><p style="text-indent:2em">配置好上面的环境后执行代码会发现报错：缺少一个“_nuke” 模块。这个模块在这里 "C:\Program Files\Nuke12.2v2\lib\site-packages\nuke.pyd" 中，由于这个文件和上面的 nukescripts 模块同级目录的nuke模块重名，导致不能加载这个nuke.pyd，因此会报这个错，如何解决呢？</p><ul><li>方法一.从搜索路径中去掉 “C:\Program Files\Nuke版本号\plugins”，但nukescripts模块的会缺少代码补全（加载完nuke.pyd后，会自动加载nuke和nukescripts模块，因此在执行代码时不会报这两个模块的错）.</li><li>方法二.在pycharm中将编辑nuke代码的Python解释器和运行nuke代码的python解释器分开，在编写的nuke代码的时候，将项目中python interpreter中设置的python解释器设置为普通的python解释器，可以在其搜索路径中加入我们想要的搜索路径，然后在运行nuke代码的时候，在Run&#x2F;Debug configuration中设置的python解释器设置为带有nuke环境的python解释器即可。</li></ul><p>  <img src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%88%87%E6%8D%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84Python%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt="切换执行时的Python解释器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%88%87%E6%8D%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84Python%E8%A7%A3%E9%87%8A%E5%99%A8.png" class="lozad post-image"> </p><p style="text-indent:2em">此环境可能无法正常运行Pyside2相关的代码，需要在nuke中执行(详情见下一节)。</p><p><img src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/Pycharm%E4%B8%AD%E4%BD%BF%E7%94%A8Pyside2%E6%8A%A5%E9%94%99.png" alt="Pycharm中使用Pyside2报错 png" srcset="/images/home/Myhead.jpg" data-src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/Pycharm%E4%B8%AD%E4%BD%BF%E7%94%A8Pyside2%E6%8A%A5%E9%94%99.png" class="lozad post-image">  </p><h4 id="Nuke-命令行模式"><a href="#Nuke-命令行模式" class="headerlink" title="Nuke 命令行模式"></a>Nuke 命令行模式</h4><pre class="language-dos" data-language="dos"><code class="language-dos">&quot;C:\Program Files\Nuke12.2v2\python.exe&quot; &quot;D:\test.py&quot;</code></pre><p>运行脚本需使用Nuke的Python解释器，若后台调用脚本，可使用subprocess方法切换至Nuke本身的Python解释器。</p><p>若要使用 Pyside2 模块，需要在通过nuke主程序 nuke.exe 使用参数 -t 就可以运行Pyside2模块。</p><pre class="language-dos" data-language="dos"><code class="language-dos">&quot;C:\Program Files\Nuke12.2v2\nuke.exe&quot; -t &quot;D:\test.py&quot;</code></pre><p>但 -t 参数不能获取到 QApplication 类，只能获取到 QCoreApplication 类（QApplication是QCoreApplication的子类），所以要通过 --tg 参数来获取 Pyside2 模块创建窗口所需要的 QApplication 类。</p><pre class="language-dos" data-language="dos"><code class="language-dos">&quot;C:\Program Files\Nuke12.2v2\nuke.exe&quot; --tg &quot;D:\test.py&quot;</code></pre><p>nuke命令行语法：</p><p style="text-indent:4em">nuke.exe <\option> [<\argv>] <\script> [<\range>]</p>使用不同类别的主程序常用参数:<ul><li>--nukex</li><li>--studio</li><li>--nc</li><li>--nukeassist</li></ul><p>可以在Windows环境下使用doskey创建快捷键(只在当前窗口有效)，可以使用PATH环境变量，并写在一个bat脚本中：</p><pre class="language-dos" data-language="dos"><code class="language-dos">doskey nukex &#x3D; &quot;C:\Program Files\Nuke12.2v2\nuke.exe&quot; --nukex $*</code></pre><p>效果等于：<br>“C:\Program Files\Nuke12.2v2\nuke.exe” -- nukex &lt;\option&gt; [&lt;\argv&gt;] &lt;\script&gt; [&lt;\range&gt;] &#x3D; nukex &lt;\option&gt; [&lt;\argv&gt;] &lt;\script&gt; [&lt;\range&gt;]</p><p>一些常用的参数：</p><ul><li>-t 适用于纯命令行脚本</li><li>–tg 会产生一个 QApplication 实例，用于执行 Pyside2 的Gui相关脚本</li><li>-x &lt;\scriptname&gt; 渲染名为 \scriptname 的nuke工程中所有激活的write节点</li><li>-X&lt;\nodename&gt; 仅渲染指定名的\nodename的write节点</li><li>-F 指定帧范围</li><li>–cont 出错后继续渲染</li><li>–sro 按顺序依次渲染节点</li><li>-f 以全尺（full resolution）的方式打开nuk工程</li><li>-p 和-f相对，以 proxy 的方式打开nuke工程</li><li>-v 打开指定的图像文件，如果是视频，还需要跟上帧范围（文件路径使用正斜杠，不能使用反斜杠）</li><li>–pause 打开nuke工程时暂停 Viewer 初始化</li><li>-P 显示每个节点的资源占用情况</li><li>-Pf&lt;\filename&gt; 将每个节点的资源占用情况写入名为 \filename 的xml文件中</li><li>–multigpu 启用多gpu支持</li><li>–gpulist 列出当前系统可用的GPU及其索引号</li><li>–gpu ARG 使用由索引号ARG指定的GPU,在终端模式下启动GPU加速</li><li>–safe 安全模式，启动nuke不加载 .nuke、NUKE_PATH及OFX插件</li><li>-m # 指定线程数</li><li>-n 关闭节点postage stamps的预览显示</li><li>-q 关闭终端输出</li><li>-i 使用nuke_i授权，可与 -x 和 -t 连用，写成 -ti 或 -xi,默认情况下使用nuke_r授权，但有些操作需要使用nuke_i授权。</li><li>–remap&lt;\pathPair&gt; 仅能在命令行模式下使用，在当前会话中设置路径映射，要求参数为一对或多对路径拼成的字符串，用逗号分隔</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nuke学习笔记</summary>
    
    
    
    <category term="Nuke" scheme="http://mirrorcg.github.io/categories/Nuke/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Nuke/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Maya中Xgen毛发渲染问题</title>
    <link href="http://mirrorcg.github.io/posts/20220729a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220729a1.html</id>
    <published>2022-07-29T15:16:15.000Z</published>
    <updated>2022-07-29T15:16:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了一些Maya中Xgen毛发渲染的相关的问题：<span id="more"></span></p><ol><li><p>Xgen 角色ABC和毛发ABC的运动模糊不匹配的问题（小概率事件）：</p><p style="text-indent:2em">原因是生长面缓存只有整数帧采样并且在渲染运动模糊时，Xgen没有计算生长面的插值,或者由于前后帧的运动差异过大，Xgen计算出错误的生长面插值，导致毛发生长面的缓存和角色缓存的插值不匹配，生长面缓存和角色缓存在小数帧位置不同，就会导致运动模糊不同。也可以通过实际文件观测到，在运动模糊有问题的小数帧，毛发不加载缓存时，其毛发引导线跟随动画缓存，加载了毛发缓存后，毛发缓存曲线和动画缓存的位置一致，而毛发引导线却和缓存曲线不在相同的位置，毛发引导线和动画缓存脱离，但是毛发引导线的形态和毛发缓存一致，说明毛发引导线只是从毛发缓存继承了形态，并不继承其位置。而毛发引导线的位置是从毛发生长面继承的，此时毛发引导线的位置和动画缓存不一致，那么小数帧时生长面的缓存和动画缓存位置不一致，因此，毛发生长面缓存在计算小数帧时有问题。解决此类问题，最好为动画缓存、曲线缓存、生长面缓存都添加缓存的小数帧采样插值。</p></li><li><p>前台批渲染带渲染运动模糊时，代码批量刷新生长面时报错‘not match object “XGEN_RENDER_:XXXX”’：</p><p style="text-indent:2em">Xgen毛发在渲染运动模糊后，会生成可通过xgen.palettes()获取，但是无法使用cmds.sl("")列出，也无法删除的临时生长面，该生长面以“XG_RENDR_:”为前缀，若要在渲染运动模糊后批量处理生长面，需要跳过它，不会有任何影响。该临时生长面不会记录到maya文件中，但是会存在当前软件中，哪怕你清除场景，并重开另一个场景，也可以查询到它，处理时直接跳过无影响。</p></li></ol><h4 id="一些Xgen文件测试记录"><a href="#一些Xgen文件测试记录" class="headerlink" title="一些Xgen文件测试记录"></a>一些Xgen文件测试记录</h4><ol><li><p>使用不同名称、完全相同的两个集合体作为Xgen描述的生长面，其基本体随机种子数会有一些差异，随机种子数是根据物体的生长面名称进行hash计算得出的结果，若替换生长面对应的几何体名称，随机种子数会发生细微变化，从而导致效果会有细微差别。</p></li><li><p>xgen文件中只记录几何体的短名，不记录长名(可以手动修改的方式使用maya规范的长名，)，测试结果是只识别几何体短名称，不区分拓扑结构和形状以及uv，只使用.xgen文件中记录的的faceid面数，但拓扑结构不同结果肯定不一样，几何体名和生长面前缀应保持一致。</p></li><li><p>绘制的iff贴图在保存文件后才会写入工程目录的文件夹，描述下有几个生长面就保存几张贴图(从新的几何体添加新的生长面，需要重新绘制贴图，保存后也会对应新增一张贴图)，根据绘制贴图时的生长面_集合_描述名称，xgen中指定的贴图名称命名为：polySurfaceShape1_grass_col_grass_decmask_generator_grass)。</p></li><li><p>生长面跟随几何体放大缩小，但是毛发粗细不变(可写入表达式，待测试)。</p></li><li><p>确定了几何体、绑定几何体并生成生长面之后，不可以修改几何体的名称，指向文件(ptx，xuv等文件)记录的是以几何体命名的贴图名称，更改几何体命名称后，链接断开，指向文件失效。</p></li><li><p>使用相同几何体生成的不同描述，其生长面的名称为“几何体名称_描述名称”，不会重名</p></li><li><p>单个XGen文件的生长面、几何体可以改名;改完命名后直接更改其Xgen文件的几何体名称，另存文件即可;</p></li><li><p>使用几个几何体生成描述，集合下就拥有几个生长面(不建议使用多个几何体映射一个描述，最好先合并成一个几何体，方便管理)</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录了一些Maya中Xgen毛发渲染的相关的问题：</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="Xgen" scheme="http://mirrorcg.github.io/tags/Xgen/"/>
    
  </entry>
  
  <entry>
    <title>Deadline中调试编写的事件</title>
    <link href="http://mirrorcg.github.io/posts/20220721a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220721a1.html</id>
    <published>2022-07-21T15:55:44.000Z</published>
    <updated>2022-07-21T17:09:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h4><p style="text-indent:2em">Deadline 事件依赖于其软件框架，不能进行实时调试，但是可以通过 Console 窗口快速获取获取事件反馈信息。</p><span id="more"></span><p style="text-indent:2em">若想快速查看事件处理的过程，获取结果，首先通过Panels > Console 开启 Console 窗口。</p><p><img src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/Console.jpg" alt="Console图片" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/Console.jpg" class="lozad post-image"></p><p style="text-indent:2em">对于事件编写，除了要先配置正确的事件文件以外，还要在代码中加入打印（可通过 DeadlineEventListener 类的 self.LogInfo 或者 print 等方法将调试信息写入代码中，或通过ClientUtils.LogText(str)方法将信息写入 Deadline 的日志文件中），由于 Deadline 会每隔一段时间才会扫描储存库，扫描的默认值一般为5分钟，当扫描过程中发现事件脚本有新的修改时，才会将修改的事件脚本重新构建到任务中，所以，为了让 Deadline 后台及时更新并构建我们修改的事件脚本，我们需要通过Tools > Synchronize Monitor Script and Plugins 功能手动更新事件脚本。</p><p><img src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC.jpg" alt="同步脚本" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC.jpg" class="lozad post-image"></p><p style="text-indent:2em">此时，Console 窗口会提示：***事件脚本有修改，将重新构建事件脚本的提示语。如果你的脚本有语法错误，Console 窗口还会给你打印一条简短的报错信息。然后 Requeue 目标任务，再将任务切换到我们所要的任务状态（先更新脚本，再操作任务，不能先操作任务再更新脚本，否则，事件不会被更新到任务状态中），Deadline 便会通过当前执行任务的机器执行事件脚本，并在Console 窗口显示反馈信息。通过此方法，可以快速对我们的事件脚本进行编写和调试。</p><h4 id="关于事件脚本中使用中文"><a href="#关于事件脚本中使用中文" class="headerlink" title="关于事件脚本中使用中文"></a>关于事件脚本中使用中文</h4><p style="text-indent:2em">有时会想在日志中打印中文信息，则我们需要将中文字符串解码为"utf8"的人类可读懂的代码。需要注意的是：</p><ul><li>了解事件脚本文件在储存时，使用的编码格式，以及系统文件流的编码格式。不仅如此，我们还会在 python 脚本文件中加入 “# -<em>- coding:utf-8 -</em>-” 类型的注释，因此需要做相应的修改。</li><li>中文字符很容易出错，导致插件执行被打断却没有任何反馈信息的假成功状态，这是由于当Deadline后台检测脚本有字符转换的错误时，它可不执行事件脚本。</li></ul><pre class="language-python" data-language="python"><code class="language-python">self.LogInfo(&quot;测试打印&quot;.decode(&quot;utf8&quot;))</code></pre><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/2_Scripting%20Reference/index.html" title="" target="">官方文档中事件脚本文档</a></br><a href="http://www.mirrorcg.com/posts/20220306a1.html" title="" target="">往期相关文章：Deadline中的事件示例</a>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;详情&quot;&gt;&lt;a href=&quot;#详情&quot; class=&quot;headerlink&quot; title=&quot;详情&quot;&gt;&lt;/a&gt;详情&lt;/h4&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;Deadline 事件依赖于其软件框架，不能进行实时调试，但是可以通过 Console 窗口快速获取获取事件反馈信息。&lt;/p&gt;</summary>
    
    
    
    <category term="Deadline" scheme="http://mirrorcg.github.io/categories/Deadline/"/>
    
    <category term="插件" scheme="http://mirrorcg.github.io/categories/Deadline/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="插件" scheme="http://mirrorcg.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>CG流程中的ACES概念解释</title>
    <link href="http://mirrorcg.github.io/posts/20220706a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220706a1.html</id>
    <published>2022-07-06T15:18:49.000Z</published>
    <updated>2022-07-06T15:18:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="ACES-一些散记"><a href="#ACES-一些散记" class="headerlink" title="ACES 一些散记"></a>ACES 一些散记</h4><p>  经过IDT转换的图片只能保证其在AECS色域中渲染的颜色信息和ACES相比较是正确的，不能保证渲染的效果和SRGB的原效果一致。<br>  线性图和非线性图的区别在于是否经过Gamma1.8到gamma2.2的曲线矫正,矫正的目的是为了迎合人眼观察的同时，方便使用8位图存储色彩信息。浮点图没有色彩存储空间不够的情况，因此浮点图一般是线性图。<br>  ACES推荐使用EXR、TIF、HDR等浮点图存储信息，最少使用16位(exr是HDR标准的图片格式，拥有多通道存储的能力，使用1位、5位、10位分段分别存储不同的信息)。<br>  CG流程中ODT用于ACES到SRGB色域的转换，通常是使用‘output_srgb’类型。<br>  Maya中输出的16位ACES图和32位图色彩信息有些许肉眼可见的不同。请自行测试。</p><h4 id="一些文章参考"><a href="#一些文章参考" class="headerlink" title="一些文章参考"></a>一些文章参考</h4><br><p style="text-indent:2em">国内网页：</p><a href="https://www.bilibili.com/video/BV1jM4y1N7yT?spm_id_from=444.41.top_right_bar_window_default_collection.content.click&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">ACES编码及色彩原理（CG）</a><br><a href="https://www.bilibili.com/video/BV1Fg411M7H6?p=1&share_medium=android&share_plat=android&share_session_id=665fc73f-fd8b-484a-9cb2-7bf453d6035e&share_source=WEIXIN&share_tag=s_i&timestamp=1656295742&unique_k=SDBzFDb&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">ACES通俗讲解</a><br><a href="https://www.bilibili.com/read/cv9842761" title="" target="">色彩原理</a><br><a href="https://www.bilibili.com/video/BV1dV411i7M1?spm_id_from=333.788.top_right_bar_window_default_collection.content.click&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">Nuke色彩空间（Gamma）的转换和原理</a><br><a href="https://www.shangyexinzhi.com/article/1960438.html" title="" target="">参考文章1</a><br><a href="https://www.toadstorm.com/blog/?p=694" title="" target="">参考文章2</a><br><a href="https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/" title="" target="">参考文章3</a><br><br><p style="text-indent:2em">以下需科学上网：</p><a href="https://www.youtube.com/watch?v=W9Z1Std_1Kc" title="" target="">ACES Workflow in Maya with Redshift and Arnold</a>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Doc/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="灯光合成" scheme="http://mirrorcg.github.io/tags/%E7%81%AF%E5%85%89%E5%90%88%E6%88%90/"/>
    
    <category term="ACES" scheme="http://mirrorcg.github.io/tags/ACES/"/>
    
  </entry>
  
  <entry>
    <title>Maya中常用的部分环境变量</title>
    <link href="http://mirrorcg.github.io/posts/20220521a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220521a1.html</id>
    <published>2022-05-21T13:33:36.000Z</published>
    <updated>2022-07-25T14:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录 maya 中常用的部分环境变量。<span id="more"></span></p><ul><li>MAYA_ENABLE_LEGACY_RENDER_LAYERS      开启旧版灯光渲染分层系统（maya2017以后可使用）</li></ul><p>屏蔽 maya 连接网络</p><ul><li>MAYA_DISABLE_CIP &#x3D; 1</li><li>MAYA_DISABLE_CLIC_IPM &#x3D; 1</li><li>MAYA_DISABLE_CER &#x3D; 1</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录 maya 中常用的部分环境变量。</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
    <category term="环境变量" scheme="http://mirrorcg.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows任务计划</title>
    <link href="http://mirrorcg.github.io/posts/20220510a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220510a1.html</id>
    <published>2022-05-10T04:51:16.000Z</published>
    <updated>2022-05-10T05:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>工作中有时需要定时执行一些规律性的脚本操作<span id="more"></span>，比如，清除磁盘垃圾、定时下载任务等。这些任务执行虽然简单，但是需要人力进行日常维护。通常有两种方式可以方便处理这类型任务：</p><ol><li>以本机作为脚本任务的执行者，开启电脑后，通过ide运行任务，但是每次开机都需要手动执行，或者将程序打包成exe程序再放入启动文件夹。</li><li>以本机作为服务器，通过任务计划的触发器，自动执行指定任务，不需要每次开机后再手动执行。</li></ol><p>下面将介绍第二种方式——任务计划</p><ul><li><p>打开计划任务程序</p><table><tr><td><img src="/images/Windows任务计划/打开管理工具.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Windows任务计划/打开管理工具.png" class="lozad post-image"></td><td><img src="/images/Windows任务计划/任务计划程序.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Windows任务计划/任务计划程序.png" class="lozad post-image"></td></tr></table></li><li><p>创建一个新的任务计划文件夹（推荐）或在“任务计划程序库”中创建基本任务:提一下”创建基本任务”和”创建任务”的区别是一个有引导界面，一个直接弹出设置界面直接设置。</p></li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1.png" alt="创建基本任务 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1.png" class="lozad post-image">  </p><ul><li>输入任务名称和描述。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%BE%93%E5%85%A5%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0.png" alt="输入任务名称和描述 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%BE%93%E5%85%A5%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0.png" class="lozad post-image">  </p><ul><li>选择触发器，修改触发器触发的时间和间隔，这里暂时只能创建一个触发器，我们可以创建完任务计划后进行添加或修改触发器。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="选择触发器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E8%A7%A6%E5%8F%91%E5%99%A8.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E4%BF%AE%E6%94%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E9%80%89%E9%A1%B9.png" alt="修改触发器选项 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E4%BF%AE%E6%94%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E9%80%89%E9%A1%B9.png" class="lozad post-image"> </p><ul><li>选择任务操作，并填入相关参数，这里很重要，它可以决定你的任务计划是否正常执行，原则上越简单越好（后面会进行详解）；然后点击完成。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C.png" alt="选择任务操作 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%84%9A%E6%9C%AC.png" alt="设置启动程序的脚本 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%84%9A%E6%9C%AC.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%AE%8C%E6%88%90%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1.png" alt="完成创建任务 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%AE%8C%E6%88%90%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1.png" class="lozad post-image"> </p><ul><li>“创建基本任务”完成后，我们还需要对其进行一些的修改；选择任务点击属性对任务进行修改。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%B8%B8%E8%A7%84%E8%AE%BE%E7%BD%AE.jpg" alt="常规设置 jpg" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%B8%B8%E8%A7%84%E8%AE%BE%E7%BD%AE.jpg" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="触发器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%A7%A6%E5%8F%91%E5%99%A8.png" class="lozad post-image"><br>  “操作”项暂不做修改；”条件”项也比较简单，都是字面意思，这里不做讲解；<br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E8%AE%BE%E7%BD%AE.jpg" alt="设置设置 jpg" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E8%AE%BE%E7%BD%AE.jpg" class="lozad post-image"><br>  note：每次手动运行任务后，若任务状态没有更改成预期状态，可通过右键任务选择“刷新”选项进行任务状态的刷新。</p><ul><li>关于”操作”项中的设置需要注意：由于我们使用的是.bat脚本中通过python程序调用.py脚本，因此这里的”程序或脚本”填入 XXX\test.bat(不加引号)，”添加参数（可选）”为空，“起始于（可选）”则是.py文件所在的目录，而不是执行程序或者.bat脚本所在的目录，否则执行的结果会出错；若不填(缺省状态)，那么自动将该处的目录位置定位到”程序或脚本”的目录位置。并且调用的程序需要传入参数，例如”程序或脚本”填入Python编译器路径 C:\Python27\python.exe ，而”添加参数（可选）”为.py文件，那么“起始于（可选）”则是.py文件所在的目录。最后说一下，任务计划中所用到的所有的文件最好放置在本地路径。</li></ul><h4 id="实践踩坑和解决办法"><a href="#实践踩坑和解决办法" class="headerlink" title="实践踩坑和解决办法"></a>实践踩坑和解决办法</h4><p style="text-indent:2em">在这次工作中由于需要每天调用pythonAPI对程序的服务端进行调整，因此使用了任务计划调用bat脚本的方式执行任务。该bat脚本中，仅简单的一句'XXX/python.exe XXX/XXX/xxx.py'---使用编译器编译python脚本，该任务在我本机上执行没有任务问题，于是将任务计划部署到农场机器上，此时任务就出现了问题：创建的任务不会成功执行，或者执行结果不为'成功执行（0X0）',或者执行结果为'成功执行（0X1）'（失败状态）或者直接失败，找了很久的原因，排除几乎所有的可能性（计算机休眠、计算机系统配置不对、任务权限不够、bat脚本有问题、.py脚本有问题、任务手动运行后状态没有及时切换导致新实例不能创建、不能访问网络盘资源、脚本“起始于（可选）”参数不对、执行程序带引号等等）。最后本着"越简单越好"的原则，直接将bat脚本拆开，将python编译器的位置填入"程序或脚本"，"添加参数（可选）"填入.py脚本，“起始于（可选）”填入.py脚本路径，问题才得到解决。</p><p style="text-indent:2em">猜测和计算机系统有关，由于我本机使用的是Windows10 的操作系统，而农场机使用的是Windows server2012 的操作系统。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>官方介绍：<a href="https://forsenergy.com/zh-cn/gpmc/html/688d2d42-454a-4e2e-90c0-557f959d49b0.htm">https://forsenergy.com/zh-cn/gpmc/html/688d2d42-454a-4e2e-90c0-557f959d49b0.htm</a><br>参考文章：<a href="https://www.jianshu.com/p/c627c77f6ea3">https://www.jianshu.com/p/c627c77f6ea3</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作中有时需要定时执行一些规律性的脚本操作</summary>
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    
    <category term="windows" scheme="http://mirrorcg.github.io/tags/windows/"/>
    
    <category term="排错记录" scheme="http://mirrorcg.github.io/tags/%E6%8E%92%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Deadline如何使用PythonAPI</title>
    <link href="http://mirrorcg.github.io/posts/20220505a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220505a1.html</id>
    <published>2022-05-05T12:46:35.000Z</published>
    <updated>2022-05-05T12:46:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p style="text-indent:2em">本文介绍如何使用 Deadline 的 Python API 操作Deadline。<span id="more"></span>通过 Python API 可在 Python 中与 HTTP API 通信。</p><h4 id="拷贝-PythonAPI-模块"><a href="#拷贝-PythonAPI-模块" class="headerlink" title="拷贝 PythonAPI 模块"></a>拷贝 PythonAPI 模块</h4><p style="text-indent:2em">首先在使用 API 之前，需要配置python环境使我们可以调用到 API。我们需要安装和使用 python2.7.9或 3.7 以上的python版本，然后将 Deadline 储存库路径（//your/repository/api/python）下的整个“Deadline”文件夹复制到Python 安装路径下的的“site-packages”文件夹，API 即可调用。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E6%8B%B7%E8%B4%9DPythonAPI.png" alt="Deadline拷贝PythonAPI" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E6%8B%B7%E8%B4%9DPythonAPI.png" class="lozad post-image"></p><h4 id="开启-WebService-服务"><a href="#开启-WebService-服务" class="headerlink" title="开启 WebService 服务"></a>开启 WebService 服务</h4><p style="text-indent:2em">我们还需要通过 WebService 通信以发送和接收请求，因此，还要在 Deadline 管理的局域网中的任何一台可见的设备上运行 WebService服务，该服务为“C:\Program Files\Thinkbox\Deadline10\bin\deadlinewebservice.exe”，打开后，我们就可以通过该设备的设备名称或者Ip地址进行通讯，API访问的端口默认情况下为8082。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/DeadlineWebServer.png" alt="DeadlineWebServer" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/DeadlineWebServer.png" class="lozad post-image"></p><h4 id="使用-PythonAPI"><a href="#使用-PythonAPI" class="headerlink" title="使用 PythonAPI"></a>使用 PythonAPI</h4><p style="text-indent:2em">使用时，必须创建一个 DeadlineCon 对象。该对象用于与 WebService 通信以发送和接收请求，该对象需要两个参数：“运行 WebService 服务的设备名或IP地址”、“该设备上允许 WebService 通信的端口号（默认为8082）”，这两个参数可以从已经运行的 WebService 通讯服务上找到。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="Deadline设备名称和端口号" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" class="lozad post-image"></p><p>然后我们就可以使用API创建一个连接对象“connectionObject &#x3D; Deadline.DeadlineConnect.DeadlineCon(‘WebServiceName’, WebServicePortNumber)”， 通过该对象，我们可以查询、修改 Deadline 上的大部分信息。</p><p>示例代码1：查询作业组、暂停指定作业</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import Deadline.DeadlineConnect as Connect  # 导入 Deadline.DeadlineConnect 作为连接connectionObject &#x3D; Connect.DeadlineCon(&#39;DESKTOP-Mirror&#39;, 8082)print(connectionObject.Groups.GetGroupNames())#[&quot;group1&quot;,&quot;group2&quot;,&quot;group3&quot;]jobId &#x3D; &quot;622c38262812473ba4c08eca&quot;  #(有效的job ID号)print(connectionObject.Jobs.SuspendJob(jobId))# &#39;Success&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码2：提交作业</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import Deadline.DeadlineConnect as ConnectDeadline &#x3D; Connect.DeadlineCon(&#39;DESKTOP-Mirror&#39;, 8082)JobInfo &#x3D; &#123;    &quot;Name&quot;: &quot;Submitted via Python&quot;,    &quot;UserName&quot;: &quot;UserName&quot;,    &quot;Frames&quot;: &quot;0-1&quot;,    &quot;Plugin&quot;: &quot;VraySpawner&quot;&#125;PluginInfo &#x3D; &#123;    &quot;Version&quot;: &quot;Max2014&quot;&#125;try:    newJob &#x3D; connectionObject.Jobs.SubmitJob(JobInfo, PluginInfo)    print(newJob)except:    print(&quot;Sorry, Web Service is currently down!&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li>官方说明：<a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/3_Python%20Reference/index.html#intro_sec">https://docs.thinkboxsoftware.com/products/deadline/10.1/3_Python%20Reference/index.html#intro_sec</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;本文介绍如何使用 Deadline 的 Python API 操作Deadline。</summary>
    
    
    
    <category term="Deadline" scheme="http://mirrorcg.github.io/categories/Deadline/"/>
    
    <category term="插件" scheme="http://mirrorcg.github.io/categories/Deadline/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="插件" scheme="http://mirrorcg.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Maya中材质文件和缓存文件相结合进行渲染的几种方式</title>
    <link href="http://mirrorcg.github.io/posts/20220503a6.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a6.html</id>
    <published>2022-05-03T08:48:37.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p style="text-indent:2em">本文记录材质文件和缓存文件相结合，组装渲染镜头文件的几种方式.<span id="more"></span></p><h3 id="缓存驱动材质文件进行渲染"><a href="#缓存驱动材质文件进行渲染" class="headerlink" title="缓存驱动材质文件进行渲染"></a>缓存驱动材质文件进行渲染</h3><p>使用缓存文件驱动材质文件的方式进行渲染。</p><h3 id="缓存文件直接替换材质文件的几何体进行渲染"><a href="#缓存文件直接替换材质文件的几何体进行渲染" class="headerlink" title="缓存文件直接替换材质文件的几何体进行渲染"></a>缓存文件直接替换材质文件的几何体进行渲染</h3><h3 id="缓存文件包裹材质文件进行渲染"><a href="#缓存文件包裹材质文件进行渲染" class="headerlink" title="缓存文件包裹材质文件进行渲染"></a>缓存文件包裹材质文件进行渲染</h3><h3 id="给缓存文件赋予材质进行渲染"><a href="#给缓存文件赋予材质进行渲染" class="headerlink" title="给缓存文件赋予材质进行渲染"></a>给缓存文件赋予材质进行渲染</h3>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;本文记录材质文件和缓存文件相结合，组装渲染镜头文件的几种方式.</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
    <category term="灯光" scheme="http://mirrorcg.github.io/tags/%E7%81%AF%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>Maya软件渲染问题集锦</title>
    <link href="http://mirrorcg.github.io/posts/20220503a5.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a5.html</id>
    <published>2022-05-03T08:01:45.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>渲染崩溃可能的问题：</p><ul><li>被赋予Arnold材质3s散射的物体是片，导致散射时不是在物体内部散射，而是在整个场景中散射，计算量特别大从而崩溃。</li><li>文件中毛发的密度太大导致渲染机内存不够用。</li><li>文件本身有问题。</li><li>具体问题，具体分析。</li></ul></li><li><p>Redshift:提示：’Mesh pCubeShape1 is instanced and uses adaptive tessellation, which isn’t supported. Disabling tessellation. If you need tessellation, please use fixed tessellation settings: i.e. disable ‘screen space adaptive’ and set ‘min edge length’ to zero to force a maximum tessellation level’。对象细分后在实例错误提示：对象在实例化后细分，被实例化对象在屏幕自适应时找不到细分对象，就不会进行细分。如果需要细分，就关闭屏幕自适应，并把最小边缘强度设置为零，以强制使用最大边缘强度，如图：</p><p> <img src="/images/Maya%E8%BD%AF%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/Redshift%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%86%E5%88%86.png" alt="Redshift实例对象自适应细分" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E8%BD%AF%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/Redshift%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%86%E5%88%86.png" class="lozad post-image"></p></li><li><p>农场机提示找不到可执行渲染的文件：“Katana render executable was not found in the semicolon separated list”（在分号分隔的列表中没有找到Katana渲染的可执行文件），该机器上没有安装相应的软件，或软件没有安装在默认的路径。</p></li><li><p>Cannot find procedure “pgYetiVRayPreRender”（或”pgYetiPreRender”）报错导致渲染暂停：渲染文件中没有Yeti毛发节点，却在渲染文件的渲染设置中填入了“pgYetiVRayPreRender”（或”pgYetiPreRender”）代码，导致渲染器找不到对应的节点而报错，我们只需要打开文件，删除渲染设置中的以下代码就行了（Render Settings &gt; Common &gt; Render Options，删除报错的MEL，一般情况下也可以全部删除）：</p> <table><tr> <td><img src="/images/Maya软件渲染问题集锦/Yeti报错.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/Yeti报错.png" class="lozad post-image"></td> <td><img src="/images/Maya软件渲染问题集锦/删除Yeti报错设置.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/删除Yeti报错设置.png" class="lozad post-image"></td> </tr></table></li><li><p>贴图文件正在上传或修改。日志出现：File“*******”was modified after being opened by OIIO，这是因为文件在渲染的时候，被文件IO读取的贴图文件还在上传或更新中<br> 解决办法：等待贴图上传完成后再渲染文件</p></li><li><p>盘符掉了或没有输出磁盘：<br> 解决办法：映射一个盘符</p> <pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">subst D: C:\D  ::映射D盘盘符到C盘的D文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Deadline农场渲染报错“defaultRenderLayer” is a layer from a referenced and is not allowed to be the current layer ,其可能是之一是：maya 的 renderLayerManage节点被改名导致 maya 不能生成默认的master layer渲染层（在.ma文件中的名称为defaultRenderLayer），因此可以将文件保存为.ma格式的文件，用文本的方式打开，将renderLayerManager节点的名称改为默认的’renderLayerManager’(没有任何修饰)，同时由于默认的renderLayerManager节点已经被修改过，默认的渲染层名称也发生了改变，导致渲染程序在调用的代码中，该层被判定为非默认的渲染层而报错“unable to modify overrides to the default layer”,因此，还需要将文件中的 defaultRenderLayer节点 (本问题记录时该节点名称为 defaultRenderLayer1 ),改为默认的名称defaultRenderLayer，即可。</p></li><li><p>maya动画文件直渲，后台批量渲染时，角色控制器带动角色模型不规则抖动的可能原因：这是旧版绑定系统的问题，这种问题一般可通过走 abc 流程规避，否则需要更新绑定的 cluster 节点选项。禁用”cluster.relative”，并将”cluster.angleInterpolation”的值设置为3，代码如下：</p> <pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">import maya.cmds as mcfor each in mc.ls(typ&#x3D;&quot;cluster&quot;):mc.setAttr(&quot;cluster1.relative&quot;, 0)mc.setAttr(&quot;cluster1.angleInterpolation&quot;, 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>maya动画文件直渲，后台批渲时，动画文件中的约束失效，例如角色对道具的约束丢失或者效果不对；可能原因：</p><ul><li>动画文件后台渲染其中的动力学不出缓存，会重新计算。</li><li>动画文件后台渲染时表达式会失效。<br>解决办法：（1）烘焙动画曲线：选择绑定组大组执行 Animation &gt; Key &gt; Bake Simulation 等待读条完成后会将控制器的每一帧都K上关键帧，然后再提交渲染即可；（2）在Premel中填入可拖动时间滑块到当前帧的mel表达式，该表达式会在渲染开始前对镜头中的帧进行切换，从开始帧逐渐切换至当前帧，相当于对文件中的控制器进行了一次”脏”运算。达到数据正确的目的。（3）走 abc 流程。</li></ul></li><li><p>maya 创建polygon报错：error line0:connection not made :”****.instObjGroup[0]”-initalShaderGroup.dagSetMembers[-1].destination is locked:可能原因：</p><ul><li>相关节点被锁</li><li>相关属性被锁<br>解决办法：解锁相关节点或相关属性，或者重启 Maya 可解决问题。</li></ul></li><li><p>后台渲染丢材质报错：[mtoa][translator polymesh] ShadingGroup ******:*****SG has no faceShader input …。可能原因：材质没有连接上对应模型或制作过程中切换过不同的渲染器，导致材质与物体mesh的链接断开；<br>解决办法：修改材质文件中的材质链接或重新连接材质，注意查看材质文件的材质、渲染器输出信息；或先赋予Lambert材质,再重新赋予原来的材质。</p></li><li><p>后台渲染和前台渲染的exr图片颜色空间不一致，或颜色不一致。可能原因：</p><ol><li>首选项中勾选了的 Preferences &gt; Output color preferences &gt; Apply Output Transform to Render ，并将Output Transform 设置为 Use View Transform ,该选项会应用 Preferences &gt; Color Transform Preferences 中的 View Transform 值到输出图片，该选项的作用是将渲染预览的结果转换并应用到输出图片（包括色彩空间），如果渲染预览的图片为sRGB编码的色彩空间图，则输出图片也会转换为sRGB色彩空间的图（如下图左1）。</li><li>渲染器驱动节点的”defaultArnoldDriver.colorManagement”渲染设置为了 Use View Transform ，其默认值为 Use Output Transform，原因和 1 一致（正确设置如下图右1所示）。<br>选中驱动节点代码：<pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">mc.select(&quot;defaultArnoldDriver.colorManagement&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><tr><td><img src="/images/Maya软件渲染问题集锦/渲染空间不一致首选项设置 .png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/渲染空间不一致首选项设置 .png" class="lozad post-image"></td><td><img src="/images/Maya软件渲染问题集锦/渲染空间不一致节点选项设置.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/渲染空间不一致节点选项设置.png" class="lozad post-image"></td></tr></table></li></ol></li><li><p>同一个场景代理文件，渲染颜色不一致、闪烁，可能原因：代理文件导入maya后，其材质网络被修改过，使两个aistand_in使用相同的代理颜色却不一样，从而产生错误（原因未知）。解决办法：1.改会原来的材质。2.修改使用两个不同的代理文件。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="锦囊小妙招" scheme="http://mirrorcg.github.io/tags/%E9%94%A6%E5%9B%8A%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Maya软件小知识点</title>
    <link href="http://mirrorcg.github.io/posts/20220503a4.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a4.html</id>
    <published>2022-05-03T07:54:38.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>贴图色彩空间被锁定的情况，解锁所有节点贴图的贴图色彩空间选项：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmdsfor i in cmds.ls(type&#x3D;&#39;file&#39;):    cmds.connectAttr(&quot;:defaultColorMgtGlobals.cme&quot;,i+&quot;.cme&quot;,f&#x3D;1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>脚本切换渲染器:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">cmds.setAttr(&quot;defaultRenderGlobals.currentRenderer&quot;, &quot;arnold&quot;, type&#x3D;&quot;string&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取当前视图快照拍屏：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">ws &#x3D; cmds.workspace(q &#x3D; True, fullName &#x3D; True)wsp &#x3D; ws + &quot;&#x2F;&quot; + &quot;images&quot;imageSnapshot &#x3D; wsp + &quot;&#x2F;&quot; + &quot;endSnapshot.jpg&quot;cmds.refresh(cv&#x3D;True, fe &#x3D; &quot;jpg&quot;, fn &#x3D; imageSnapshot)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>脚本设置渲染设置的输出序列图选项：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">mc.setAttr(&quot;defaultRenderGlobals.animation&quot;, True)  # 开启动画帧序列mc.setAttr(&quot;defaultRenderGlobals.animationRange&quot;,1)  # 开启动画帧的范围mc.setAttr(&quot;defaultRenderGlobals.outFormatControl&quot;, 1)  # 设置帧格式mc.setAttr(&quot;defaultRenderGlobals.putFrameBeforeExt&quot;, 1) # 设置图片格式在数字后面（name.#.ext）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建多相机渲染：</p><ul><li>选择相机&gt;AtteibutsEdit&gt;OutputSettings&gt;Renderable(勾选)</li><li>RenderSetting&gt;RednderableCamera&gt;Add RenderableCamera</li></ul></li><li><p>Arnold开关运动模糊要同时设置运动模糊可见性:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">mc.setAttr(&quot;defaultRenderGlobals.motionBlur&quot;, 0) #关闭运动模糊（针对于Arnold）mc.setAttr(&quot;defaultArnoldRenderOptions.motion_blur_enable&quot;, 0) #关闭运动模糊可见性mc.setAttr(&quot;defaultRenderGlobals.motionBlur&quot;, 1) #开启运动模糊mc.setAttr(&quot;defaultArnoldRenderOptions.motion_blur_enable&quot;, 1) #开启运动模糊可见性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>脚本打印部分渲染节点属性名称和值的方式:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds render_glob &#x3D; &quot;defaultRenderGlobals&quot;list_Attr &#x3D; cmds.listAttr(render_glob, r&#x3D;True, s&#x3D;True)for attr in list_Attr:    get_attr_name &#x3D; &quot;%s.%s&quot;%(render_glob, attr)    print &quot;setAttr %s %s&quot;%(get_attr_name, cmds.getAttr(get_attr_name))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>mtoa 创建和访问AOV:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import mtoa.aovs as aovs# 添加aovaovs.AOVInterface().addAOV(&#39;aov名称&#39;, aovType&#x3D;&#39;float&#39;)# 列出活动状态的aovsaovs.AOVInterface().getAOVs()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Arnold代码加载arnold渲染器并创建默认节点：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcimport mtoa.coremc.setAttr(&quot;defaultRenderGlobals.currentRenderer&quot;,&quot;arnold&quot;,typ&#x3D;&quot;string&quot;)mtoa.core.createOptions()  # 创建ar默认节点网络<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看 mel 函数帮助：<br>使用 “whatIs ‘mel命令’;” 可以查看mel函数帮助。</p></li><li><p>设置maya视图窗口为非显卡（不使用显卡）支持的窗口模式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcdef switch_preview():    all_model_panel &#x3D; mc.getPanel(typ&#x3D;&quot;modelPanel&quot;)    for each in all_model_panel:        mc.modelEditor(each,e&#x3D;True,rnm&#x3D;&quot;base_OpenGL_Renderer&quot;)  # 查询可用的渲染器名称 mc.modelEditor(each,q&#x3D;True,rendererList&#x3D;True) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Xgen相关:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import xgenm.xmaya.xgmExternalAPI as xgenmExternalAPIimport xgenm as xgpalettes &#x3D; xg.palettes()  # 获取Xgen 所有描述if not (xgenmExternalAPI.xgg.DescriptionEditor is None):    xgenmExternalAPI.xgg.DescriptionEditor.refresh(&quot;Full&quot;)  # 刷新所有Xgen面板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="锦囊小妙招" scheme="http://mirrorcg.github.io/tags/%E9%94%A6%E5%9B%8A%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Maya软件小问题集锦</title>
    <link href="http://mirrorcg.github.io/posts/20220503a3.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a3.html</id>
    <published>2022-05-03T07:02:20.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了一些Maya中出现的一些小问题：<span id="more"></span></p><ol><li><p>AOV无法正常创建</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcmc.lockNode(&#39;initialParticleSE&#39;,l&#x3D;0,lu&#x3D;0)mc.lockNode(&#39;initialShadingGroup&#39;,l&#x3D;0,lu&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Maya 操作总是提示 “&#x2F;&#x2F; Error: line 1: Cannot find procedure “onModelChange3dc”. &#x2F;&#x2F;“，这可能是模型制作的时候打开了某个窗口，maya在关闭的时候会保存一份配置在maya文件里，可以从Expression Editor的By Script Node Name里看到，虽然没什么影响，但是真的很烦。解决办法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymel.core as pm# 获取Maya中的所有模型编辑器并重置 editorChanged 事件for item in pm.lsUI(editors&#x3D;True):   if isinstance(item, pm.ui.ModelEditor):       pm.modelEditor(item, edit&#x3D;True, editorChanged&#x3D;&quot;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>RenderSetting渲染面板内容空白，执行mel脚本:</p><pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">deleteUI unifiedRenderGlobalsWindow;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>关闭“cannot find procedrure ‘look’”：</p><ul><li><p>执行mel脚本:</p><ul><li>方法一：<pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>方法二：<pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">global proc look()&#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>执行python脚本:</p> <pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">maya.mel.eval(&#39;outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;&#39;) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>删除TurtleDefaultBakeLayer层：</p><ul><li><p>执行mel脚本</p> <pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">&#x2F;&#x2F;删除海龟渲染 mel脚本lockNode -l off TurtleDefaultBakeLayer;delete TurtleDefaultBakeLayer;lockNode -l off TurtleRenderOptions;delete TurtleRenderOptions;lockNode -l off TurtleBakeLayerManager;delete TurtleBakeLayerManager;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行python脚本</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">def delTurtleRender():    if mc.objExists(&#39;TurtleRenderOptions&#39;):        mc.lockNode(&#39;TurtleRenderOptions&#39;, &#39;TurtleUIOptions&#39;, &#39;TurtleBakeLayerManager&#39;, &#39;TurtleDefaultBakeLayer&#39;, lock&#x3D;0)        mc.delete(&#39;TurtleRenderOptions&#39;, &#39;TurtleUIOptions&#39;, &#39;TurtleBakeLayerManager&#39;, &#39;TurtleDefaultBakeLayer&#39;)        print u&quot;海龟渲染节点清理完成&quot;    else:        print u&quot;场景中海龟渲染节点已清理干净&quot;delTurtleRender()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Maya Arnold不能渲染:<br> &#x2F;&#x2F; Rendering with Arnold Renderer… &#x2F;&#x2F;<br> &#x2F;&#x2F; Result: Rendering Completed. See mayaRenderLog.txt for information. &#x2F;&#x2F;<br> 是因为Maya 的mtoa环境变量丢失，导致渲染器使用的部分文件没有调用到，因此直接结束渲染。<br> 解决办法：<br> <a href="https://support.solidangle.com/display/AFMUG/Batch+Rendering">https://support.solidangle.com/display/AFMUG/Batch+Rendering</a> 的Batch Render Flags   提到了解决问题的办法，就是在环境变量中增加如下环境变量（对应maya版本号）：<br> MAYA_RENDER_DESC_PATH&#x3D;C:\solidangle\mtoadeploy\对应maya版本号<br> 然后，重新打开maya渲染。或者，重新安装渲染器，此办法有概率解决问题。</p></li><li><p>高版本Maya(2020以上)不能加载Arnold渲染器的问题：需要打补丁程序VC_redist.x64.exe。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录了一些Maya中出现的一些小问题：</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="锦囊小妙招" scheme="http://mirrorcg.github.io/tags/%E9%94%A6%E5%9B%8A%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Maya文件打开慢或者崩溃的检查办法</title>
    <link href="http://mirrorcg.github.io/posts/20220503a2.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a2.html</id>
    <published>2022-05-03T06:07:21.000Z</published>
    <updated>2022-05-03T07:07:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目制作过程中常常会遇到制作文件打不开或者打开慢的情况，对于此类问题：<span id="more"></span></p><ol><li><p>如果是’.mb’文件，会比较麻烦些，需要在打开文件时不加载引用文件，然后一个一个加载引用文件，根据引用文件的加载情况进行判断是否有引用文件有问题。一般会出现：单个引用文件加载崩溃、单个引用文件加载慢、所有引用文件加载都没问题，但是保存后还是打开有问题，这时就需要分别尝试打开带有加载不同引用文件的maya文件。（之前碰到过引用文件中有的节点有冲突：相同的引用文件单独加载都没问题，但保存后加载会崩溃，然后逐步定位加载有问题的文件一步一步排除，最后将有冲突的节点重建才解决问题。）</p></li><li><p>如果是’.ma’文件：</p><ul><li>使用上面的’.mb’文件的办法。</li><li>在文件中插入 mel 脚本，在打开脚本的同时，执行mel脚本，通过脚本的日志内容情况来判断是什么文件导致的‘.ma’文件打不开，或者打开慢的情况。</li></ul></li></ol><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import codecsdef checkMayaAsciiFile(source_file, target_file, log_file):    &quot;&quot;&quot;    1. 用于检查 Maya Ascii 文件打开崩溃    2. - - - - - - - - - - - - - -耗时    Args:        source_file: ma 文件        target_file: 修改后的文件        log_file: logging    Returns: none    &quot;&quot;&quot;    # # 记录打不开的ma文件是从哪一行崩溃的    # __startMel &#x3D; &#39;&#39;&#39;python(&quot;logFile&#x3D;&#39;%s&#39;;ff &#x3D; open(logFile,&#39;w&#39;);ff.write(&#39; &#39;);ff.close();&quot;);&#39;&#39;&#39; % log_file    # __proc &#x3D; &#39;&#39;&#39;python(&quot;ff &#x3D; open(logFile,&#39;a&#39;);ff.write(&#39;%s - &#123;0&#125;\\\\n&#39;.format(comp_time));ff.close();&quot;);\n&#39;&#39;&#39;    # __endMel &#x3D; &quot;&quot;    # 记录打开文件时的耗时信息    __startMel &#x3D; &#39;&#39;&#39;python(&quot;from datetime import datetime;import time;line_time&#x3D;datetime.now();time.sleep(0.002);threshold_time&#x3D;datetime.now() - line_time;start_time&#x3D;line_time;logging&#x3D;list();logFile&#x3D;&#39;%s&#39;&quot;);&#39;&#39;&#39; % log_file    __proc &#x3D; &#39;&#39;&#39;python(&quot;comp_time &#x3D; datetime.now() - line_time;logging.append(&#39;%s - &#39;+ str(comp_time)) if comp_time &gt; threshold_time else None;line_time &#x3D; datetime.now();&quot;);\n&#39;&#39;&#39;    __endMel &#x3D; &#39;&#39;&#39;python(&quot;logging.append(&#39;\\\\n\\\\nStart Time - &#39;+ str(start_time) + &#39;\\\\nEnd Time - &#39;+ str(line_time) + &#39;\\\\nTotal Time - &#39; + str(line_time - start_time));ff &#x3D; open(logFile,&#39;w&#39;);[ff.write(line+&#39;\\\\n&#39;) for line in logging];ff.close();&quot;);&#39;&#39;&#39;    with codecs.open(source_file, &quot;r&quot;, &quot;gbk&quot;) as f:        aLines &#x3D; f.readlines()    fileter &#x3D; (&quot;select&quot;, &quot;connectAttr&quot;, &quot;dataStructure&quot;, &quot;createNode&quot;, &quot;requires&quot;, &quot;currentUnit&quot;)    # other relationship fileInfo    rule &#x3D; 1    for num, line in enumerate(aLines):        line_add &#x3D; &quot;&quot;.join([aLines[num - 1][:-1], __proc % str(num)])        if rule:  # 文件开头的 file 每一行都加 mel            if __startMel:  # 文件开头结尾初始化命令                aLines[num] &#x3D; __startMel + line                if __endMel:                    aLines[num - 1] &#x3D; __endMel + aLines[num - 1]                __startMel &#x3D; 0                continue            if &quot;file&quot; in line:  # 可能有的设置里会有file字符串,所以这里要独立规则                if &quot;;\n&quot; not in aLines[num - 1]:                    continue                aLines[num - 1] &#x3D; line_add            if &quot;requires&quot; in line:  # requires 之后改变规则                rule &#x3D; 0        # 在 fileter 参数里的,对它的前一行添加 mel        # setAttr 用的是 .attr 的方式,在它之后加 mel 会影响下一个 setAttr 所以这里添加这个过滤        for _ in fileter:            if _ in line:                if &quot;;\n&quot; in aLines[num - 1]:                    aLines[num - 1] &#x3D; line_add    with codecs.open(target_file, &quot;w&quot;, &quot;gbk&quot;) as ff:        for lines in aLines:            ff.write(lines)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    srcFile &#x3D; r&quot;E:\test\shot00401.ma&quot;    srcFile &#x3D; srcFile.replace(&quot;\\&quot;, &quot;&#x2F;&quot;)    sourceFile &#x3D; srcFile    targetFile &#x3D; srcFile[:-3] + &quot;_v01.ma&quot;    logFile &#x3D; srcFile[:-3] + &quot;_v01.txt&quot;    # print(sourceFile, targetFile, logFile)    checkMayaAsciiFile(sourceFile, targetFile, logFile)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，需要将”E:\test\shot00401.ma”替换成你的‘.ma’文件路径，执行完成后，会在同级文件目录下生成一个版本号为‘-v01’的‘.ma’文件，使用Maya打开该文件，打开文件的同时会执行文件中的mel脚本保存日志信息，文件读取完成后，也会在统计目录下生成一个版本号为‘-v01’的txt日志文件，打开文件分析即可。</p><h4 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h4><p>部分内容转载自：<a href="https://ruben.blog.csdn.net/article/details/90082639">https://ruben.blog.csdn.net/article/details/90082639</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目制作过程中常常会遇到制作文件打不开或者打开慢的情况，对于此类问题：</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="小工具" scheme="http://mirrorcg.github.io/categories/Maya/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="检查" scheme="http://mirrorcg.github.io/tags/%E6%A3%80%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Maya中在物体的点上创建跟踪对象</title>
    <link href="http://mirrorcg.github.io/posts/20220503a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a1.html</id>
    <published>2022-05-03T05:28:40.000Z</published>
    <updated>2022-05-03T06:28:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">之前做测量相机焦距工具的时候发现不能把焦距添加约束到物体上的点，尤其是做了abc缓存之后，由于并没有对点进行编辑，不管是在自身空间还是世界空间中，点的位置在数值上都没有变换，被约束的相机的焦点依旧保持在原地，因此对点添加普通的的约束并不能达到效果，我们需要换一种方式进行约束。<span id="more"></span></p><p style="text-indent:2em">可以使用给点创建毛囊的办法，利用uv映射的点的位置始终保持不变，但是物体的世界矩阵在变化的原理，将点世界坐标的信息传递给毛囊，毛囊会一直跟着点的，此时我们只需要约束毛囊就能达到我们想要的效果了。</p><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-# !&#x2F;usr&#x2F;bin&#x2F;env python27# @Author: Mirror# @Time: 2022-03-15# description: 该脚本用于在选中点的位置上创建定位毛囊，该毛囊通过UV点定位，所有使用后不能调整点所在的UV# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;import maya.cmds as mcdef buildFollicle(points):    if not points:        return    if type(points).__name__ &#x3D;&#x3D; &quot;str&quot;:        points &#x3D; [points]    for point in points:        poly_transform &#x3D; mc.listRelatives(mc.listRelatives(point, p&#x3D;True, s&#x3D;True)[0], p&#x3D;True, s&#x3D;True)[0]        point_uvVertex &#x3D; mc.polyListComponentConversion(point, fv&#x3D;True, tuv&#x3D;True)        point_uvposition &#x3D; mc.polyEditUV(point_uvVertex[0], q&#x3D;1)        follicle &#x3D; mc.createNode(&quot;follicle&quot;, n&#x3D;&quot;follicle_%s&quot; % point.replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;, &quot;&quot;).replace(&quot;.&quot;, &quot;_&quot;))        follicle_transform &#x3D; mc.listRelatives(follicle, p&#x3D;True)[0]        mc.connectAttr(poly_transform + &quot;.worldMatrix[0]&quot;, follicle + &quot;.inputWorldMatrix&quot;)        mc.connectAttr(poly_transform + &quot;.outMesh&quot;, follicle + &quot;.inputMesh&quot;)        mc.connectAttr(follicle + &quot;.outTranslate&quot;, follicle_transform + &quot;.translate&quot;)        mc.connectAttr(follicle + &quot;.outRotate&quot;, follicle_transform + &quot;.rotate&quot;)        mc.setAttr(follicle_transform + &quot;.parameterU&quot;, point_uvposition[0])        mc.setAttr(follicle_transform + &quot;.parameterV&quot;, point_uvposition[1])if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    vertexs &#x3D; mc.ls(sl&#x3D;True,fl&#x3D;True)    buildFollicle(vertexs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：在添加了定位的毛囊之后，不能修改UV，否则毛囊会回到原点，约束失效，需要重新创建毛囊和约束。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>官网中相关的介绍：<a href="https://help.autodesk.com/view/MAYAUL/2018/CHS/?guid=GUID-A0D2DD53-FE41-4244-8635-CD4651ABF97F">https://help.autodesk.com/view/MAYAUL/2018/CHS/?guid=GUID-A0D2DD53-FE41-4244-8635-CD4651ABF97F</a></p>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-indent:2em&quot;&gt;之前做测量相机焦距工具的时候发现不能把焦距添加约束到物体上的点，尤其是做了abc缓存之后，由于并没有对点进行编辑，不管是在自身空间还是世界空间中，点的位置在数值上都没有变换，被约束的相机的焦点依旧保持在原地，因此对点添加普通的的约束并不能达到效果，我们需要换一种方式进行约束。</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="小工具" scheme="http://mirrorcg.github.io/categories/Maya/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="灯光" scheme="http://mirrorcg.github.io/tags/%E7%81%AF%E5%85%89/"/>
    
    <category term="UV" scheme="http://mirrorcg.github.io/tags/UV/"/>
    
  </entry>
  
  <entry>
    <title>一些好用的网站</title>
    <link href="http://mirrorcg.github.io/posts/20220501a2.html"/>
    <id>http://mirrorcg.github.io/posts/20220501a2.html</id>
    <published>2022-05-01T11:57:59.000Z</published>
    <updated>2022-07-08T11:57:59.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">本文推荐一些多快好省的网站、技术大佬的博客网站、专业网站。<span id="more"></span></p><ol><li><p>图标下载</p><ul><li>Icon图标下载：<a href="https://icon-icons.com/zh/">https://icon-icons.com/zh/</a></li><li>阿里巴巴矢量图库：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></li><li>图片格式转换： <a href="https://www.butterpig.top/ico/">https://www.butterpig.top/ico/</a></li></ul></li><li><p>影视行业软件下载网站：</p><ul><li>画忆大佬的软件下载网站(无毒无公害)：<a href="http://www.iiicg.com/">www.iiicg.com</a></li><li>nuke插件网 站：<a href="http://www.nukepedia.com/">www.nukepedia.com</a></li></ul></li><li><p>技术大佬们的博客网页</p><ul><li>TD手册：<a href="https://cg-td-course.readthedocs.io/zh_CN/latest/index.html">https://cg-td-course.readthedocs.io/zh_CN/latest/index.html</a></li><li>凌云大佬技术博客分享：<a href="https://lingyunfx.com/">https://lingyunfx.com/</a></li><li>汝小右大佬博客：<a href="https://ruben.blog.csdn.net/?type=blog">https://ruben.blog.csdn.net/?type=blog</a></li></ul></li><li><p>行业官网</p><ul><li>Maya2022 用户文档：<a href="https://help.autodesk.com/view/MAYAUL/2022/CHS/">https://help.autodesk.com/view/MAYAUL/2022/CHS/</a></li><li>Yeti 用户文档：<a href="https://support.peregrinelabs.com/support/solutions/66000172201">https://support.peregrinelabs.com/support/solutions/66000172201</a></li><li>Arnold 用户文档：<a href="https://www.arnoldrenderer.com/news/">https://www.arnoldrenderer.com/news/</a></li><li>Nuke 用户文档：<a href="https://learn.foundry.com/nuke/13.1/content/learn_nuke.html">https://learn.foundry.com/nuke/13.1/content/learn_nuke.html</a></li><li>Katana 用户文档：<a href="https://learn.foundry.com/katana/5.0/Content/learn_katana.html">https://learn.foundry.com/katana/5.0/Content/learn_katana.html</a></li><li>Deadline 用户文档：<a href="https://docs.thinkboxsoftware.com/">https://docs.thinkboxsoftware.com/</a></li><li>Pyside2 用户文档：<a href="https://wiki.qt.io/Main">https://wiki.qt.io/Main</a></li><li>ShotGrid 用户文档：<a href="https://help.autodesk.com/view/SGSUB/CHS/">https://help.autodesk.com/view/SGSUB/CHS/</a></li><li>AutoIt3 用户文档：<a href="https://www.autoitscript.com/autoit3/docs/">https://www.autoitscript.com/autoit3/docs/</a></li><li>USD 用户文档：<a href="https://graphics.pixar.com/usd/release/index.html">https://graphics.pixar.com/usd/release/index.html</a></li><li>UE4 官网：<a href="https://www.unrealengine.com/zh-CN">https://www.unrealengine.com/zh-CN</a></li><li>ACES 用户手册：<a href="https://acescentral.com/knowledge-base-2/">https://acescentral.com/knowledge-base-2/</a></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-indent:2em&quot;&gt;本文推荐一些多快好省的网站、技术大佬的博客网站、专业网站。</summary>
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    
    <category term="网站推荐" scheme="http://mirrorcg.github.io/tags/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>QT中的系统托盘图标和系统消息推送</title>
    <link href="http://mirrorcg.github.io/posts/20220501a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220501a1.html</id>
    <published>2022-05-01T09:40:20.000Z</published>
    <updated>2022-05-01T11:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">本文记录: 使用 PySide2 编写工具界面时，需要为工具创建系统托盘图标以及推送消息的方法。<span id="more"></span>以方便用户对工具进行操作。</p><p style="text-indent:2em">通过 PySide2 创建系统托盘，需要使用 PySide2.QtWidgets.QSystemTrayIcon 这个类。这个类中需要使用了以下常用方法，就可以创建最基本的系统托盘图标：</p><ul><li>QSystemTrayIcon   创建一个系统托盘对象</li><li>QSystemTrayIcon.setContextMenu    添加右键菜单(QMenu)</li><li>QSystemTrayIcon.showMessage   在右下角弹出要提示消息</li><li>QObject.connect 连接信号和槽</li></ul><p>使用上面的方法，可以完成：</p><ol><li>在系统托盘中创建一个程序图标。</li></ol><p><img src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87.png" alt="创建的系统托盘图标.png" srcset="/images/home/Myhead.jpg" data-src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87.png" class="lozad post-image">  </p><ol start="2"><li>在程序创建完成托盘图标后，推送一条提示程序已经启动的系统消息。</li></ol><p><img src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E6%8E%A8%E9%80%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF.png" alt="推送的系统消息.png" srcset="/images/home/Myhead.jpg" data-src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E6%8E%A8%E9%80%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF.png" class="lozad post-image">  </p><ol start="3"><li>鼠标点击图标时的左右键功能。</li></ol><p><img src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E5%B7%A6%E5%8F%B3%E9%94%AE%E5%8A%9F%E8%83%BD.png" alt="点击图标左右键功能.png" srcset="/images/home/Myhead.jpg" data-src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E5%B7%A6%E5%8F%B3%E9%94%AE%E5%8A%9F%E8%83%BD.png" class="lozad post-image">  </p><p>代码示例如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import sysfrom PySide2.QtWidgets import QApplication, QAction, QMenu, QSystemTrayIconfrom PySide2.QtCore import SIGNAL, QObjectfrom PySide2.QtGui import QIcondef close():    print(&quot;close&quot;)def restart():    print(&quot;restart&quot;)def show():    print(&quot;show&quot;)app &#x3D; QApplication(sys.argv)exit &#x3D; QAction(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu.ico&quot;), &quot;Exit&quot;, )QObject.connect(exit, SIGNAL(&quot;triggered()&quot;), close)res &#x3D; QAction(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu1.ico&quot;), &quot;Restart&quot;, )QObject.connect(res, SIGNAL(&quot;triggered()&quot;), restart)menu &#x3D; QMenu()  # 创建菜单，添加菜单选项menu.addAction(exit)menu.addAction(res)trayIcon &#x3D; QSystemTrayIcon(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu4.ico&quot;))  # 创建系统托盘trayIcon.setContextMenu(menu)QObject.connect(trayIcon, SIGNAL(&quot;activated(QSystemTrayIcon::ActivationReason)&quot;), show)trayIcon.show()trayIcon.setToolTip(&quot;启动器&quot;)trayIcon.showMessage(&quot;启动器已经启动!&quot;, &quot;左击显示窗口\n右击显示菜单&quot;, QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu_Note1.ico&quot;))sys.exit(app.exec_())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行代码后，会在电脑桌面系统托盘创建一个本程序的图标，同时会推送一条启动信息，该信息会自动收回。<br>上面的代码没有判断点的是左还是右键，所以只要鼠标点击图标都会先打印一遍 “show”,请自行判断。</p>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-indent:2em&quot;&gt;本文记录: 使用 PySide2 编写工具界面时，需要为工具创建系统托盘图标以及推送消息的方法。</summary>
    
    
    
    <category term="Qt" scheme="http://mirrorcg.github.io/categories/Qt/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Qt/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="QT事件" scheme="http://mirrorcg.github.io/tags/QT%E4%BA%8B%E4%BB%B6/"/>
    
    <category term="信号&amp;槽" scheme="http://mirrorcg.github.io/tags/%E4%BF%A1%E5%8F%B7-%E6%A7%BD/"/>
    
    <category term="系统托盘图标和消息" scheme="http://mirrorcg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E6%B6%88%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>USD框架的搭建</title>
    <link href="http://mirrorcg.github.io/posts/20220421a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220421a1.html</id>
    <published>2022-04-20T16:02:26.000Z</published>
    <updated>2022-04-20T16:02:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天来介绍一下 windows 环境下 USD 的独立安装过程。<span id="more"></span><br>首先，我们需要了解几个网站：</p><p style="text-indent:2em">USD 的帮助文档 ：https://graphics.pixar.com/usd/release/index.html</p><p style="text-indent:2em">USD 的Github仓库 ：https://github.com/PixarAnimationStudios/USD</p><h4 id="安装准备："><a href="#安装准备：" class="headerlink" title="安装准备："></a>安装准备：</h4><p>需要准备：Python2、Cmake、NASM、Microsoft Visual Studio2017、Microsoft Visual Studio Code</p><p style="text-indent:2em">1. 确认环境中有Python2。在 windows 上安装 USD 需要我们的环境中有 Python， 由于 USD 目前还不支持Python3 ，因此我使用的是 Python2.7.16 ,没有Python2 的小伙伴可以从<a href="https://www.python.org/downloads/release/python-2710/" title="" target="">官网下载</a>，下载安装好后，需要调整一下环境变量的顺序，将Python2的相关环境变量提升到Python3的前面，这样可以在后面安装的时候直接调用Python2的环境,就不会出现一些奇怪的问题导致安装失败，如下图。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E5%89%8D%E7%BD%AEpython2%E7%9A%84%E7%8E%AF%E5%A2%83.png" alt="前置python2的环境" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E5%89%8D%E7%BD%AEpython2%E7%9A%84%E7%8E%AF%E5%A2%83.png" class="lozad post-image"></p><p style="text-indent:2em">2. 安装CMAKE工具，如果电脑上没有CMAKE，可以<a href="https://cmake.org/download/" title="" target="">从这里下载</a>，往下翻，找到相应的平台和系统版本，下载到一个可安装的文件，使用默认安装就好。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDCMAKE.png" alt="下载CMAKE" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDCMAKE.png" class="lozad post-image"></p><p style="text-indent:2em">3. 安装NASM，如果电脑上也没有NASM，则可以<a href="https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=D" title="" target="">从这里下载</a>，打开链接后选择一个合适的版本，我使用的是2.15.05版本的NASM，双击文件夹，选择自己系统对应的文件夹，再次双击，可以看到一个安装程序，点击即可下载，没有特殊需求的话，尽量使用默认安装。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDNASM.png" alt="下载NASM" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDNASM.png" class="lozad post-image"></p><p style="text-indent:2em">4. 安装Microsoft Visual Studio，USD 暂时不支持较新的版本，本案例使用的是VS2017版本，可以<a href="https://my.visualstudio.com/Downloads?q=visual%20studio%202017&wt.mc_id=o~msft~vscom~older-downloads" title="" target="">从这里下载</a>，选择一个合适的版本，安装过程中选择使用C++的桌面开发。</p><p style="text-indent:2em">5. 安装Microsoft Visual Studio Code，如果没有VSCode，可以<a href="https://code.visualstudio.com/download" title="" target="">从这里下载</a>，选择一个合适的版本，下载后默认安装好，打开下载Python拓展插件，并将上面安装的Python2的执行程序路径填入对应位置，如下图所示。</p><table><tr><td><img src="/images/USD框架的搭建/下载VSCode.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/USD框架的搭建/下载VSCode.png" class="lozad post-image"></td><td><img src="/images/USD框架的搭建/安装Python插件.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/USD框架的搭建/安装Python插件.png" class="lozad post-image"></td></tr></table>接下来我们还需要为Python2安装一些功能模块：PySide、pyd、pyopengl、Jinja2，在cmd中依次执行下面的指令即可<p style="text-indent:2em">pip install PySide</p><p style="text-indent:2em">pip install pyd</p><p style="text-indent:2em">pip install pyopengl</p><p style="text-indent:2em">pip install Jinja2</p>注：这里如果出现“pip Fatal error in launcher: Unable to create process...”错误，可以通过python安装文件的修复功能来解决，点击repair。<h4 id="构建-USD"><a href="#构建-USD" class="headerlink" title="构建 USD"></a>构建 USD</h4><p style="text-indent:2em">先从USD 的Github仓库<a href="https://github.com/PixarAnimationStudios/USD" title="" target="">下载 USD 源码</a>到本地，打开“x86 Native Tools Command Prompt VS 2017”界面，这里不能使用x64,并且对于高版本的VS,不管是"X64" 还是 "x86" 均不能安装成功。输入 python "你的USD源码下载位置"\build_scripts\build_usd.py "C:\USD" ，其中"C:\USD"是你的安装位置（安装位置中似乎不能有空格，我尝试了几次将usd安装在带空格的"Program Files (x86)"中，都没有成功）。程序会自动为你安装zlib，boost，TBB，OpenSubdiv用来构建USD环境。这个过程只有简单的几条语句提示，没有进度条，并且可能会报错或者安装不成功（也许是下载速度的原因），多执行几次上面的构建指令就好了，我也是安装了三次才成功。成功后会提示你，需要将 "C:\USD\lib\python"添加进系统变量PYTHONPATH中，再在系统变量 PATH 中添加 "C:\USD\bin" 和 "C:\USD\lib"两个路径，如下图所示。<p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E6%9E%84%E5%BB%BA%E7%95%8C%E9%9D%A2.png" alt="构建界面" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E6%9E%84%E5%BB%BA%E7%95%8C%E9%9D%A2.png" class="lozad post-image"></p><p>至此USD环境就搭建好了。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>打开一个cmd窗口，cd 进入你的USD源代码目录,然后输入指令：“usdview .\extras\usd\tutorials\convertingLayerFormats\Sphere.usd”，出现下面的界面就表示成功了。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/USD%E7%95%8C%E9%9D%A2.png" alt="USD界面" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/USD%E7%95%8C%E9%9D%A2.png" class="lozad post-image"></p><p>接下来就可以愉快地<a href="https://graphics.pixar.com/usd/release/tut_usd_tutorials.html#" title="" target="">学习案例</a>了！！！</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol><li><a href="https://zhuanlan.zhihu.com/p/437422802">https://zhuanlan.zhihu.com/p/437422802</a></li><li><a href="https://github.com/PixarAnimationStudios/USD/blob/release/README.md#getting-and-building-the-code">https://github.com/PixarAnimationStudios/USD/blob/release/README.md#getting-and-building-the-code</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天来介绍一下 windows 环境下 USD 的独立安装过程。</summary>
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Doc/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="USD" scheme="http://mirrorcg.github.io/tags/USD/"/>
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
  </entry>
  
</feed>
