<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mirror的个人博客</title>
  
  <subtitle>Mirror的博客</subtitle>
  <link href="http://mirrorcg.github.io/atom.xml" rel="self"/>
  
  <link href="http://mirrorcg.github.io/"/>
  <updated>2022-08-28T08:03:22.000Z</updated>
  <id>http://mirrorcg.github.io/</id>
  
  <author>
    <name>Mirror</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maya中创建UI</title>
    <link href="http://mirrorcg.github.io/posts/20220823a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220823a1.html</id>
    <published>2022-08-23T14:43:27.000Z</published>
    <updated>2022-08-28T08:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在maya中创建各种UI<span id="more"></span></p><h4 id="创建主菜单和菜单项："><a href="#创建主菜单和菜单项：" class="headerlink" title="创建主菜单和菜单项："></a>创建主菜单和菜单项：</h4><p>menuItem() 若不指定父级,都默认将菜单项添加到上一个创建的菜单中。</p><p><img src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E4%B8%BB%E8%8F%9C%E5%8D%95%E8%8F%9C%E5%8D%95%E9%A1%B9.png" alt="主菜单菜单项.png" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E4%B8%BB%E8%8F%9C%E5%8D%95%E8%8F%9C%E5%8D%95%E9%A1%B9.png" class="lozad post-image"></p><p>示例代码：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds cmds.menu( &quot;test&quot;,label&#x3D;&#39;流程框架&#39;, tearOff&#x3D;True,parent&#x3D;&quot;MayaWindow&quot; )cmds.menuItem( label&#x3D;&#39;New&#39; )cmds.menuItem( label&#x3D;&#39;Open&#39; )cmds.menuItem( label&#x3D;&#39;Save&#39; )cmds.menuItem( divider&#x3D;True )  # 分隔线cmds.menuItem( label&#x3D;&#39;print&#39;,c&#x3D;&quot;print(11111)&quot; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建菜单集"><a href="#创建菜单集" class="headerlink" title="创建菜单集"></a>创建菜单集</h4><p>菜单集中的菜单项来自于上面创建的主菜单，因此需要有菜单项才能添加和显示菜单集。空的菜单集不在菜单集的下拉框中显示，因此菜单集下至少应该拥有一项菜单项。</p><p><img src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E8%8F%9C%E5%8D%95%E9%9B%86.png" alt="菜单集.png" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E8%8F%9C%E5%8D%95%E9%9B%86.png" class="lozad post-image"></p><p>示例代码：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds cmds.menuSet( &#39;testSet&#39;, label&#x3D;&#39;testSetLabel&#39; )  # 创建菜单集,不指定标签，显示为空行cmds.menuSet(am&#x3D;&quot;mainKeysMenu&quot;)  # 从当前菜单添加cmds.menuSet(cms&#x3D;1,q&#x3D;1 ) #  设置当前激活的菜单，只是激活，不刷新显示cmds.menuSet (ams&#x3D;True,q&#x3D;True)  # 所有的菜单集cmds.menuSet(rm&#x3D;&quot;mainKeysMenu&quot;)  # 从当前菜单移除currentmenus &#x3D; cmds.menuSet(query&#x3D;True, menuArray&#x3D;True)  # 查询当前流单集中所有的菜单项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建状态栏菜单"><a href="#创建状态栏菜单" class="headerlink" title="创建状态栏菜单"></a>创建状态栏菜单</h4><p>状态行只需要为控件指定父级窗口为”statusFieldButton”即可。</p><p><img src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E7%8A%B6%E6%80%81%E6%A0%8F.png" alt="状态栏.png" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E7%8A%B6%E6%80%81%E6%A0%8F.png" class="lozad post-image">  </p><p>示例代码：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds cmds.iconTextButton(&quot;状态行名称1&quot;,l&#x3D;&quot;标签1&quot;,style&#x3D;&quot;textOnly&quot;,al&#x3D;&#39;center&#39;,p&#x3D;cmds.iconTextButton(&quot;statusFieldButton&quot;,q&#x3D;1,p&#x3D;1))cmds.button(&quot;状态行名称2&quot;,l&#x3D;&quot;标签2&quot;,al&#x3D;&#39;center&#39;,p&#x3D;cmds.iconTextButton(&quot;statusFieldButton&quot;,q&#x3D;1,p&#x3D;1))cmds.nodeIconButton(&quot;状态行名称3&quot;, label&#x3D;&quot;标签3&quot; , style&#x3D;&#39;iconAndTextHorizontal&#39;, command&#x3D;&#39;cmds.spotLight()&#39;, image1&#x3D;&#39;spotlight.png&#39;,p&#x3D;cmds.iconTextButton(&quot;statusFieldButton&quot;,q&#x3D;1,p&#x3D;1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建侧栏工具页"><a href="#创建侧栏工具页" class="headerlink" title="创建侧栏工具页"></a>创建侧栏工具页</h4><p>侧栏工具页通过 toolBar 控件生成，创建后可指定吸附到边界上。</p><p><img src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E4%BE%A7%E6%A0%8F%E5%B7%A5%E5%85%B7%E9%A1%B5.png" alt="侧栏工具页.png" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E4%BE%A7%E6%A0%8F%E5%B7%A5%E5%85%B7%E9%A1%B5.png" class="lozad post-image">  </p><p>示例代码：<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds myWindow&#x3D;cmds.window()buttonForm &#x3D; cmds.formLayout( parent &#x3D; myWindow)cmds.button( parent &#x3D; buttonForm,l&#x3D;&quot;testSide&quot;)cmds.toolBar( area&#x3D;&#39;top&#39;, content&#x3D;myWindow, allowedArea&#x3D;[&#39;top&#39;, &#39;bottom&#39;, &quot;left&quot;, &quot;right&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="创建工具架分页："><a href="#创建工具架分页：" class="headerlink" title="创建工具架分页："></a>创建工具架分页：</h4><p>工具架分页由cmds.shelfLayout()创建，将创建的工具架分页的父级指向shelf主窗口，然后在shelfLayout下创建工具按钮即可：</p><p><img src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E5%B7%A5%E5%85%B7%E6%9E%B6%E5%88%86%E9%A1%B5.png" alt="工具架分页.png" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E4%B8%AD%E5%88%9B%E5%BB%BAUI/%E5%B7%A5%E5%85%B7%E6%9E%B6%E5%88%86%E9%A1%B5.png" class="lozad post-image">  </p><p>示例代码：<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.mel as mmimport maya.cmds as cmdsmainTopShelfTab &#x3D; mm.eval(&#39;global string $gShelfTopLevel;string $a&#x3D;$gShelfTopLevel;&#39;)# 获取工具架顶级布局newShelfLayout &#x3D; cmds.shelfLayout(&quot;NewLayout&quot;,p&#x3D;mainTopShelfTab)  # 创建工具架分页newToolButton &#x3D; cmds.shelfButton(&quot;testShelf&quot;,docTag&#x3D;u&quot;测试工具&quot;,rpt&#x3D;1,l&#x3D;&quot;工具&quot;,i1 &#x3D; r&quot;S:&#x2F;icon&#x2F;TDtool.ico&quot;,iol&#x3D;&quot;工具&quot;,c&#x3D;&#39;print(u&quot;测试&quot;)&#39;,p&#x3D;newShelfLayout)  # 添加工具按钮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>一些常用代码：<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">mainTopShelfTab &#x3D; mm.eval(&#39;global string $gShelfTopLevel;string $a&#x3D;$gShelfTopLevel;&#39;)  # 获取工具架顶级布局shelfnum &#x3D; cmds.shelfTabLayout(mainTopShelfTab,q&#x3D;1,numberOfChildren&#x3D;1)  # 获取指定工具架窗口的工具数量shelfTools &#x3D; cmds.shelfTabLayout(mainTopShelfTab,q&#x3D;1,ca&#x3D;1) # 获取工具架上所有工具栏shelf_fullname &#x3D; cmds.shelfLayout(shelfTool[2],q &#x3D; 1,fpn &#x3D; 1)  # 获取指定名称的工具架全路径shelfVisible &#x3D; cmds.shelfButton(&quot;testShelf&quot;,e&#x3D;1,visible&#x3D;0) # 设置工具按钮可见性maya.mel.eval(&#39;addNewShelfTab &quot;test&quot;&#39;)  # 添加指定名称工具架页maya.mel.eval(&#39;deleteShelfTab &quot;test&quot;&#39;)  #删除指定个名称工具架<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>从maya文档中加载默认工具架及其按钮：<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">#注意此脚本会将一部分默认不加载的工具架也加载到maya工具架下 def get_shelf():  &quot;&quot;&quot;获取maya安装目录下shelf&quot;&quot;&quot;  shelf_files &#x3D; []  maya_shelf_path &#x3D; &#39;&#123;&#125;&#x2F;scripts&#x2F;shelves&#39;.format(os.getenv(&#39;MAYA_LOCATION&#39;))  files &#x3D; os.listdir( maya_shelf_path)  if files:      for _file in files:          if &quot;_&quot; in _file and &quot;.&quot; in _file and &quot;.res.&quot; not in _file:              shelf_files.append(_file.split(&#39;.&#39;)[0].split(&#39;_&#39;)[-1])  return shelf_filesdef load_shelf():  &quot;&quot;&quot;加载maya默认shelf&quot;&quot;&quot;  allShelfs &#x3D; mel.eval(&#39;shelfTabLayout -q -childArray $gShelfTopLevel&#39;) # 获取maya默认shelfs  maya_files &#x3D; get_shelf()  if maya_files:      for _shelf in maya_files:          if _shelf not in allShelfs:              mel.eval(&#39;loadNewShelf &quot;shelf_&#123;&#125;.mel&quot;;&#39;.format(_shelf))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>循环删除指定工具架下的按钮：<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">def remove button (self,shelf):    &quot;&quot;&quot;批量删除指定工具架下的工具&quot;&quot;&quot;&quot;    shelf_fullname &#x3D; cmds.shelfLayout (&quot;shelfname&quot;,q&#x3D;1,fpn&#x3D;1)   buttons &#x3D; cmds.shelfLayout(shelf_fullname,q &#x3D; 1,ca &#x3D; 1)    for _button in buttons:        button_fullname &#x3D; cmds.shelfButton(_button,q &#x3D;1,fpn &#x3D;1)        cmds.deleteUI( button_fullname)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>删除指定的工具架，方法改自deleteShelfTab，会删除一些首选项中存储的变量：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import osimport maya.cmds as cmdsimport maya.mel as mm def remove_shelf(_shelfname):    mainTopShelfTab &#x3D; mm.eval(&#39;global string $gShelfTopLevel;string $a&#x3D;$gShelfTopLevel;&#39;)    shelf_info &#x3D; &#123;i: _shelf for i, _shelf in enumerate(cmds.shelfTabLayout(mainTopShelfTab, q&#x3D;1, ca&#x3D;1))                   if _shelf.split(&quot;|&quot;)[-1].startswith(_shelfname[:2])&#125;    shelfnum&#x3D; cmds.shelfTabLayout(mainTopShelfTab, q&#x3D;1, numberofChildren&#x3D;1)    if shelf_info:        for _k,_v in shelf_info.items():            if _v &#x3D;&#x3D; _shelfname:                shelf_fullname &#x3D; cmds.shelfLayout(_v, q&#x3D;1, fpn&#x3D;1)                for _i in range(shelfnum):                    _align_c &#x3D; &quot;left&quot;                    if cmds.optionVar(ex&#x3D;&quot;shelfAlign&#123;&#125;&quot;.format(_i+1)):                        _align_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfAlign&#123;&#125;&quot;.format(_i+1))                    _shelfload_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfLoad&#123;&#125;&quot;.format(_i+1))                    _shelfname_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfName&#123;&#125;&quot;.format(_i+1))                    _shelffile_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfFile&#123;&#125;&quot;.format(_i+1))                    cmds.optionVar(                        iv&#x3D;(&quot;shelfLoad&#123;&#125;&quot;.format(_i+1), _shelfload_c),                        sv&#x3D;[(&quot;shelfAlign&#123;&#125;&quot;.format(_i+1), _align_c),                            (&quot;shelfName&#123;&#125;&quot;.format(_i+1), _shelfname_c),                            (&quot;shelfFile&#123;&#125;&quot;.format(_i+1), _shelffile_c)                            ])                cmds.optionVar(remove &#x3D;[&quot;shelfLoad&#123;&#125;&quot;.format(_k),                                        &quot;shelfAlign&#123;&#125;&quot;.format(_k),                                        &quot;shelfName&#123;&#125;&quot;.format(_k),                                        &quot;shelfFile&#123;&#125;&quot;.format(_k)                                        ])                cmds.deleteUI(shelf_fullname, layout&#x3D;1)                shelfDir &#x3D; cmds.internalVar(ush&#x3D;1)                shelfFile &#x3D; os.path.join(shelfDir, &quot;shelf_&#123;&#125;.mel&quot;.format(_v))                if os.path.exists(shelfFile):                    os.remove(shelfFile)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除UI"><a href="#删除UI" class="headerlink" title="删除UI"></a>删除UI</h4><p>删除UI需要知道窗口的窗口名称：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds cmds.deleteUI(&quot;windowName&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;在maya中创建各种UI</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="小工具" scheme="http://mirrorcg.github.io/categories/Maya/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="QT事件" scheme="http://mirrorcg.github.io/tags/QT%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python代码中的字符编码</title>
    <link href="http://mirrorcg.github.io/posts/20220822a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220822a1.html</id>
    <published>2022-08-22T14:52:29.000Z</published>
    <updated>2022-08-22T15:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Python 中的字符编码 <span id="more"></span></p><h4 id="文本编辑器存储信息的过程"><a href="#文本编辑器存储信息的过程" class="headerlink" title="文本编辑器存储信息的过程"></a>文本编辑器存储信息的过程</h4><ol><li><p>打开编辑器就在内存中开辟了一个空间，用编辑器编写的内容暂存在内存中，断电会丢失。</p></li><li><p>保存时，编辑器把内存的Unicode数据通过某种编码格式存到了硬盘上。</p></li><li><p>编写.py文件（没有执行时）和编写其他文件没有区别，只是在写一堆字符。</p></li></ol><h4 id="python解释器解释python代码的流程"><a href="#python解释器解释python代码的流程" class="headerlink" title="python解释器解释python代码的流程"></a>python解释器解释python代码的流程</h4><ol><li><p>python解释器启动，相当于启动了一个文本编辑器。</p></li><li><p>python解释器相当于文本编辑器，打开test.py文件，从硬盘将test.py文件通过某种编码格式（gbk,utf8等）解码数据从硬盘读入到内存中（python的解释性决定了解释器只关心文件的内容，不关心文件的后缀）。</p></li><li><p>python解释器解释执行加载到内存中的test.py代码。在该阶段才会识别python语法，为变量值等开辟存储空间。</p></li></ol><h4 id="Python2和Python3的区别"><a href="#Python2和Python3的区别" class="headerlink" title="Python2和Python3的区别"></a>Python2和Python3的区别</h4><ol><li><p>python2有两种存储形式，第一种：Unicode；第二种：按coding头选择存储格式，假设python2用utf8存储 x&#x3D;’中文’，当你print(x)的时候，终端接收gbk的变量x，但是windows终端编码是utf8，会乱码。Python3 默认存储形式为utf-8。</p></li><li><p>字符串类型：Python2 unicode 和 str类型（gbk、utf-8、MP4、MP3、JPG）；Python3 str（Unicode字符串）和bytes类型（（gbk、utf-8、MP4、MP3、JPG））。</p></li><li><p>python3只有Unicode一种存储变量的形式。Python2中默认使用ascii，Python3中默认使用utf-8，部分文本编辑器编写的文件默认为gbk编码格式，需要注意编写代码时文本编辑器的默认编码格式。</p></li><li><p>Python2 解释器编码默认为ASCII，只能处理 ascii字符，如果代码中有中文会报错，所以需要在代码顶部添加下面一行声明，将代码文件编码声明修改为 utf-8。Python3 解释器默认编码为utf-8;可通过 sys.getdefaultencoding() 查询。</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-print(u&quot;测试中文打印&quot;.encode(&quot;gbk&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h4 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h4><p>  当字符串第一次写入文件时，文件创建成功，文件编码和字符串编码保持一致。如果后续写入其他编码的字符串，则文件编码会被修改，原来的数据会出现乱码。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>python bytes 也称字节序列，并非字符。取值范围 0 &lt;&#x3D; bytes &lt;&#x3D; 255，输出的时候最前面会有字符b修饰；string 是python中字符串类型;</p></li><li><p>bytes主要是给在计算机看的，string主要是给人看的；string经过编码encode，转化成二进制对象，给计算机识别；bytes经过解码decode，转化成string，让我们看，但是注意反编码的编码规则是有范围,\xc8就不是utf8识别的范围；</p></li><li><p>内存中固定使用Unicode编码，我们只能改变存储到硬盘时使用的编码格式。读文件时，读取文件采用的编码格式与文本原来的编码格式不同则会导致出现乱码。需注意文本编辑器的编码格式，这能直接影响编译器是否能正确编译程序文本文件。同时也要注意控制台的编码格式，其中Windows 默认的编码格式为gbk，因此某些字符需要转码后打印在控制台才不会是乱码：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-print(u&quot;测试中文打印&quot;.encode(&quot;gbk&quot;))print(unicode(&quot;测试中文打印&quot;，&quot;utf-8&quot;).encode(&quot;gbk&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>任何语言、任何操作系统、任何编码，都可以和Unicode编码通过decode()和encode()的方式互相转换。</p></li></ol><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><a href="https://www.cnblogs.com/yyxayz/p/4044528.html" title="" target="">1.Python的字符编码问题</a></br><a href="https://www.runoob.com/python3/python3-func-bytes.html" title="" target="">2.bytes()内建函数</a>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python 中的字符编码</summary>
    
    
    
    <category term="Python" scheme="http://mirrorcg.github.io/categories/Python/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="锦囊小妙招" scheme="http://mirrorcg.github.io/tags/%E9%94%A6%E5%9B%8A%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Lua脚本语言</title>
    <link href="http://mirrorcg.github.io/posts/20220821a2.html"/>
    <id>http://mirrorcg.github.io/posts/20220821a2.html</id>
    <published>2022-08-21T15:38:15.000Z</published>
    <updated>2022-08-21T15:38:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">脚本语言--Lua学习笔记。<span id="more"></span></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>菜鸟教程：<a href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-indent:2em&quot;&gt;脚本语言--Lua学习笔记。</summary>
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Doc/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Yeti毛发</title>
    <link href="http://mirrorcg.github.io/posts/20220821a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220821a1.html</id>
    <published>2022-08-21T15:09:17.000Z</published>
    <updated>2022-08-21T15:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了一些Maya中Yeti毛发的相关的问题：<span id="more"></span></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>对应的版本: yeti插件版本需要与arnold(或redshift渲染器)版本、maya版本相对应，否则不报错且无法使用</p></li><li><p>环境变量：需在 pgYetiMaya.mod写入环境变量的文件(一行一句)。C:\rlm\yeti.lic 为破解文件。</p><ul><li><ul><li>pgYetiMaya 3.6.0 C:\Yeti-v3.6.0_Maya2018-windows</li></ul></li><li>PATH +:&#x3D; bin</li><li>MTOA_EXTENSIONS_PATH +:&#x3D; plug-ins</li><li>ARNOLD_PLUGIN_PATH +:&#x3D; bin</li><li>YETI_DOCS +:&#x3D; docs</li><li>YETI_TMP &#x3D; C:\Yeti-v3.6.0_Maya2018-windows\tmp</li><li>PEREGRINE_LOG_FILE &#x3D; C:\Yeti-v3.6.0_Maya2018-windows\Yeti.log</li><li>YETI_GEOCACHE_SIZE &#x3D; 1024</li><li>YETI_TEXTURECACHE_SIZE &#x3D; 1024</li><li>YETI_HOME &#x3D; C:\Yeti-v3.6.0_Maya2018-windows</li><li>peregrinel_LICENSE &#x3D; C:\rlm\yeti.lic</li></ul></li><li><p>破解：yeti破解文件或通过rlm服务器破解</p></li></ul><h3 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h3><ol><li>yeti 与Arnold版本不匹配，需要下载相对应的各插件版本，具体参考yeti官网文档</li><li>yeti安装后未破解，打开yeti graph editer时会提示没有许可或工具不显示</li><li>yeti破解后没有成功建立和渲染器的链接，需要在上述对应的.mod文件中写入环境变量,成功写入环境变量后即可渲染</li><li>yeti插件与渲染器成功建立来链接后，开启Maya可能会出现.dll文件的报错没然后Maya卡死，该问题是maya环境中没有找到.dll与对应的渲染器，可能是没有安装，删除yeti安装目录文件夹bin下对应的.dll即可</li><li>渲染没有毛发：渲染器和yeti插件的链接没有接上。没有指定Yeti毛发缓存的存放路径YETI_TMP</li><li>“pgYetiMaya.mod”文件中不能有空行</li></ol><h3 id="制作和渲染问题"><a href="#制作和渲染问题" class="headerlink" title="制作和渲染问题"></a>制作和渲染问题</h3><ol><li><p>pgYetiPreRender:此代码用于指定yeti渲染前产生的yeti缓存文件存放位置，渲染时直接调用此路径下的.fur文件，若不在Maya渲染射中的中preRenderMel选项中填入此代码，则渲染器找不到生成的缓存，渲染失败。低版本中，此代码不会自动写入和自动清除，高版本会判定场景中是否存在相关yeti节点，然后自动写入或清除。</p></li><li><p>yeti毛发取消缓存(将input Mode 设置为None)，需要保存后重开文件，才能正常渲染出毛发。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录了一些Maya中Yeti毛发的相关的问题：</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="Yeti" scheme="http://mirrorcg.github.io/tags/Yeti/"/>
    
  </entry>
  
  <entry>
    <title>ShotGrid的API使用示例</title>
    <link href="http://mirrorcg.github.io/posts/20220814a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220814a1.html</id>
    <published>2022-08-14T10:46:39.000Z</published>
    <updated>2022-08-25T15:46:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">本文为 ShotGrid 的 Python API 学习笔记。<span id="more"></span></p><h3 id="注册网站"><a href="#注册网站" class="headerlink" title="注册网站"></a>注册网站</h3><p>如果已经有了自己可操作的 ShotGrid 网站页面，就直接开始吧。没有的话需要在 Autodesk 官网下找到<a href="https://www.shotgridsoftware.com/trial/" title="" target="">ShotGrid 注册</a>自己的 ShotGrid 网站页面，设置邮箱和电话号码后，获取登录账户和密码（可以获得30天的试用时间），就可以开始下面的操作了。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h5 id="最低要求"><a href="#最低要求" class="headerlink" title="最低要求"></a>最低要求</h5><ul><li>Python 2.7 或 Python 3.7</li></ul><h5 id="下载并写入Python搜索路径"><a href="#下载并写入Python搜索路径" class="headerlink" title="下载并写入Python搜索路径"></a>下载并写入Python搜索路径</h5><ul><li>手动下载<ul><li>下载 PythonAPI 库到本地：<a href="https://github.com/shotgunsoftware/python-api/releases" title="" target="">从这下载</a>最新版本到本地。</li><li>将下载的 PythonAPI 加入到 PYTHONPATH 环境变量中，用于我们在代码中可搜索到对应的模块。</li></ul></li><li>pip下载<ul><li>安装最新版本<pre class="language-dos" data-language="dos"><code class="language-dos">pip install git+https:&#x2F;&#x2F;github.com&#x2F;shotgunsoftware&#x2F;python-api.git</code></pre></li><li>安装特定版本<pre class="language-dos" data-language="dos"><code class="language-dos">pip install git+https:&#x2F;&#x2F;github.com&#x2F;shotgunsoftware&#x2F;python-api.git@v3.0.26</code></pre></li></ul></li></ul><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>直接使用用户名和密码，用户身份登录的脚本操作，会生成事件，其中存储了一些额外的元数据，EventLogEntry用于标识事件是由代表用户的脚本创建的。<br><img src="/images/ShotGrid%E7%9A%84API%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/%E4%BA%8B%E4%BB%B6%E7%94%9F%E6%88%90%E6%8E%A7%E5%88%B6.png" alt="事件生成控制 png" srcset="/images/home/Myhead.jpg" data-src="/images/ShotGrid%E7%9A%84API%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/%E4%BA%8B%E4%BB%B6%E7%94%9F%E6%88%90%E6%8E%A7%E5%88%B6.png" class="lozad post-image"><br>而使用脚本身份验证登录前，必须在Shotgun 中注册 (User&gt;Scripts)并具有有效的 API 密钥 (密钥需要在创建的时候记录下来，创建完后不再显示).</p><ul><li><p>基于用户名登陆验证</p><pre class="language-none"><code class="language-none">sg &#x3D; shotgun_api3.Shotgun(&quot;https:&#x2F;&#x2F;piedpiper.shotgunstudio.com&quot;,                        login&#x3D;&quot;rhendriks&quot;,                        password&#x3D;&quot;c0mPre$Hi0n&quot;)</code></pre></li><li><p>基于脚本登录验证</p><pre class="language-none"><code class="language-none">sg &#x3D; shotgun_api3.Shotgun(&quot;https:&#x2F;&#x2F;piedpiper.shotgunstudio.com&quot;,                        script_name&#x3D;&quot;rhendriks&quot;,                        api_key&#x3D;&quot;c0mPre$Hi0n&quot;)</code></pre></li></ul><h3 id="查询内容"><a href="#查询内容" class="headerlink" title="查询内容"></a>查询内容</h3><p>查询结果默认返回查询对象的id,字段中的实体通过id连接，如果使用实体作为过滤项（过滤条件有大括号），每个filter中的实体都应该包含实体的id，这个实体用于筛选查询的范围，那么必须使用实体的id进行过滤，不能使用名称或其他条件，例如[ “shot”,”is”,{“type”:”Shot”,”id”:1173}]；如果过滤项不是实体，那么可以使用名称或其他字段进行过滤，但必须使用点语法（链式调用），例如[ “shot.Shot.code”,”is”,”seq110”]。点语法用于查询点语法中使用的实体以外的实体，例如，project.Project.name为点语法的项目名，只能通过项目名查场次和镜头等，不能用它查询项目本身。查询本身不用点语法，直接使用shotgun.find(“Project”,[ “name”，”is”，”Test_Fly”],[])；点语法：”fieldname.entityname.fieldname.entityname.fieldname…” 只能单实体关系使用语法，由于性能问题，一个字段链接了多个实体时，不能通过点语法获得结果，需要遍历获取。不显示字段代码名称的字段，可以从filed &gt; 右键菜单 &gt; ConfigField 中获取field code名称</p><ul><li><p>查询所有项目</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_project &#x3D; sg.find(&quot;Project&quot;, [], [&quot;id&quot;, &quot;name&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询指定名称的项目(默认返回id)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_project &#x3D; sg.find(&quot;Project&quot;, [[&#39;name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询指定项目所有的场次(通过项目id获取，可直接使用查询到的实体获取相关内容)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_project &#x3D; sg.find(&quot;Project&quot;, [[&#39;name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])[0][&quot;id&quot;]sg_sequence &#x3D; sg.find(&quot;Sequence&quot;, [[&#39;project&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: sg_project&#125;]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询指定项目的场次(通过项目名称获取,使用点语法)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_sequence &#x3D; sg.find(&quot;Sequence&quot;, [[&#39;project.Project.name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定项目的所有镜头(通过项目名称获取)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_shot &#x3D; sg.find(&quot;Shot&quot;, [[&#39;project.Project.name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定场次的所有镜头(通过场次id获取)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_shot1 &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;, &quot;is&quot;, &#123;&quot;type&quot;:&quot;Sequence&quot;, &quot;id&quot;:44&#125;]], [ &quot;code&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定场次的状态为IP所有镜头(通过场次id获取)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_shot2 &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;,&quot;is&quot;, &#123;&quot;type&quot;:&quot;Sequence&quot;,&quot;id&quot;:44&#125;]，[&quot;sg_status_list&quot;, &quot;is&quot;, &quot;ip&quot;]],[ &quot;code&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定场次的状态为IP所有镜头(通过场次名称和项目共同筛选获取)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_shot3 &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Sequence&quot;,&quot;Sequence Name&quot;:&quot;seq001&quot;&#125;],[&quot;sg_status_list&quot;, &quot;is&quot;, &quot;ip&quot;], [&#39;project&#39;, &#39;is&#39;,&#123;&#39;type&#39;:&#39;Project&#39;,&#39;id&#39;:122&#125;]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定场次的状态为IP所有镜头(通过场次名称和项目共同筛选获取)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_shots &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Sequence&quot;,&quot;Sequence Name&quot;:&quot;seq001&quot;&#125;],[&quot;sg_status_list&quot;, &quot;is&quot;, &quot;ip&quot;], [&#39;project&#39;, &#39;is&#39;,&#123;&#39;type&#39;:&#39;Project&#39;,&#39;id&#39;:122&#125;]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定镜头的资产</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">project_id &#x3D; 122sequence_id &#x3D; 182filter &#x3D;  [  [&#39;project&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: project_id&#125;],  [&#39;sg_asset_type&#39;, &#39;is&#39;, &#39;Character&#39;],  [&#39;sequences&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Sequence&#39;, &#39;id&#39;: sequence_id&#125;]] fields &#x3D; [&#39;id&#39;, &#39;code&#39;, &#39;sg_asset_type&#39;]asset &#x3D; sg.find(&quot;Asset&quot;, filter, fields)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取指定类型的资产</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fields &#x3D; [&#39;id&#39;, &#39;sg_asset_type&#39;, &#39;code&#39;]filters &#x3D; [  [&#39;project&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;:122&#125;],  [&#39;sequence&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Sequence&#39;, &#39;id&#39;: 145&#125;],  [&#39;sg_asset_type&#39;, &#39;is&#39;, &#39;Character&#39;]]Character &#x3D; sg.find(&#39;Asset&#39;, filters, fields)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>计算指定Sequence里所有的任务数量，并找到其中最近截止日期</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">entity_type&#x3D;&#39;Task&#39;filter &#x3D; [[&#39;entity.Shot.sg_sequence&#39;, &#39;is&#39;, &#123;&#39;type&#39;:&#39;Sequence&#39;, &#39;id&#39;:2&#125;],[&#39;sg_status_list&#39;, &#39;is_not&#39;, &#39;na&#39;]]summary_field &#x3D; [&#123;&#39;field&#39;:&#39;id&#39;, &#39;type&#39;:&#39;count&#39;&#125;,&#123;&#39;field&#39;:&#39;due_date&#39;,&#39;type&#39;:&#39;latest&#39;&#125;]result &#x3D; sg.summarize(entity_type,filter,summary_field)#最近的截至日期，和当前场次所有任务的总数#&#123;&#39;groups&#39;: [], &#39;summaries&#39;: &#123;&#39;due_date&#39;: &#39;2013-07-05&#39;, &#39;id&#39;: 30&#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取指定 Version id 的mov</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">mov &#x3D; sg.find(&quot;Version&quot;, [&quot;id&quot;, &quot;is&quot;, 12321], [ &quot;sg_uploaded_movie&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询所有的工作流环节</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pipeline &#x3D; shotgun.find(&quot;Step&quot;,[ ],[ &quot;code&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询指定工作流环节</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotgun.find(&quot;Step&quot;,[ &quot;code&quot;，&quot;is&quot;，&quot;Animation&quot;],[])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询指定id的镜头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotgun.find(&quot;Shot&quot;,[ &quot;id&quot;，&quot;is&quot;，&quot;1207&quot;],[ &quot;code&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定镜头的指定环节的task信息（task是单独的，筛选它的link字段为entity，因此下面是筛选link字段中id为1207的镜头。注意，过滤器的第三项是要过滤的实体的话，必须使用实体id）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotgun.find(&quot;Task&quot;,[[ &quot;entity&quot;，&quot;is&quot;，&#123;&quot;type&quot;:&quot;shot&quot;,&quot;id&quot;:1207&#125;],[ &quot;shot&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Shot&quot;,&quot;id&quot;:1174&#125;],[ &quot;content&quot;,&quot;is&quot;,&quot;anim&quot;]],[])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定镜头、指定环节、指定名称的task信息</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotgun.find(&quot;Task&quot;,[[ &quot;entity&quot;，&quot;is&quot;，&#123;&quot;type&quot;:&quot;shot&quot;,&quot;id&quot;:1207&#125;],[ &quot;shot&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Shot&quot;,&quot;id&quot;:1174&#125;],[ &quot;content&quot;,&quot;is&quot;,&quot;anim&quot;]],[])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="下载mov"><a href="#下载mov" class="headerlink" title="下载mov"></a>下载mov</h3><p>下载指定 Version id 的mov<br>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">mov &#x3D; sg.find(&quot;Version&quot;, [&quot;id&quot;, &quot;is&quot;, 12321], [&quot;sg_uploaded_movie&quot;])localpath &#x3D; r&quot;E:\temp&quot; + mov[&quot;sg_uploaded_movie&quot;][&quot;name&quot;]sg.download_attachment(version[&quot;sg_uploaded_movie&quot;], file_path&#x3D;local_file_path)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h3 id="创建内容"><a href="#创建内容" class="headerlink" title="创建内容"></a>创建内容</h3><ul><li><p>创建镜头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotname &#x3D; &quot;test001&quot;data &#x3D; &#123;  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,  &#39;sg_sequence&#39;: &#123;&#39;type&#39;: &#39;Sequence&#39;, &#39;id&#39;: 145&#125;,  &#39;code&#39;: shotname,  &#39;sg_status_list&#39;: &#39;ip&#39;&#125;shot &#x3D; sg.create(&#39;Shot&#39;, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在镜头的pipeline步环节下创建task(一个流程环节可以有多个任务)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">animationStepId &#x3D; 106shotId &#x3D; 1173 data &#x3D; &#123;  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,  &#39;content&#39;: &#39;anim&#39;, # 任务名  &#39;step&#39;: &#123;&#39;name&#39;: &#39;Animation&#39;, &#39;type&#39;: &#39;Step&#39;, &#39;id&#39;: animationStepId&#125;,  &#39;entity&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: shotId&#125;&#125;task &#x3D; sg.create(&#39;Task&#39;, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Task下创建Version</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">taskCode &#x3D; &#39;testVersion_v001&#39;shotId &#x3D; 1173 taskId &#x3D; 5964data &#x3D; &#123;  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,  &#39;code&#39; : taskCode,  &#39;sg_status_list&#39; : &#39;rev&#39;,  &#39;entity&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: shotId&#125;,   &#39;sg_task&#39;: &#123;&#39;type&#39;: &#39;Task&#39;, &#39;id&#39;: taskId&#125;,   &#39;user&#39;: &#123;&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 220&#125; # 创建Version的人员&#125;version &#x3D; sg.create(&#39;Version&#39;, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建带有镜头和任务链接的版本</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">shotID &#x3D; 1173taskID &#x3D; 5964 data &#x3D; &#123; &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;,&#39;id&#39;: 122&#125;,        &#39;code&#39;: &#39;100_010_anim_v1&#39;,        &#39;description&#39;: &#39;first pass at opening shot with bunnies&#39;,        &#39;sg_path_to_frames&#39;: &#39;&#x2F;v1&#x2F;gun&#x2F;s100&#x2F;010&#x2F;frames&#x2F;anim&#x2F;100_010_animv1_jack.#.jpg&#39;,        &#39;sg_status_list&#39;: &#39;rev&#39;,        &#39;entity&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;:  shotID&#125;,        &#39;sg_task&#39;: &#123;&#39;type&#39;: &#39;Task&#39;, &#39;id&#39;: taskID&#125;,        &#39;user&#39;: &#123;&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 165&#125; &#125; result &#x3D; sg.create(&#39;Version&#39;, data) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用任务模板创建任务</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">filters &#x3D; [[&#39;code&#39;,&#39;is&#39;, &#39;3D Shot Template&#39; ]]taskTemplate &#x3D; sg.find_one(&#39;TaskTemplate&#39;, filters)  # 查找任务模板taskId &#x3D; 5964data &#x3D; &#123;&#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;,&#39;id&#39;: 122&#125;,      &#39;code&#39;: &#39;seq001_sc001&#39;,      &#39;description&#39;: &#39;creating a task with taskTemplate&#39;,      &#39;task_template&#39;: template &#125;result &#x3D; sg.create(&#39;Shot&#39;, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建自定义实体 Entity(查找方式和查找别的实体一样)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data &#x3D; &#123;  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,  &#39;code&#39;: &#39;test_plate_v001&#39;,  &#39;sg_shot&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: 1173&#125;,  &#39;updated_by&#39;: &#123;&#39;type&#39;: &#39;Group&#39;, &#39;id&#39;: 3&#125;, # 更新用户为群组  &#39;sg_original_resolution&#39;: &#39;1920x1080&#39;,  &#39;sg_plate_type&#39;: &#39;BG01&#39;,  &#39;sg_frames_scanned&#39;: 150,  &#39;sg_scan_start&#39;: 1,  &#39;sg_scan_end&#39;: 150&#125;plate &#x3D; sg.create(&#39;CustomEntity10&#39;, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>上传缩略图</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">versionID &#x3D; 214picPath &#x3D; &quot;&#x2F;v1&#x2F;gun&#x2F;s100&#x2F;010&#x2F;beauties&#x2F;anim&#x2F;100_010_animv1.jpg&quot;sg.upload_thumbnail(&quot;Version&quot;, versionID, picPath)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h3><ul><li><p>更新镜头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotId &#x3D; 1173data &#x3D; &#123;  &#39;description&#39;: &#39;Open on a beautiful field with fuzzy bunnies&#39;,  &#39;sg_status_list&#39;: &#39;ip&#39;  &#125;result &#x3D; sg.update(&#39;Shot&#39;, shotId, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>更新Mov到镜头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotId &#x3D; 423mov_file &#x3D; &#39;&#x2F;data&#x2F;show&#x2F;ne2&#x2F;100_110&#x2F;anim&#x2F;01.mlk-02b.mov&#39;sg.upload(&quot;Shot&quot;, shotId, mov_file, field_name&#x3D;&quot;sg_latest_quicktime&quot;, display_name&#x3D;&quot;Latest QT&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h3><ul><li><p>删除指定id的project实体</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sg_delete &#x3D; sg.delete(&quot;Project&quot;,155)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除指定镜头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shotId &#x3D; 1173result &#x3D; sg.delete(&quot;Shot&quot;,shotId)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="恢复内容"><a href="#恢复内容" class="headerlink" title="恢复内容"></a>恢复内容</h3><ul><li>恢复删掉的镜头<pre class="line-numbers language-python" data-language="python"><code class="language-python">shotId &#x3D; 1173sg.revive(&quot;Shot&quot;, shotId)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="批量处理（创建，删除，更新）镜头"><a href="#批量处理（创建，删除，更新）镜头" class="headerlink" title="批量处理（创建，删除，更新）镜头"></a>批量处理（创建，删除，更新）镜头</h3><p>使用batch函数的任务，要么全部完成，要么全都不完成</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">batch_data &#x3D; []for i in range(1,100):    data &#x3D; &#123;        &quot;code&quot;: &quot;shot_%04d&quot; % i,        &quot;project&quot;: project    &#125;    batch_data.append(&#123;&quot;request_type&quot;: &quot;create&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;data&quot;: data&#125;)sg.batch(batch_data)  batch_data &#x3D; [  &#123;&quot;request_type&quot;: &quot;create&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;data&quot;: &#123;&quot;code&quot;: &quot;New Shot 1&quot;, &quot;project&quot;: project&#125;&#125;,  &#123;&quot;request_type&quot;: &quot;update&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 3624, &quot;data&quot;: &#123;&quot;code&quot;: &quot;Changed 1&quot;&#125;&#125;,  &#123;&quot;request_type&quot;: &quot;delete&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 3624&#125;]sg.batch(batch_data) # 三种不同类型可同时存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关闭链接"><a href="#关闭链接" class="headerlink" title="关闭链接"></a>关闭链接</h3>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">sg.close()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="部分可查询实体类型"><a href="#部分可查询实体类型" class="headerlink" title="部分可查询实体类型"></a>部分可查询实体类型</h3><table><thead><tr><th align="right">实体类型名称</th><th align="left">实体含义</th></tr></thead><tbody><tr><td align="right">ActionMenuItem</td><td align="left">动作菜单</td></tr><tr><td align="right">ApiUser</td><td align="left">脚本</td></tr><tr><td align="right">Asset</td><td align="left">资产</td></tr><tr><td align="right">Attachment</td><td align="left">附件</td></tr><tr><td align="right">Booking</td><td align="left">人员规划</td></tr><tr><td align="right">Camera</td><td align="left">摄像机</td></tr><tr><td align="right">ClientUser</td><td align="left">客户</td></tr><tr><td align="right">Composition</td><td align="left">合成</td></tr><tr><td align="right">Cut</td><td align="left">剪辑镜头</td></tr><tr><td align="right">CutItem</td><td align="left">剪辑镜头项</td></tr><tr><td align="right">Delivery</td><td align="left">分发</td></tr><tr><td align="right">Department</td><td align="left">部门</td></tr><tr><td align="right">Episode</td><td align="left">季</td></tr><tr><td align="right">EventLogEntry</td><td align="left">事件日志</td></tr><tr><td align="right">FilesystemLocation</td><td align="left">文件系统位置</td></tr><tr><td align="right">Group</td><td align="left">组</td></tr><tr><td align="right">HumanUser</td><td align="left">人员</td></tr><tr><td align="right">Icon</td><td align="left">图标</td></tr><tr><td align="right">Level</td><td align="left">关卡</td></tr><tr><td align="right">LocalStorage</td><td align="left">本地存储</td></tr><tr><td align="right">MocapPass</td><td align="left">动作捕捉过程</td></tr><tr><td align="right">MocapSetup</td><td align="left">动作捕捉设置</td></tr><tr><td align="right">MocapTake</td><td align="left">动作捕捉条目</td></tr><tr><td align="right">MocapTakeRange</td><td align="left">动作捕捉条目范围</td></tr><tr><td align="right">Note</td><td align="left">反馈，记录</td></tr><tr><td align="right">Page</td><td align="left">页面</td></tr><tr><td align="right">PageHit</td><td align="left">页面点击</td></tr><tr><td align="right">PageSetting</td><td align="left">页面设置</td></tr><tr><td align="right">Performer</td><td align="left">演员</td></tr><tr><td align="right">PermissionRuleSet</td><td align="left">权限组设置</td></tr><tr><td align="right">Phase</td><td align="left">项目时间表</td></tr><tr><td align="right">PhysicalAsset</td><td align="left">实拍道具</td></tr><tr><td align="right">PipelineConfiguration</td><td align="left">工作流工序配置</td></tr><tr><td align="right">Playlist</td><td align="left">播放表单</td></tr><tr><td align="right">PlaylistShare</td><td align="left">共享的播放表单</td></tr><tr><td align="right">Project</td><td align="left">项目</td></tr><tr><td align="right">PublishedFile</td><td align="left">已发布文件</td></tr><tr><td align="right">PublishedFileDependency</td><td align="left">已发布文件依存关系</td></tr><tr><td align="right">PublishedFileType</td><td align="left">已发布文件类型</td></tr><tr><td align="right">Release</td><td align="left">软件发布版本</td></tr><tr><td align="right">Reply</td><td align="left">回复</td></tr><tr><td align="right">Revision</td><td align="left">修正版本</td></tr><tr><td align="right">Routine</td><td align="left">运动捕捉例程</td></tr><tr><td align="right">RvLicense</td><td align="left">RV许可证</td></tr><tr><td align="right">Scene</td><td align="left">场</td></tr><tr><td align="right">Sequence</td><td align="left">本</td></tr><tr><td align="right">ShootDay</td><td align="left">拍摄日期</td></tr><tr><td align="right">Shot</td><td align="left">镜头</td></tr><tr><td align="right">Software</td><td align="left">DCC软件</td></tr><tr><td align="right">Status</td><td align="left">状态</td></tr><tr><td align="right">Step</td><td align="left">工作流工序</td></tr><tr><td align="right">Tag</td><td align="left">标签</td></tr><tr><td align="right">Task</td><td align="left">任务</td></tr><tr><td align="right">TaskDependency</td><td align="left">任务依存关系</td></tr><tr><td align="right">TaskTemplate</td><td align="left">任务模版</td></tr><tr><td align="right">Ticket</td><td align="left">软件开发工单</td></tr><tr><td align="right">TimeLog</td><td align="left">工时记录</td></tr><tr><td align="right">Version</td><td align="left">版本</td></tr></tbody></table><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>ShotGrid API文档：<a href="https://developer.shotgridsoftware.com/python-api/">https://developer.shotgridsoftware.com/python-api/</a><br>用户帮助文档：<a href="https://shotgunsoftware.zendesk.com/hc/zh-cn">https://shotgunsoftware.zendesk.com/hc/zh-cn</a><br>站点状态查询网站：<a href="https://status.shotgridsoftware.com/">https://status.shotgridsoftware.com/</a><br>shot教学视频：<a href="https://space.bilibili.com/399556599">https://space.bilibili.com/399556599</a></p>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-indent:2em&quot;&gt;本文为 ShotGrid 的 Python API 学习笔记。</summary>
    
    
    
    <category term="ShotGrid" scheme="http://mirrorcg.github.io/categories/ShotGrid/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/ShotGrid/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="API" scheme="http://mirrorcg.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Nuke学习笔记4_回调函数</title>
    <link href="http://mirrorcg.github.io/posts/20220807a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220807a1.html</id>
    <published>2022-08-07T12:41:35.000Z</published>
    <updated>2022-08-07T12:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h3 id="Nuke-API-文档"><a href="#Nuke-API-文档" class="headerlink" title="Nuke API 文档"></a>Nuke API 文档</h3><ul><li>本地文档：C:\Program Files\Nuke12.2v2\Documentation</li><li>在线文档：<a href="https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html">https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html</a><ul><li>Nuke Python Developers Guide: 案例教程</li><li>Python Scripting Reference： API 参考文档</li><li><a href="http://www.nukepedia.com/reference/Tcl/" title="" target="">TCL Scripting Reference: TCL 表达式参考文档</a></li></ul></li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>部分回调函数的使用</p><ul><li>添加回调函数<ul><li>nuke.toNode(“节点名”)[“knobChanged”].setValue(回调函数) 仅对选择的节点生效，此处回调函数是字符串格式</li><li>nuke.addOnCreate(callable,args&#x3D;(),kwargs&#x3D;{},nodeClass&#x3D;”*”)</li><li>callable 可调用对象</li><li>args 不定长位置参数列表</li><li>kwargs 不定长关键字参数字典</li><li>nodeClass 默认值是星号，指无论当前节点是什么，在事件发生时都会执行这个回调函数，需自定义</li></ul></li><li>删除回调函数</li><li>事件函数<ul><li><p>knobChanged 用户在打开的面版中改变knob后执行事件，可实现联动事件</p><ul><li>nuke.thisNode() 该控件在打开、关闭面板或输入端改变时，分别指向showPanel、hidePanel、inputChange事件，这三个控件使用代码获取不到，但可以在knobChange中使用控件名<pre class="language-Python" data-language="Python"><code class="language-Python">def testevent():    &quot;&quot;&quot;如果打开面板，打印内容&quot;&quot;&quot;    k&#x3D;nuke.thisKnob()    if k.name() &#x3D;&#x3D; &quot;showPanel&quot;:        print(&quot;show&quot;)nuke.addKnobChanged(testevent, nodeClass&#x3D;&quot;NoOp&quot;)</code></pre></li></ul></li><li><p>updateUI 任意UI发生变化后触发，比knobChange优先级低，不应在其中添加任何和回调结构有关的操作</p></li><li><p>autolabel 在updateUI之后执行，用于为节点设置在Node Grape中显示的文本 ，按照函数添加的顺序，从后往前执行，只要那个函数的返回值不是None，那么这个返回值就用于该节点的显示文本，若没有返回值或返回值为None,则使用节点名显示，该显示的文本和label标签不同。</p></li></ul></li></ul><p>回调函数执行顺序：<br>可以通过控件设置的回调函数 &gt; 使用注册回调函数添加的回调函数<br>使用注册回调函数添加的回调函数的优先级依赖注册的先后顺序，并先执行指定了nodeClass参数的回调，再执行满足所有类型的回调。addAutolabel()和addFilenameFilter()是特里，它们恰恰与之相反。<br>onCreate 对于Group节点，会先执行其中的内部节点，然后再在Group节点上执行一遍回调<br>onDestory事件和onCreate事件相反<br>onUserCreate执行优先级 &gt; onCreate执行优先级 </p><h3 id="部分回调函数"><a href="#部分回调函数" class="headerlink" title="部分回调函数"></a>部分回调函数</h3><table><tr><td><img src="/images/Nuke学习笔记4_回调函数/回调函数1.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记4_回调函数/回调函数1.png" class="lozad post-image"></td><td><img src="/images/Nuke学习笔记4_回调函数/回调函数2.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记4_回调函数/回调函数2.png" class="lozad post-image"></td></tr></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nuke学习笔记</summary>
    
    
    
    <category term="Nuke" scheme="http://mirrorcg.github.io/categories/Nuke/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Nuke/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Nuke学习笔记3_菜单的加载和界面</title>
    <link href="http://mirrorcg.github.io/posts/20220801a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220801a1.html</id>
    <published>2022-07-31T16:19:20.000Z</published>
    <updated>2022-07-31T16:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h3 id="Nuke-API-文档"><a href="#Nuke-API-文档" class="headerlink" title="Nuke API 文档"></a>Nuke API 文档</h3><ul><li>本地文档：C:\Program Files\Nuke12.2v2\Documentation</li><li>在线文档：<a href="https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html">https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html</a><ul><li>Nuke Python Developers Guide: 案例教程</li><li>Python Scripting Reference： API 参考文档</li><li>TCL Scripting Reference: TCL 表达式参考文档</li></ul></li></ul><h3 id="工具加载"><a href="#工具加载" class="headerlink" title="工具加载"></a>工具加载</h3><p>开启 nuke 时，系统会加载两个安装目录的Plugins文件夹下的两个文件：</p><ul><li>init.py : 用于Nuke的环境设置、系统选项和默认参数，不能包含任何界面相关操作，命令行模式和GUI模式下均加载。</li><li>menu.py ：用于跟界面相关的设置、自定义菜单、工具架，仅GUI模式加载。<br>位于用户文件夹下存放用户预设的.nuke文件夹，其下的init.py和menu.py用于存放用户预设。</li></ul><p>加载工具方式</p><ul><li>加载工具不运行：仅需要在init.py导入模块的主函数即可，再通过工具界面去调用主函数</li></ul><h3 id="加载工具相关函数"><a href="#加载工具相关函数" class="headerlink" title="加载工具相关函数"></a>加载工具相关函数</h3><ul><li>获取插件和图标的搜索路径 nuke.pluginPath()</li><li>向系统搜索路径添加路径到开头,并加载路径下的init.py nuke.pluginAddPath(“pathstr or pathList”)</li><li>向系统搜索路径添加路径到结尾,但不加载路径下的init.py nuke.pluginAppendPath(“pathstr or pathList”)</li><li>检测指定的函数或插件是否存在 nuke.pluginExists(“pluginName or path or fileName”)</li><li>返回所有已经加载的插件的文件路径列表 nuke.pligins(num,”re表达式过滤”，”re表达式过滤”，…)  num为 0，1，2，3</li></ul><h3 id="Nuke环境变量"><a href="#Nuke环境变量" class="headerlink" title="Nuke环境变量"></a>Nuke环境变量</h3><p>NUKE_PATH、OFX_PLUGIN_PATH都是列表后面的路径先加载，以反向解析加载路径的方式进行的，因此涉及继承和覆盖的通用配置需要放在列表后面，特殊和本地的配置放在列表开头。nuke.pluginPath是正向解析加载方式。</p><ul><li>NUKE_PATH 搜索 Nuke 的init.py 和menu.py文件的路径，可以将插件放在不同的位置，并且每一个插件都有各自的init.py和menu.py文件，就不用将所有插件都写入 .nuke 文件夹下的文件中，实现分布式管理</li><li>OFX_PLUGIN_PATH 用来设置和加载ofx插件的位置，指向ofx的安装路径</li></ul><h3 id="自定义菜单常用类型"><a href="#自定义菜单常用类型" class="headerlink" title="自定义菜单常用类型"></a>自定义菜单常用类型</h3><p>Nuke的菜单界面和Qt是两套体系,Nuke 界面不属于Qt范畴</p><ul><li>菜单栏工具<ul><li>nuke.menu(“Nuke”)</li></ul></li><li>工具栏工具<ul><li>nuke.menu(“Nodes”)</li></ul></li><li>NodeGraph中右键工具<ul><li>nuke.menu(“Node Graph”)</li></ul></li></ul><h3 id="自定义菜单函数"><a href="#自定义菜单函数" class="headerlink" title="自定义菜单函数"></a>自定义菜单函数</h3><ul><li><p>nuke.Menu 菜单类型</p><ul><li>nuke.menu(“Nuke”).findItem(“菜单项名称”) 查找指定菜单项 <ul><li>菜单项名称可以是相对于顶级菜单项的名称 nuke.menu(“Nuke”).findItem(“菜单项1&#x2F;菜单项2&#x2F;菜单项3”)</li></ul></li><li>nuke.menu(“Nuke”).menu(“菜单项名称”) 查找指定菜单项</li><li>nuke.Menu.items() 返回查询到的菜单项</li><li>nuke.menu(“Nuke”).addMenu(“新加项”，icon&#x3D;””,tooltip&#x3D;””,index&#x3D;””) 创建新菜单，其中新加项也是相对路径，index添加位置，默认为-1，只对要添加的最后一级菜单项有效  </li><li>nuke.menu(“Nuke”).addcommand(“新加项”,”脚本字符串”，“快捷键”，”icon”,”tooltip”，”index”) 添加菜单项命令，其中 “脚本字符串”可以为可执行的Python语句，或lambda函数，若没有指定命令，则会默认为创建一个名为新加项的节点。</li><li>nuke.menu(“Nuke”).removeItem(“删除项”) 删除指定的菜单，其中删除项不为相对路径，要删除指定项，需要从指定级的上一级删除，空菜单会自动删除</li><li>nuke.menu(“Nuke”).clearMenu() 删除菜单下的所有菜单项，也不支持相对路径，不会删除当前空菜单</li></ul></li><li><p>nuke.MenuItem 创建菜单项类</p><ul><li>nuke.menu(“Nuke”).findItem(“菜单项”).action() 获取QAction对象,其父对象是QMainWindow</li><li>nuke.menu(“Nuke”).findItem(“菜单项”).invoke() 直接执行menuItem，等同于nuke.menu(“Nuke”).findItem(“菜单项”).action().trigger()</li><li>nuke.menu(“Nuke”).findItem(“菜单项”).script() 返回对应的字符串，如果是lambda函数，其返回值是空</li><li>nuke.menu(“Nuke”).findItem(“菜单项”).setScript() 重新设置字符串</li></ul></li><li><p>nuke.menu(“菜单名”) 获取指定的根菜单，以下列出部分菜单名</p><ul><li>Nuke 菜单栏</li><li>Nodes 工具栏</li><li>Node Graph NodeGraph中的右键菜单</li><li>Viewer Viewer菜单</li><li>Properties 节点属性对话框中的右键菜单</li><li>Animation 动画控件和曲线编辑器右键菜单</li><li>Pane 界面中面板布局右键菜单</li><li>Axis 坐标右键菜单</li></ul></li></ul><h3 id="获取当前软件QT对象"><a href="#获取当前软件QT对象" class="headerlink" title="获取当前软件QT对象"></a>获取当前软件QT对象</h3><pre class="line-numbers language-pyhton" data-language="pyhton"><code class="language-pyhton">from Pyside2 import QtWidgetsallWin &#x3D; [w for w in QtWidgets.QApplication.instance().topLevelWidgets() if w.windowTitle() &#x3D;&#x3D; &quot;窗口提示&quot;]allMenu &#x3D; [w for w in allWin[0]children() if isinstance(w,QtWidgets.QMenuBar)]menubar &#x3D; allMenu[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nuke学习笔记</summary>
    
    
    
    <category term="Nuke" scheme="http://mirrorcg.github.io/categories/Nuke/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Nuke/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Nuke学习笔记2_节点与Knob</title>
    <link href="http://mirrorcg.github.io/posts/20220731a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220731a1.html</id>
    <published>2022-07-31T07:23:52.000Z</published>
    <updated>2022-08-23T16:26:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h3 id="Nuke-API-文档"><a href="#Nuke-API-文档" class="headerlink" title="Nuke API 文档"></a>Nuke API 文档</h3><ul><li>本地文档：C:\Program Files\Nuke12.2v2\Documentation</li><li>在线文档：<a href="https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html">https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html</a><ul><li>Nuke Python Developers Guide: 案例教程</li><li>Python Scripting Reference： API 参考文档</li><li>TCL Scripting Reference: TCL 表达式参考文档</li></ul></li></ul><h3 id="节点创建和删除"><a href="#节点创建和删除" class="headerlink" title="节点创建和删除"></a>节点创建和删除</h3><p>nuke节点的有可能有不同的版本，比如”Text”和”Text2”、 “Merge”和”Merge2”、”Tracher”和”Tracher3”以及”Tracher4”，默认情况下使用的是新版。右键 &gt; Other &gt; All Plugin &gt; Update，这个操作会扫面并加载所有可用的节点。bezier节点不能被扫描出来，可使用Roto代替,若一定要使用，可使用代码创建或使用 Comp Script Command（TCL） 快捷键（X）创建想要的节点。节点参数的键可以在Nuke中将鼠标悬停在参数选项上，显示的提示框的第一句就是参数的名称，参数的值可复制节点到文本编辑器中查询，有时参数可能设置不上，是Nuke的一些bug,需要寻找别的手段设置。前台模式适合在Gui模式下交互，并且创建的节点会默认连接到当前选择的节点下，若没有选中节点，则创建在鼠标最后一次点击的位置；后台模式更适合后台运行脚本，创建的节点的位置随机。</p><ul><li>创建节点：<ul><li>前台模式：nuke.createNode(“节点类型”) </li><li>后台模式：nuke.nodes.Read()</li></ul></li><li>创建节点时不弹出参数设置对话框：nuke.createNode(“节点类型”，inpanel&#x3D;False)</li><li>创建节点时设置参数：<ul><li>前台模式：nuke.createNode(“Text2”,”message ‘test’ yjustify center”)</li><li>后台模式：nuke.nodes.Read(message&#x3D;’test’, yjustify&#x3D;center)</li></ul></li><li>获取选中节点类型名：<ul><li>nuke.getNodeClassName()(选中状态的节点)</li><li>node &#x3D; createNode(“Text2”);node.Class()</li></ul></li><li>获取节点名：node.name()</li><li>删除节点：<ul><li>前台模式：nuke.delete(node)</li><li>后台模式：nuke.nodeDelete()(选中状态的节点)</li></ul></li></ul><h5 id="Read节点读取文件小技巧"><a href="#Read节点读取文件小技巧" class="headerlink" title="Read节点读取文件小技巧"></a>Read节点读取文件小技巧</h5><p>通过fromUserText方法读取视频文件，可以直接获取到视频文件的视频的长度。</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import nukereadNode &#x3D; nuke.nodes.Read()movPath &#x3D; r&quot;D:\mov\test.mov&quot;readNode[&#39;file&#39;].fromUserText(movpath)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是exr或者别的图片序列呢？<br>通过nuke.getFileNameList(path)方法可以获取到文件夹下的序列，进行自动分类，并返回一个字符串列表：</p><blockquote><p>[‘N.####.exr 1-15’, ‘Z.####.exr 1-7’, ‘beauty.####.exr 1-160’]</p></blockquote><p>创建read节点示例如下：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">import nukereadNode &#x3D; nuke.nodes.Read()exrPath &#x3D; r&quot;D:\image\beauty&quot;exrlist &#x3D; nuke.getFileNameList(exrPath)for _each in exrlist:    readNode &#x3D; nuke.nodes.Read()    readNode[&#39;file&#39;].fromUserText(&quot;%s&#x2F;%s&quot; % (exrPath,_each))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择和链接节点"><a href="#选择和链接节点" class="headerlink" title="选择和链接节点"></a>选择和链接节点</h3><ul><li>获取节点：nuke.toNode(“节点名”)</li><li>获取节点输入：<ul><li>获取所有输入端：nuke.inputs()</li><li>获取指定输入端：nuke.input(端口数字)</li></ul></li><li>链接节点：nuke.setInput(端口数字，nuke.toNode(“节点名”)) </li><li>获取所有节点：nuke.allNodes()</li><li>获取选中节点：<ul><li>仅返回最后一个被选中的节点 nuke.selectedNode() </li><li>返回主节点树中所有选中的节点 nuke.selectedNodes()</li></ul></li><li>选中以获得的节点<ul><li>将节点设置为选中状态 node &#x3D; createNode(“Text2”);node.setSelect(是否选中) 也可以传递参数设置选中状态</li><li>将当前节点设置为整个节点树中唯一被选中的状态 node.selectOnly()</li></ul></li><li>选中所有节点 nuke.selectAll()</li><li>选中满足模糊搜索节点名称的节点：nuke.selectPattern() 仅能在GUI模式下使用</li><li>选中与当前选中节点类似的节点：nuke.selectSimilar(“要匹配的类型”)<ul><li>选中有相似的类型 nuke.selectSimilar(nuke.MATCH_CLASS)</li><li>选中有相似的label标签 nuke.selectSimilar(nuke.MATCH_LABEL)</li><li>选中有相似的颜色 nuke.selectSimilar(nuke.MATCH_COLOR)</li></ul></li><li>将选中节点的上下游都设置为选中状态 nuke.selectConnectedNodes()</li><li>判断是否有被选中的节点 nuke.nodesSelected()</li><li>反向选择 nuke.invertSelection()</li><li>将节点从选中的节点中脱离出来 nuke.extractSelected()</li><li>克隆选中的节点 nuke.cloneSelected()</li><li>以递归形式清除节点的选中状态 nukescript.misc.clear_selection_recursive() 包括Gizmo 和 Group 中选中的节点也会被清除选中。</li></ul><h3 id="节点位置和布局"><a href="#节点位置和布局" class="headerlink" title="节点位置和布局"></a>节点位置和布局</h3><p> NodeGraph 的坐标轴方向是X轴向右，Y轴向下；节点的位置指的是节点左上角的位置.<br> 位置相关方法,node &#x3D; createNode(“Text2”)：</p><ul><li>获取位置<ul><li>node.xpos()、node.ypos()</li><li>node[“xpos”].value、node[“ypos”].value</li></ul></li><li>设置位置<ul><li>node.setXpos(“value”)、node.setYpos(“value”)、node.setXYpos(“value1”,”value2”)</li><li>node[“xpos”].setValue(“value”)、node[“ypos”].setValue(“value”)</li></ul></li><li>获取节点长宽<ul><li>node.screenWidth()、node.screenHeight()</li></ul></li><li>自动布局到选中节点的下方 node.autoplace()</li><li>NodeGraph 缩放比 <ul><li>查询缩放比 nuke.zoom()</li><li>设置缩放比 nuke.zoom(倍数，[焦距的位置X,焦距的位置Y])</li><li>聚焦到指定节点 nuke.zoom(倍数，[node.xpos(),node.ypos()])</li></ul></li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>打开新Nuke工程 nuke.scriptNew() ctrl+N</li><li>打开指定Nuke工程 nuke.scriptOpen(“存在的Nuke工程路径”) </li><li>将已有的Nuke工程导入到当前的Nuke工程中<ul><li>nuke.scriptSource()</li><li>nuke.scriptRendFile()</li></ul></li><li>清空当前NodeGraph:<ul><li>直接放弃修改，无返回值 nuke.scriptClear()</li><li>提示是否保存更改，有返回值 nuke.scriptClose()</li></ul></li><li>退出Nuke nuke.scriptExit()</li><li>获取当前文件名称 <ul><li>nuke.scriptName()</li><li>nuke.Root().name()</li><li>nuke.Root()[“name”].value()</li><li>nuke.Root().knob(“name”).value()</li></ul></li><li>从节点中进入节点树环境.使用上下文管理器with ‘with nuke.Root()’</li><li>返回当前工程所在的文件夹的路径<ul><li>nuke.utils.script_directory()</li><li>nukescripts.script_directory()（该方法调用上面的方法）</li></ul></li><li>复制和粘贴<ul><li>从字符串创建一个节点 nuke.scriptReadText(“表示节点的字符串，超麻烦”)</li><li>将选中的节点暂存到文本名或粘贴板名的文件中 nuke.nodeCopy(“文件路径或临时起名的粘贴板中”)</li><li>将粘贴板中的内容粘贴到nuke中 nuke.nodePaste(“文件路径或临时起名的粘贴板中”)  # %clipboard% 可表示系统粘贴板</li></ul></li><li>保存工程 <ul><li>直接保存 nuke.scriptSave()</li><li>另存为 nuke.scriptSaveAs(“文件名”)</li><li>另存时不修改Root节点中的路径 nuke.scriptSaveToTemp(“文件名”)</li><li>保存文件后清空nuke工程 nuke.scriptSaveAndClear()</li></ul></li></ul><h3 id="Nuke中的控件（Knob）"><a href="#Nuke中的控件（Knob）" class="headerlink" title="Nuke中的控件（Knob）"></a>Nuke中的控件（Knob）</h3><p>Nuke中的文本框、下拉菜单、复选框、滑块等基本控件，以及色彩设置<br>图片尺寸、坐标值等 专属控件都称为Knob。<br>node &#x3D; nuke.toNode(“Read”)</p><ul><li>获取所有的控件 <ul><li>node.allKnobs() 所有控件列表</li><li>node.knobs() 所有控件字典</li></ul></li><li>获取特定的控件对象 <ul><li>根据控件名获取<ul><li>node.knob(“控件名”) 没找到指定对象返回None</li><li>node[“控件名”] 没找到指定对象会报错</li><li>node.knobs().get(“控件名”) 根据控件名获取控件对象</li></ul></li><li>根据序号获取<ul><li>node.numKnobs() 返回当前节点中所有控件的总数量</li><li>node.knob(控件序号)</li></ul></li></ul></li><li>获取当前用户操作的控件 nuke.thisNode() </li><li>控件状态 <ul><li>node.knob(“控件名”).enable() 是否启用</li><li>node.knob(“控件名”).enable()setEnable() 设置启用状态</li><li>node.knob(“控件名”).enable()visible() 是否可见</li><li>node.knob(“控件名”).enable()setVisible() 设置可见状态</li></ul></li><li>返回标签名、控件名、提示信息 label()、name()、tooltip()</li><li>设置标签名、控件名、提示信息 setLabel()、setName()、setTooltip()</li><li>获取控件值<ul><li>value() 控件会根据需要进行继承和修改函数</li><li>getValue(oc) 获取特定帧或特定视图下的值</li><li>getValueAt()</li><li>defaultValue() 获取默认值</li></ul></li><li>设置控件的值  <ul><li>setValue(value,view&#x3D;”default”) 控件会根据需要进行继承和修改函数</li><li>setValueAt()</li><li>setDafaultValue() 设置控件的默认值</li><li>nuke.knobDefault(“节点名.控件名”，”参数”) 对节点的参数设置全局默认值</li></ul></li><li>控件值是否不为默认值 notDefault()</li></ul><p>format_knob 参数默认值来源于Root节点的format值</p><ul><li>获取值 node.knob(“format控件名”).value() </li><li>设置值 node.knob(“format控件名”).setValue()</li><li>新建默认format值 nuke.addFormat(“新建format值”) 新建format值为TCL表达式，其至少要包含 宽度，高度，格式名三项，每项用空格分隔，名称不能用数字开头</li></ul><p>TCL表达式相关函数：</p><ul><li>node.knob(“format控件名”).fromScript(“tcl表达式”) 接受tcl表达式并赋值给对象</li><li>node.knob(“format控件名”).toScript(bool,time) 将值输出为TCL表达式 bool为Ture，结果两侧加大括号，反之不加，time为具体帧，则仅设置该帧，若为None，则设置所有帧</li><li>node.knob(“format控件名”).readKnobs(“tcl表达式”) 使用tcl表达式为一个或多个节点控件赋值</li><li>node.knob(“format控件名”).writeKnobs(value) 将控件值以tcl表达式方式输出,value需要根据常量获取，详情见文档</li></ul><h3 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h3><p>UI交互式创建</p><table><tr><td><img src="/images/Nuke学习笔记2_节点与Knob/编辑控件.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记2_节点与Knob/编辑控件.png" class="lozad post-image"></td><td><img src="/images/Nuke学习笔记2_节点与Knob/创建控件.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Nuke学习笔记2_节点与Knob/创建控件.png" class="lozad post-image"></td></tr></table><p>代码创建<br>可使用NoOp节点进行自定义<br>node &#x3D; nuke.toNode(“Read”)</p><ul><li>添加控件 node.addKnob(控件对象)</li><li>移除控件 node.removeKnob(控件对象)</li><li>pythonScript中获取当前节点 nuke.thisNode()</li></ul><h3 id="Gizmo操作"><a href="#Gizmo操作" class="headerlink" title="Gizmo操作"></a>Gizmo操作</h3><p>将具有特定功能的节点组打包成一个节点，可用于别的nuke工程</p><ul><li>查询节点全路径 nuke.thisNode().fullName()</li><li>查询组内的节点 <ul><li>nuke.node(“组名”).node(“内部节点名”)[“knob名”].value()</li><li>nuke.node(“组名.组内节点名”)[“knob名”].value()</li></ul></li><li>在组织间进行代码操作<ul><li>node.begin() 代码开始</li><li>node.end() 代码结束</li></ul></li><li>转换正确导入的Gizmo为Group nuke.toNode(“Group”).makeGroup()</li></ul><h4 id="导入-导出gizmo"><a href="#导入-导出gizmo" class="headerlink" title="导入\导出gizmo"></a>导入\导出gizmo</h4><p>在组节点或者Gizmo节点下面，点击Node &gt; Export gizmo\Copr as Group<br>不能直接import Gizmo 节点使用，这样导入的节点是不完整的，只能使用nuke标准环境加载的方式进行应用。或将gizmo文件以文本的方式打开，将其中的Gizmo 替换为Group,这样也可以正确导入节点组。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nuke学习笔记</summary>
    
    
    
    <category term="Nuke" scheme="http://mirrorcg.github.io/categories/Nuke/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Nuke/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Nuke学习笔记1_环境与命令行</title>
    <link href="http://mirrorcg.github.io/posts/20220730a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220730a1.html</id>
    <published>2022-07-30T13:47:04.000Z</published>
    <updated>2022-07-31T07:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nuke学习笔记 <span id="more"></span></p><h4 id="Nuke-脚本编辑窗口相关快捷键和操作"><a href="#Nuke-脚本编辑窗口相关快捷键和操作" class="headerlink" title="Nuke 脚本编辑窗口相关快捷键和操作"></a>Nuke 脚本编辑窗口相关快捷键和操作</h4><p>tab键   自动代码补全    输入部分脚本后，可获取相关的方法</p><p style="text-indent:2em">Edit > Preferences > ScriptEditor > echo python commands to output window 将输出常用操作的 Nuke Python API 代码显示在代码执行结果显示区。</p><p><img src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9CPython%E4%BB%A3%E7%A0%81%E5%88%B0%E8%84%9A%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="输出操作Python代码到脚本编辑器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9CPython%E4%BB%A3%E7%A0%81%E5%88%B0%E8%84%9A%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8.png" class="lozad post-image"> </p><h4 id="搭建-Pycharm-IDE-开发环境"><a href="#搭建-Pycharm-IDE-开发环境" class="headerlink" title="搭建 Pycharm IDE 开发环境"></a>搭建 Pycharm IDE 开发环境</h4><p style="text-indent:2em">在 Pycharm 中新建一个项目，用于开发Nuke插件,必须使用Nuke本身的Python编译器 "C:\Program Files\Nuke版本\python.exe"，该python编译器拥有完整的Nuke开发环境。</p><p style="text-indent:2em">关于 nukescripts 模块的使用，需要将“C:\Program Files\Nuke版本号\plugins”加入搜索路径</p><p style="text-indent:2em">关于 Pyside2 模块的使用，需要将“C:\Program Files\Nuke版本号\pythonextensions\site-packages”加入搜索路径</p><p style="text-indent:2em">配置好上面的环境后执行代码会发现报错：缺少一个“_nuke” 模块。这个模块在这里 "C:\Program Files\Nuke12.2v2\lib\site-packages\nuke.pyd" 中，由于这个文件和上面的 nukescripts 模块同级目录的nuke模块重名，导致不能加载这个nuke.pyd，因此会报这个错，如何解决呢？</p><ul><li>方法一.从搜索路径中去掉 “C:\Program Files\Nuke版本号\plugins”，但nukescripts模块的会缺少代码补全（加载完nuke.pyd后，会自动加载nuke和nukescripts模块，因此在执行代码时不会报这两个模块的错）.</li><li>方法二.在pycharm中将编辑nuke代码的Python解释器和运行nuke代码的python解释器分开，在编写的nuke代码的时候，将项目中python interpreter中设置的python解释器设置为普通的python解释器，可以在其搜索路径中加入我们想要的搜索路径，然后在运行nuke代码的时候，在Run&#x2F;Debug configuration中设置的python解释器设置为带有nuke环境的python解释器即可。</li></ul><p>  <img src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%88%87%E6%8D%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84Python%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt="切换执行时的Python解释器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%88%87%E6%8D%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84Python%E8%A7%A3%E9%87%8A%E5%99%A8.png" class="lozad post-image"> </p><p style="text-indent:2em">此环境可能无法正常运行Pyside2相关的代码，需要在nuke中执行(详情见下一节)。</p><p><img src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/Pycharm%E4%B8%AD%E4%BD%BF%E7%94%A8Pyside2%E6%8A%A5%E9%94%99.png" alt="Pycharm中使用Pyside2报错 png" srcset="/images/home/Myhead.jpg" data-src="/images/Nuke%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/Pycharm%E4%B8%AD%E4%BD%BF%E7%94%A8Pyside2%E6%8A%A5%E9%94%99.png" class="lozad post-image">  </p><h4 id="Nuke-命令行模式"><a href="#Nuke-命令行模式" class="headerlink" title="Nuke 命令行模式"></a>Nuke 命令行模式</h4><pre class="language-dos" data-language="dos"><code class="language-dos">&quot;C:\Program Files\Nuke12.2v2\python.exe&quot; &quot;D:\test.py&quot;</code></pre><p>运行脚本需使用Nuke的Python解释器，若后台调用脚本，可使用subprocess方法切换至Nuke本身的Python解释器。</p><p>若要使用 Pyside2 模块，需要在通过nuke主程序 nuke.exe 使用参数 -t 就可以运行Pyside2模块。</p><pre class="language-dos" data-language="dos"><code class="language-dos">&quot;C:\Program Files\Nuke12.2v2\nuke.exe&quot; -t &quot;D:\test.py&quot;</code></pre><p>但 -t 参数不能获取到 QApplication 类，只能获取到 QCoreApplication 类（QApplication是QCoreApplication的子类），所以要通过 --tg 参数来获取 Pyside2 模块创建窗口所需要的 QApplication 类。</p><pre class="language-dos" data-language="dos"><code class="language-dos">&quot;C:\Program Files\Nuke12.2v2\nuke.exe&quot; --tg &quot;D:\test.py&quot;</code></pre><p>nuke命令行语法：</p><p style="text-indent:4em">nuke.exe <\option> [<\argv>] <\script> [<\range>]</p>使用不同类别的主程序常用参数:<ul><li>--nukex</li><li>--studio</li><li>--nc</li><li>--nukeassist</li></ul><p>可以在Windows环境下使用doskey创建快捷键(只在当前窗口有效)，可以使用PATH环境变量，并写在一个bat脚本中：</p><pre class="language-dos" data-language="dos"><code class="language-dos">doskey nukex &#x3D; &quot;C:\Program Files\Nuke12.2v2\nuke.exe&quot; --nukex $*</code></pre><p>效果等于：<br>“C:\Program Files\Nuke12.2v2\nuke.exe” -- nukex &lt;\option&gt; [&lt;\argv&gt;] &lt;\script&gt; [&lt;\range&gt;] &#x3D; nukex &lt;\option&gt; [&lt;\argv&gt;] &lt;\script&gt; [&lt;\range&gt;]</p><p>一些常用的参数：</p><ul><li>-t 适用于纯命令行脚本</li><li>–tg 会产生一个 QApplication 实例，用于执行 Pyside2 的Gui相关脚本</li><li>-x &lt;\scriptname&gt; 渲染名为 \scriptname 的nuke工程中所有激活的write节点</li><li>-X&lt;\nodename&gt; 仅渲染指定名的\nodename的write节点</li><li>-F 指定帧范围</li><li>–cont 出错后继续渲染</li><li>–sro 按顺序依次渲染节点</li><li>-f 以全尺（full resolution）的方式打开nuk工程</li><li>-p 和-f相对，以 proxy 的方式打开nuke工程</li><li>-v 打开指定的图像文件，如果是视频，还需要跟上帧范围（文件路径使用正斜杠，不能使用反斜杠）</li><li>–pause 打开nuke工程时暂停 Viewer 初始化</li><li>-P 显示每个节点的资源占用情况</li><li>-Pf&lt;\filename&gt; 将每个节点的资源占用情况写入名为 \filename 的xml文件中</li><li>–multigpu 启用多gpu支持</li><li>–gpulist 列出当前系统可用的GPU及其索引号</li><li>–gpu ARG 使用由索引号ARG指定的GPU,在终端模式下启动GPU加速</li><li>–safe 安全模式，启动nuke不加载 .nuke、NUKE_PATH及OFX插件</li><li>-m # 指定线程数</li><li>-n 关闭节点postage stamps的预览显示</li><li>-q 关闭终端输出</li><li>-i 使用nuke_i授权，可与 -x 和 -t 连用，写成 -ti 或 -xi,默认情况下使用nuke_r授权，但有些操作需要使用nuke_i授权。</li><li>–remap&lt;\pathPair&gt; 仅能在命令行模式下使用，在当前会话中设置路径映射，要求参数为一对或多对路径拼成的字符串，用逗号分隔</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nuke学习笔记</summary>
    
    
    
    <category term="Nuke" scheme="http://mirrorcg.github.io/categories/Nuke/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Nuke/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Xgen毛发</title>
    <link href="http://mirrorcg.github.io/posts/20220729a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220729a1.html</id>
    <published>2022-07-29T15:16:15.000Z</published>
    <updated>2022-08-24T14:36:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了一些Maya中Xgen毛发渲染的相关的问题：<span id="more"></span></p><ol><li><p>Xgen 角色ABC和毛发ABC的运动模糊不匹配的问题（小概率事件）：</p><p style="text-indent:2em">原因是生长面缓存只有整数帧采样并且在渲染运动模糊时，Xgen没有计算生长面的插值,或者由于前后帧的运动差异过大，Xgen计算出错误的生长面插值，导致毛发生长面的缓存和角色缓存的插值不匹配，生长面缓存和角色缓存在小数帧位置不同，就会导致运动模糊不同。也可以通过实际文件观测到，在运动模糊有问题的小数帧，毛发不加载缓存时，其毛发引导线跟随动画缓存，加载了毛发缓存后，毛发缓存曲线和动画缓存的位置一致，而毛发引导线却和缓存曲线不在相同的位置，毛发引导线和动画缓存脱离，但是毛发引导线的形态和毛发缓存一致，说明毛发引导线只是从毛发缓存继承了形态，并不继承其位置。而毛发引导线的位置是从毛发生长面继承的，此时毛发引导线的位置和动画缓存不一致，那么小数帧时生长面的缓存和动画缓存位置不一致，因此，毛发生长面缓存在计算小数帧时有问题。解决此类问题，最好为动画缓存、曲线缓存、生长面缓存都添加缓存的小数帧采样插值。</p></li><li><p>前台批渲染带渲染运动模糊时，代码批量刷新生长面时报错‘not match object “XGEN_RENDER_:XXXX”’：</p><p style="text-indent:2em">Xgen毛发在渲染运动模糊后，会生成可通过xgen.palettes()获取，但是无法使用cmds.sl("")列出，也无法删除的临时生长面，该生长面以“XG_RENDR_:”为前缀，若要在渲染运动模糊后批量处理生长面，需要跳过它，不会有任何影响。该临时生长面不会记录到maya文件中，但是会存在当前软件中，哪怕你清除场景，并重开另一个场景，也可以查询到它，处理时需直接跳过，对渲染无影响。</p></li><li><p>abc流程中，对角色缓存位置进行修改（场景移回原点）过的灯光文件，其xGen毛发可能会炸毛，可能原因是引用文件记录了一些错误的操作，这部分操作导致xGen文件状态不对，需要删除.Xgen文件，重新引用毛发文件，或者先删除.Xgen文件、卸载引用文件、清除其操作历史，再加载引用文件。</p></li></ol><h4 id="Xgen-毛发创建笔记"><a href="#Xgen-毛发创建笔记" class="headerlink" title="Xgen 毛发创建笔记"></a>Xgen 毛发创建笔记</h4><h4 id="一些Xgen文件测试记录"><a href="#一些Xgen文件测试记录" class="headerlink" title="一些Xgen文件测试记录"></a>一些Xgen文件测试记录</h4><ol><li><p>使用不同名称、完全相同的两个集合体作为Xgen描述的生长面，其基本体随机种子数会有一些差异，随机种子数是根据物体的生长面名称进行hash计算得出的结果，若替换生长面对应的几何体名称，随机种子数会发生细微变化，从而导致效果会有细微差别。</p></li><li><p>xgen文件中只记录几何体的短名，不记录长名(可以手动修改的方式使用maya规范的长名，)，测试结果是只识别几何体短名称，不区分拓扑结构和形状以及uv，只使用.xgen文件中记录的的faceid面数，但拓扑结构不同结果肯定不一样，几何体名和生长面前缀应保持一致。</p></li><li><p>绘制的iff贴图在保存文件后才会写入工程目录的文件夹，描述下有几个生长面就保存几张贴图(从新的几何体添加新的生长面，需要重新绘制贴图，保存后也会对应新增一张贴图)，根据绘制贴图时的生长面_集合_描述名称，xgen中指定的贴图名称命名为：polySurfaceShape1_grass_col_grass_decmask_generator_grass)。</p></li><li><p>生长面跟随几何体放大缩小，但是毛发粗细不变(可写入表达式，待测试)。</p></li><li><p>确定了几何体、绑定几何体并生成生长面之后，不可以修改几何体的名称，指向文件(ptx，xuv等文件)记录的是以几何体命名的贴图名称，更改几何体命名称后，链接断开，指向文件失效。</p></li><li><p>使用相同几何体生成的不同描述，其生长面的名称为“几何体名称_描述名称”，不会重名</p></li><li><p>单个XGen文件的生长面、几何体可以改名;改完命名后直接更改其Xgen文件的几何体名称，另存文件即可;</p></li><li><p>使用几个几何体生成描述，集合下就拥有几个生长面(不建议使用多个几何体映射一个描述，最好先合并成一个几何体，方便管理)</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录了一些Maya中Xgen毛发渲染的相关的问题：</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="排错记录" scheme="http://mirrorcg.github.io/tags/%E6%8E%92%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Xgen" scheme="http://mirrorcg.github.io/tags/Xgen/"/>
    
  </entry>
  
  <entry>
    <title>Deadline中调试编写的事件</title>
    <link href="http://mirrorcg.github.io/posts/20220721a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220721a1.html</id>
    <published>2022-07-21T15:55:44.000Z</published>
    <updated>2022-08-21T17:09:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h4><p style="text-indent:2em">Deadline 事件依赖于其软件框架，不能进行实时调试，但是可以通过 Console 窗口快速获取获取事件反馈信息。</p><span id="more"></span><p style="text-indent:2em">若想快速查看事件处理的过程，获取结果，首先通过Panels > Console 开启 Console 窗口。</p><p><img src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/Console.jpg" alt="Console图片" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/Console.jpg" class="lozad post-image"></p><p style="text-indent:2em">对于事件编写，除了要先配置正确的事件文件以外，还要在代码中加入打印（可通过 DeadlineEventListener 类的 self.LogInfo 或者 print 等方法将调试信息写入代码中，或通过ClientUtils.LogText(str)方法将信息写入 Deadline 的日志文件中），由于 Deadline 会每隔一段时间才会扫描储存库，扫描的默认值一般为5分钟，当扫描过程中发现事件脚本有新的修改时，才会将修改的事件脚本重新构建到任务中，所以，为了让 Deadline 后台及时更新并构建我们修改的事件脚本，我们需要通过Tools > Synchronize Monitor Script and Plugins 功能手动更新事件脚本。</p><p><img src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC.jpg" alt="同步脚本" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC.jpg" class="lozad post-image"></p><p style="text-indent:2em">此时，Console 窗口会提示：***事件脚本有修改，将重新构建事件脚本的提示语。如果你的脚本有语法错误，Console 窗口还会给你打印一条简短的报错信息。然后 Requeue 目标任务，再将任务切换到我们所要的任务状态（先更新脚本，再操作任务，不能先操作任务再更新脚本，否则，事件不会被更新到任务状态中），Deadline 便会通过当前执行任务的机器执行事件脚本，并在Console 窗口显示反馈信息。通过此方法，可以快速对我们的事件脚本进行编写和调试。</p><h4 id="关于事件脚本中使用中文"><a href="#关于事件脚本中使用中文" class="headerlink" title="关于事件脚本中使用中文"></a>关于事件脚本中使用中文</h4><p style="text-indent:2em">有时会在日志中打印中文信息，则我们需要将中文字符串编码为"gbk"（windows系统）的人类可读懂的代码。需要注意的是：</p><ul><li>需了解事件脚本在编写时，文本编辑器使用的编码格式是否为utf8，以及操作系统文件在编译中文时，使用的编码格式（Windows下控制台中的编码使用的是gbk）。因此，我们会在 python 脚本文件头部中加入 “# -<em>- coding:utf-8 -</em>-” 显式编码注释，文本编辑器在存储脚本时会做相应的修改。</li><li>中文字符很容易出错，导致插件执行被打断却没有任何反馈信息的假成功状态，这是由于当Deadline后台检测脚本有字符转换的错误时，它可不执行事件脚本。</li><li>测试 deadline 10.0.6.3 的 Python2 环境打印中文：中文字符串最后一个字符串不能为中文标点符号，否则会报语法错误（控制台在编码中文时，会将最后一个标点符号编码错误为一个‘？’号）。</li></ul>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-def __main__():    print(u&quot;测试中文打印&quot;.encode(&quot;gbk&quot;))    print(unicode(&quot;测试中文打印&quot;，&quot;utf-8&quot;).encode(&quot;gbk&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>测试在 deadline 10.1 的环境打印中文则很简单，和普通代码一样直接打印,字符串末尾可以有中文标点符号且不用进行字符编码，否则会报错：  <pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-def __main__():    print(&quot;测试中文打印。&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/2_Scripting%20Reference/index.html" title="" target="">1.官方文档中事件脚本文档</a></br><a href="http://www.mirrorcg.com/posts/20220306a1.html" title="" target="">2.往期相关文章：Deadline中的事件示例</a></br><a href="http://www.mirrorcg.com/posts/20220822a1.html" title="" target="">3.相关文章：Python代码中的字符编码</a>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;详情&quot;&gt;&lt;a href=&quot;#详情&quot; class=&quot;headerlink&quot; title=&quot;详情&quot;&gt;&lt;/a&gt;详情&lt;/h4&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;Deadline 事件依赖于其软件框架，不能进行实时调试，但是可以通过 Console 窗口快速获取获取事件反馈信息。&lt;/p&gt;</summary>
    
    
    
    <category term="Deadline" scheme="http://mirrorcg.github.io/categories/Deadline/"/>
    
    <category term="插件" scheme="http://mirrorcg.github.io/categories/Deadline/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="插件" scheme="http://mirrorcg.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
    <category term="API" scheme="http://mirrorcg.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>CG流程中的ACES概念解释</title>
    <link href="http://mirrorcg.github.io/posts/20220706a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220706a1.html</id>
    <published>2022-07-06T15:18:49.000Z</published>
    <updated>2022-07-06T15:18:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="ACES-一些散记"><a href="#ACES-一些散记" class="headerlink" title="ACES 一些散记"></a>ACES 一些散记</h4><p>  经过IDT转换的图片只能保证其在AECS色域中渲染的颜色信息和ACES相比较是正确的，不能保证渲染的效果和SRGB的原效果一致。<br>  线性图和非线性图的区别在于是否经过Gamma1.8到gamma2.2的曲线矫正,矫正的目的是为了迎合人眼观察的同时，方便使用8位图存储色彩信息。浮点图没有色彩存储空间不够的情况，因此浮点图一般是线性图。<br>  ACES推荐使用EXR、TIF、HDR等浮点图存储信息，最少使用16位(exr是HDR标准的图片格式，拥有多通道存储的能力，使用1位、5位、10位分段分别存储不同的信息)。<br>  CG流程中ODT用于ACES到SRGB色域的转换，通常是使用‘output_srgb’类型。<br>  Maya中输出的16位ACES图和32位图色彩信息有些许肉眼可见的不同。请自行测试。</p><h4 id="一些文章参考"><a href="#一些文章参考" class="headerlink" title="一些文章参考"></a>一些文章参考</h4><br><p style="text-indent:2em">国内网页：</p><a href="https://www.bilibili.com/video/BV1jM4y1N7yT?spm_id_from=444.41.top_right_bar_window_default_collection.content.click&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">ACES编码及色彩原理（CG）</a><br><a href="https://www.bilibili.com/video/BV1Fg411M7H6?p=1&share_medium=android&share_plat=android&share_session_id=665fc73f-fd8b-484a-9cb2-7bf453d6035e&share_source=WEIXIN&share_tag=s_i&timestamp=1656295742&unique_k=SDBzFDb&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">ACES通俗讲解</a><br><a href="https://www.bilibili.com/read/cv9842761" title="" target="">色彩原理</a><br><a href="https://www.bilibili.com/video/BV1dV411i7M1?spm_id_from=333.788.top_right_bar_window_default_collection.content.click&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">Nuke色彩空间（Gamma）的转换和原理</a><br><a href="https://www.shangyexinzhi.com/article/1960438.html" title="" target="">参考文章1</a><br><a href="https://www.toadstorm.com/blog/?p=694" title="" target="">参考文章2</a><br><a href="https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/" title="" target="">参考文章3</a><br><br><p style="text-indent:2em">以下需科学上网：</p><a href="https://www.youtube.com/watch?v=W9Z1Std_1Kc" title="" target="">ACES Workflow in Maya with Redshift and Arnold</a>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Doc/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="灯光合成" scheme="http://mirrorcg.github.io/tags/%E7%81%AF%E5%85%89%E5%90%88%E6%88%90/"/>
    
    <category term="ACES" scheme="http://mirrorcg.github.io/tags/ACES/"/>
    
  </entry>
  
  <entry>
    <title>Maya中常用的部分环境变量</title>
    <link href="http://mirrorcg.github.io/posts/20220521a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220521a1.html</id>
    <published>2022-05-21T13:33:36.000Z</published>
    <updated>2022-07-25T14:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录 maya 中常用的部分环境变量。<span id="more"></span></p><ul><li>MAYA_ENABLE_LEGACY_RENDER_LAYERS      开启旧版灯光渲染分层系统（maya2017以后可使用）</li></ul><p>屏蔽 maya 连接网络</p><ul><li>MAYA_DISABLE_CIP &#x3D; 1</li><li>MAYA_DISABLE_CLIC_IPM &#x3D; 1</li><li>MAYA_DISABLE_CER &#x3D; 1</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录 maya 中常用的部分环境变量。</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
    <category term="环境变量" scheme="http://mirrorcg.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows任务计划</title>
    <link href="http://mirrorcg.github.io/posts/20220510a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220510a1.html</id>
    <published>2022-05-10T04:51:16.000Z</published>
    <updated>2022-05-10T05:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>工作中有时需要定时执行一些规律性的脚本操作<span id="more"></span>，比如，清除磁盘垃圾、定时下载任务等。这些任务执行虽然简单，但是需要人力进行日常维护。通常有两种方式可以方便处理这类型任务：</p><ol><li>以本机作为脚本任务的执行者，开启电脑后，通过ide运行任务，但是每次开机都需要手动执行，或者将程序打包成exe程序再放入启动文件夹。</li><li>以本机作为服务器，通过任务计划的触发器，自动执行指定任务，不需要每次开机后再手动执行。</li></ol><p>下面将介绍第二种方式——任务计划</p><ul><li><p>打开计划任务程序</p><table><tr><td><img src="/images/Windows任务计划/打开管理工具.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Windows任务计划/打开管理工具.png" class="lozad post-image"></td><td><img src="/images/Windows任务计划/任务计划程序.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Windows任务计划/任务计划程序.png" class="lozad post-image"></td></tr></table></li><li><p>创建一个新的任务计划文件夹（推荐）或在“任务计划程序库”中创建基本任务:提一下”创建基本任务”和”创建任务”的区别是一个有引导界面，一个直接弹出设置界面直接设置。</p></li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1.png" alt="创建基本任务 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1.png" class="lozad post-image">  </p><ul><li>输入任务名称和描述。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%BE%93%E5%85%A5%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0.png" alt="输入任务名称和描述 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%BE%93%E5%85%A5%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0.png" class="lozad post-image">  </p><ul><li>选择触发器，修改触发器触发的时间和间隔，这里暂时只能创建一个触发器，我们可以创建完任务计划后进行添加或修改触发器。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="选择触发器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E8%A7%A6%E5%8F%91%E5%99%A8.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E4%BF%AE%E6%94%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E9%80%89%E9%A1%B9.png" alt="修改触发器选项 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E4%BF%AE%E6%94%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E9%80%89%E9%A1%B9.png" class="lozad post-image"> </p><ul><li>选择任务操作，并填入相关参数，这里很重要，它可以决定你的任务计划是否正常执行，原则上越简单越好（后面会进行详解）；然后点击完成。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C.png" alt="选择任务操作 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%84%9A%E6%9C%AC.png" alt="设置启动程序的脚本 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%84%9A%E6%9C%AC.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%AE%8C%E6%88%90%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1.png" alt="完成创建任务 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%AE%8C%E6%88%90%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1.png" class="lozad post-image"> </p><ul><li>“创建基本任务”完成后，我们还需要对其进行一些的修改；选择任务点击属性对任务进行修改。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%B8%B8%E8%A7%84%E8%AE%BE%E7%BD%AE.jpg" alt="常规设置 jpg" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%B8%B8%E8%A7%84%E8%AE%BE%E7%BD%AE.jpg" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="触发器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%A7%A6%E5%8F%91%E5%99%A8.png" class="lozad post-image"><br>  “操作”项暂不做修改；”条件”项也比较简单，都是字面意思，这里不做讲解；<br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E8%AE%BE%E7%BD%AE.jpg" alt="设置设置 jpg" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E8%AE%BE%E7%BD%AE.jpg" class="lozad post-image"><br>  note：每次手动运行任务后，若任务状态没有更改成预期状态，可通过右键任务选择“刷新”选项进行任务状态的刷新。</p><ul><li>关于”操作”项中的设置需要注意：由于我们使用的是.bat脚本中通过python程序调用.py脚本，因此这里的”程序或脚本”填入 XXX\test.bat(不加引号)，”添加参数（可选）”为空，“起始于（可选）”则是.py文件所在的目录，而不是执行程序或者.bat脚本所在的目录，否则执行的结果会出错；若不填(缺省状态)，那么自动将该处的目录位置定位到”程序或脚本”的目录位置。并且调用的程序需要传入参数，例如”程序或脚本”填入Python编译器路径 C:\Python27\python.exe ，而”添加参数（可选）”为.py文件，那么“起始于（可选）”则是.py文件所在的目录。最后说一下，任务计划中所用到的所有的文件最好放置在本地路径。</li></ul><h4 id="实践踩坑和解决办法"><a href="#实践踩坑和解决办法" class="headerlink" title="实践踩坑和解决办法"></a>实践踩坑和解决办法</h4><p style="text-indent:2em">在这次工作中由于需要每天调用pythonAPI对程序的服务端进行调整，因此使用了任务计划调用bat脚本的方式执行任务。该bat脚本中，仅简单的一句'XXX/python.exe XXX/XXX/xxx.py'---使用编译器编译python脚本，该任务在我本机上执行没有任务问题，于是将任务计划部署到农场机器上，此时任务就出现了问题：创建的任务不会成功执行，或者执行结果不为'成功执行（0X0）',或者执行结果为'成功执行（0X1）'（失败状态）或者直接失败，找了很久的原因，排除几乎所有的可能性（计算机休眠、计算机系统配置不对、任务权限不够、bat脚本有问题、.py脚本有问题、任务手动运行后状态没有及时切换导致新实例不能创建、不能访问网络盘资源、脚本“起始于（可选）”参数不对、执行程序带引号等等）。最后本着"越简单越好"的原则，直接将bat脚本拆开，将python编译器的位置填入"程序或脚本"，"添加参数（可选）"填入.py脚本，“起始于（可选）”填入.py脚本路径，问题才得到解决。</p><p style="text-indent:2em">猜测和计算机系统有关，由于我本机使用的是Windows10 的操作系统，而农场机使用的是Windows server2012 的操作系统。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>官方介绍：<a href="https://forsenergy.com/zh-cn/gpmc/html/688d2d42-454a-4e2e-90c0-557f959d49b0.htm">https://forsenergy.com/zh-cn/gpmc/html/688d2d42-454a-4e2e-90c0-557f959d49b0.htm</a><br>参考文章：<a href="https://www.jianshu.com/p/c627c77f6ea3">https://www.jianshu.com/p/c627c77f6ea3</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作中有时需要定时执行一些规律性的脚本操作</summary>
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    
    <category term="排错记录" scheme="http://mirrorcg.github.io/tags/%E6%8E%92%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    
    <category term="windows" scheme="http://mirrorcg.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Deadline如何使用PythonAPI</title>
    <link href="http://mirrorcg.github.io/posts/20220505a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220505a1.html</id>
    <published>2022-05-05T12:46:35.000Z</published>
    <updated>2022-05-05T12:46:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p style="text-indent:2em">本文介绍如何使用 Deadline 的 Python API 操作Deadline。<span id="more"></span>通过 Python API 可在 Python 中与 HTTP API 通信。</p><h4 id="拷贝-PythonAPI-模块"><a href="#拷贝-PythonAPI-模块" class="headerlink" title="拷贝 PythonAPI 模块"></a>拷贝 PythonAPI 模块</h4><p style="text-indent:2em">首先在使用 API 之前，需要配置python环境使我们可以调用到 API。我们需要安装和使用 python2.7.9或 3.7 以上的python版本，然后将 Deadline 储存库路径（//your/repository/api/python）下的整个“Deadline”文件夹复制到Python 安装路径下的的“site-packages”文件夹，API 即可调用。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E6%8B%B7%E8%B4%9DPythonAPI.png" alt="Deadline拷贝PythonAPI" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E6%8B%B7%E8%B4%9DPythonAPI.png" class="lozad post-image"></p><h4 id="开启-WebService-服务"><a href="#开启-WebService-服务" class="headerlink" title="开启 WebService 服务"></a>开启 WebService 服务</h4><p style="text-indent:2em">我们还需要通过 WebService 通信以发送和接收请求，因此，还要在 Deadline 管理的局域网中的任何一台可见的设备上运行 WebService服务，该服务为“C:\Program Files\Thinkbox\Deadline10\bin\deadlinewebservice.exe”，打开后，我们就可以通过该设备的设备名称或者Ip地址进行通讯，API访问的端口默认情况下为8082。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/DeadlineWebServer.png" alt="DeadlineWebServer" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/DeadlineWebServer.png" class="lozad post-image"></p><h4 id="使用-PythonAPI"><a href="#使用-PythonAPI" class="headerlink" title="使用 PythonAPI"></a>使用 PythonAPI</h4><p style="text-indent:2em">使用时，必须创建一个 DeadlineCon 对象。该对象用于与 WebService 通信以发送和接收请求，该对象需要两个参数：“运行 WebService 服务的设备名或IP地址”、“该设备上允许 WebService 通信的端口号（默认为8082）”，这两个参数可以从已经运行的 WebService 通讯服务上找到。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="Deadline设备名称和端口号" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" class="lozad post-image"></p><p>然后我们就可以使用API创建一个连接对象“connectionObject &#x3D; Deadline.DeadlineConnect.DeadlineCon(‘WebServiceName’, WebServicePortNumber)”， 通过该对象，我们可以查询、修改 Deadline 上的大部分信息。</p><p>示例代码1：查询作业组、暂停指定作业</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import Deadline.DeadlineConnect as Connect  # 导入 Deadline.DeadlineConnect 作为连接connectionObject &#x3D; Connect.DeadlineCon(&#39;DESKTOP-Mirror&#39;, 8082)print(connectionObject.Groups.GetGroupNames())#[&quot;group1&quot;,&quot;group2&quot;,&quot;group3&quot;]jobId &#x3D; &quot;622c38262812473ba4c08eca&quot;  #(有效的job ID号)print(connectionObject.Jobs.SuspendJob(jobId))# &#39;Success&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码2：提交作业</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import Deadline.DeadlineConnect as ConnectDeadline &#x3D; Connect.DeadlineCon(&#39;DESKTOP-Mirror&#39;, 8082)JobInfo &#x3D; &#123;    &quot;Name&quot;: &quot;Submitted via Python&quot;,    &quot;UserName&quot;: &quot;UserName&quot;,    &quot;Frames&quot;: &quot;0-1&quot;,    &quot;Plugin&quot;: &quot;VraySpawner&quot;&#125;PluginInfo &#x3D; &#123;    &quot;Version&quot;: &quot;Max2014&quot;&#125;try:    newJob &#x3D; connectionObject.Jobs.SubmitJob(JobInfo, PluginInfo)    print(newJob)except:    print(&quot;Sorry, Web Service is currently down!&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li>官方说明：<a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/3_Python%20Reference/index.html#intro_sec">https://docs.thinkboxsoftware.com/products/deadline/10.1/3_Python%20Reference/index.html#intro_sec</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;本文介绍如何使用 Deadline 的 Python API 操作Deadline。</summary>
    
    
    
    <category term="Deadline" scheme="http://mirrorcg.github.io/categories/Deadline/"/>
    
    <category term="插件" scheme="http://mirrorcg.github.io/categories/Deadline/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="插件" scheme="http://mirrorcg.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
    <category term="API" scheme="http://mirrorcg.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Maya中材质文件和缓存文件相结合进行渲染的几种方式</title>
    <link href="http://mirrorcg.github.io/posts/20220503a6.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a6.html</id>
    <published>2022-05-03T08:48:37.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p style="text-indent:2em">本文记录材质文件和缓存文件相结合，组装渲染镜头文件的几种方式.<span id="more"></span></p><h3 id="缓存驱动材质文件进行渲染"><a href="#缓存驱动材质文件进行渲染" class="headerlink" title="缓存驱动材质文件进行渲染"></a>缓存驱动材质文件进行渲染</h3><p>使用缓存文件驱动材质文件的方式进行渲染。</p><h3 id="缓存文件直接替换材质文件的几何体进行渲染"><a href="#缓存文件直接替换材质文件的几何体进行渲染" class="headerlink" title="缓存文件直接替换材质文件的几何体进行渲染"></a>缓存文件直接替换材质文件的几何体进行渲染</h3><h3 id="缓存文件包裹材质文件进行渲染"><a href="#缓存文件包裹材质文件进行渲染" class="headerlink" title="缓存文件包裹材质文件进行渲染"></a>缓存文件包裹材质文件进行渲染</h3><h3 id="给缓存文件赋予材质进行渲染"><a href="#给缓存文件赋予材质进行渲染" class="headerlink" title="给缓存文件赋予材质进行渲染"></a>给缓存文件赋予材质进行渲染</h3>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;本文记录材质文件和缓存文件相结合，组装渲染镜头文件的几种方式.</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
    <category term="灯光" scheme="http://mirrorcg.github.io/tags/%E7%81%AF%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>Maya软件渲染问题集锦</title>
    <link href="http://mirrorcg.github.io/posts/20220503a5.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a5.html</id>
    <published>2022-05-03T08:01:45.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>渲染崩溃可能的问题：</p><ul><li>被赋予Arnold材质3s散射的物体是片，导致散射时不是在物体内部散射，而是在整个场景中散射，计算量特别大从而崩溃。</li><li>文件中毛发的密度太大导致渲染机内存不够用。</li><li>文件本身有问题。</li><li>具体问题，具体分析。</li></ul></li><li><p>Redshift:提示：’Mesh pCubeShape1 is instanced and uses adaptive tessellation, which isn’t supported. Disabling tessellation. If you need tessellation, please use fixed tessellation settings: i.e. disable ‘screen space adaptive’ and set ‘min edge length’ to zero to force a maximum tessellation level’。对象细分后在实例错误提示：对象在实例化后细分，被实例化对象在屏幕自适应时找不到细分对象，就不会进行细分。如果需要细分，就关闭屏幕自适应，并把最小边缘强度设置为零，以强制使用最大边缘强度，如图：</p><p> <img src="/images/Maya%E8%BD%AF%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/Redshift%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%86%E5%88%86.png" alt="Redshift实例对象自适应细分" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E8%BD%AF%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/Redshift%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%86%E5%88%86.png" class="lozad post-image"></p></li><li><p>农场机提示找不到可执行渲染的文件：“Katana render executable was not found in the semicolon separated list”（在分号分隔的列表中没有找到Katana渲染的可执行文件），该机器上没有安装相应的软件，或软件没有安装在默认的路径。</p></li><li><p>Cannot find procedure “pgYetiVRayPreRender”（或”pgYetiPreRender”）报错导致渲染暂停：渲染文件中没有Yeti毛发节点，却在渲染文件的渲染设置中填入了“pgYetiVRayPreRender”（或”pgYetiPreRender”）代码，导致渲染器找不到对应的节点而报错，我们只需要打开文件，删除渲染设置中的以下代码就行了（Render Settings &gt; Common &gt; Render Options，删除报错的MEL，一般情况下也可以全部删除）：</p> <table><tr> <td><img src="/images/Maya软件渲染问题集锦/Yeti报错.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/Yeti报错.png" class="lozad post-image"></td> <td><img src="/images/Maya软件渲染问题集锦/删除Yeti报错设置.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/删除Yeti报错设置.png" class="lozad post-image"></td> </tr></table></li><li><p>贴图文件正在上传或修改。日志出现：File“*******”was modified after being opened by OIIO，这是因为文件在渲染的时候，被文件IO读取的贴图文件还在上传或更新中<br> 解决办法：等待贴图上传完成后再渲染文件</p></li><li><p>盘符掉了或没有输出磁盘：<br> 解决办法：映射一个盘符</p> <pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">subst D: C:\D  ::映射D盘盘符到C盘的D文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Deadline农场渲染报错“defaultRenderLayer” is a layer from a referenced and is not allowed to be the current layer ,其可能是之一是：maya 的 renderLayerManage节点被改名导致 maya 不能生成默认的master layer渲染层（在.ma文件中的名称为defaultRenderLayer），因此可以将文件保存为.ma格式的文件，用文本的方式打开，将renderLayerManager节点的名称改为默认的’renderLayerManager’(没有任何修饰)，同时由于默认的renderLayerManager节点已经被修改过，默认的渲染层名称也发生了改变，导致渲染程序在调用的代码中，该层被判定为非默认的渲染层而报错“unable to modify overrides to the default layer”,因此，还需要将文件中的 defaultRenderLayer节点 (本问题记录时该节点名称为 defaultRenderLayer1 ),改为默认的名称defaultRenderLayer，即可。</p></li><li><p>maya动画文件直渲，后台批量渲染时，角色控制器带动角色模型不规则抖动的可能原因：这是旧版绑定系统的问题，这种问题一般可通过走 abc 流程规避，否则需要更新绑定的 cluster 节点选项。禁用”cluster.relative”，并将”cluster.angleInterpolation”的值设置为3，代码如下：</p> <pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">import maya.cmds as mcfor each in mc.ls(typ&#x3D;&quot;cluster&quot;):mc.setAttr(&quot;cluster1.relative&quot;, 0)mc.setAttr(&quot;cluster1.angleInterpolation&quot;, 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>maya动画文件直渲，后台批渲时，动画文件中的约束失效，例如角色对道具的约束丢失或者效果不对；可能原因：</p><ul><li>动画文件后台渲染其中的动力学不出缓存，会重新计算。</li><li>动画文件后台渲染时表达式会失效。<br>解决办法：（1）烘焙动画曲线：选择绑定组大组执行 Animation &gt; Key &gt; Bake Simulation 等待读条完成后会将控制器的每一帧都K上关键帧，然后再提交渲染即可；（2）在Premel中填入可拖动时间滑块到当前帧的mel表达式，该表达式会在渲染开始前对镜头中的帧进行切换，从开始帧逐渐切换至当前帧，相当于对文件中的控制器进行了一次”脏”运算。达到数据正确的目的。（3）走 abc 流程。</li></ul></li><li><p>maya 创建polygon报错：error line0:connection not made :”****.instObjGroup[0]”-initalShaderGroup.dagSetMembers[-1].destination is locked:可能原因：</p><ul><li>相关节点被锁</li><li>相关属性被锁<br>解决办法：解锁相关节点或相关属性，或者重启 Maya 可解决问题。</li></ul></li><li><p>后台渲染丢材质报错：[mtoa][translator polymesh] ShadingGroup ******:*****SG has no faceShader input …。可能原因：材质没有连接上对应模型或制作过程中切换过不同的渲染器，导致材质与物体mesh的链接断开；<br>解决办法：修改材质文件中的材质链接或重新连接材质，注意查看材质文件的材质、渲染器输出信息；或先赋予Lambert材质,再重新赋予原来的材质。</p></li><li><p>后台渲染和前台渲染的exr图片颜色空间不一致，或颜色不一致。可能原因：</p><ol><li>首选项中勾选了的 Preferences &gt; Output color preferences &gt; Apply Output Transform to Render ，并将Output Transform 设置为 Use View Transform ,该选项会应用 Preferences &gt; Color Transform Preferences 中的 View Transform 值到输出图片，该选项的作用是将渲染预览的结果转换并应用到输出图片（包括色彩空间），如果渲染预览的图片为sRGB编码的色彩空间图，则输出图片也会转换为sRGB色彩空间的图（如下图左1）。</li><li>渲染器驱动节点的”defaultArnoldDriver.colorManagement”渲染设置为了 Use View Transform ，其默认值为 Use Output Transform，原因和 1 一致（正确设置如下图右1所示）。<br>选中驱动节点代码：<pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">mc.select(&quot;defaultArnoldDriver.colorManagement&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><tr><td><img src="/images/Maya软件渲染问题集锦/渲染空间不一致首选项设置 .png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/渲染空间不一致首选项设置 .png" class="lozad post-image"></td><td><img src="/images/Maya软件渲染问题集锦/渲染空间不一致节点选项设置.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/渲染空间不一致节点选项设置.png" class="lozad post-image"></td></tr></table></li></ol></li><li><p>同一个场景代理文件，渲染颜色不一致、闪烁，可能原因：代理文件导入maya后，其材质网络被修改过，使两个aistand_in使用相同的代理颜色却不一样，从而产生错误（原因未知）。解决办法：1.改会原来的材质。2.修改使用两个不同的代理文件。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="排错记录" scheme="http://mirrorcg.github.io/tags/%E6%8E%92%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    
    <category term="锦囊小妙招" scheme="http://mirrorcg.github.io/tags/%E9%94%A6%E5%9B%8A%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Maya软件小知识点</title>
    <link href="http://mirrorcg.github.io/posts/20220503a4.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a4.html</id>
    <published>2022-05-03T07:54:38.000Z</published>
    <updated>2022-08-24T15:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>贴图色彩空间被锁定的情况，解锁所有节点贴图的贴图色彩空间选项：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmdsfor i in cmds.ls(type&#x3D;&#39;file&#39;):    cmds.connectAttr(&quot;:defaultColorMgtGlobals.cme&quot;,i+&quot;.cme&quot;,f&#x3D;1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>脚本切换渲染器:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">cmds.setAttr(&quot;defaultRenderGlobals.currentRenderer&quot;, &quot;arnold&quot;, type&#x3D;&quot;string&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取当前视图快照拍屏：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">ws &#x3D; cmds.workspace(q &#x3D; True, fullName &#x3D; True)wsp &#x3D; ws + &quot;&#x2F;&quot; + &quot;images&quot;imageSnapshot &#x3D; wsp + &quot;&#x2F;&quot; + &quot;endSnapshot.jpg&quot;cmds.refresh(cv&#x3D;True, fe &#x3D; &quot;jpg&quot;, fn &#x3D; imageSnapshot)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>脚本设置渲染设置的输出序列图选项：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">mc.setAttr(&quot;defaultRenderGlobals.animation&quot;, True)  # 开启动画帧序列mc.setAttr(&quot;defaultRenderGlobals.animationRange&quot;,1)  # 开启动画帧的范围mc.setAttr(&quot;defaultRenderGlobals.outFormatControl&quot;, 1)  # 设置帧格式mc.setAttr(&quot;defaultRenderGlobals.putFrameBeforeExt&quot;, 1) # 设置图片格式在数字后面（name.#.ext）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建多相机渲染：</p><ul><li>选择相机&gt;AtteibutsEdit&gt;OutputSettings&gt;Renderable(勾选)</li><li>RenderSetting&gt;RednderableCamera&gt;Add RenderableCamera</li></ul></li><li><p>Arnold开关运动模糊要同时设置运动模糊可见性:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">mc.setAttr(&quot;defaultRenderGlobals.motionBlur&quot;, 0) #关闭运动模糊（针对于Arnold）mc.setAttr(&quot;defaultArnoldRenderOptions.motion_blur_enable&quot;, 0) #关闭运动模糊可见性mc.setAttr(&quot;defaultRenderGlobals.motionBlur&quot;, 1) #开启运动模糊mc.setAttr(&quot;defaultArnoldRenderOptions.motion_blur_enable&quot;, 1) #开启运动模糊可见性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>脚本打印部分渲染节点属性名称和值的方式:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds render_glob &#x3D; &quot;defaultRenderGlobals&quot;list_Attr &#x3D; cmds.listAttr(render_glob, r&#x3D;True, s&#x3D;True)for attr in list_Attr:    get_attr_name &#x3D; &quot;%s.%s&quot;%(render_glob, attr)    print &quot;setAttr %s %s&quot;%(get_attr_name, cmds.getAttr(get_attr_name))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>mtoa 创建和访问AOV:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import mtoa.aovs as aovs# 添加aovaovs.AOVInterface().addAOV(&#39;aov名称&#39;, aovType&#x3D;&#39;float&#39;)# 列出活动状态的aovsaovs.AOVInterface().getAOVs()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Arnold代码加载arnold渲染器并创建默认节点：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcimport mtoa.coremc.setAttr(&quot;defaultRenderGlobals.currentRenderer&quot;,&quot;arnold&quot;,typ&#x3D;&quot;string&quot;)mtoa.core.createOptions()  # 创建ar默认节点网络<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看 mel 函数帮助：<br>使用 “whatIs ‘mel命令’;” 可以查看mel函数帮助。</p></li><li><p>设置maya视图窗口为非显卡（不使用显卡）支持的窗口模式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcdef switch_preview():    all_model_panel &#x3D; mc.getPanel(typ&#x3D;&quot;modelPanel&quot;)    for each in all_model_panel:        mc.modelEditor(each,e&#x3D;True,rnm&#x3D;&quot;base_OpenGL_Renderer&quot;)  # 查询可用的渲染器名称 mc.modelEditor(each,q&#x3D;True,rendererList&#x3D;True) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Xgen相关:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import xgenm.xmaya.xgmExternalAPI as xgenmExternalAPIimport xgenm as xgpalettes &#x3D; xg.palettes()  # 获取Xgen 所有描述if not (xgenmExternalAPI.xgg.DescriptionEditor is None):    xgenmExternalAPI.xgg.DescriptionEditor.refresh(&quot;Full&quot;)  # 刷新所有Xgen面板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>开启软件时关闭材质刷新</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cmds.scriptJob(event&#x3D;(&#39;SceneOpened&#39;,&#39;cmds.renderThumbnailUpdate(False)&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>添加回调</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.OpenMaya as OpenMayaOpenMaya.MSceneMessage().addCallback(37, funcName)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>清除进程任务</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymel.core.language as pcl_jobs &#x3D;pcl.scriptJob(lj&#x3D;1)#.清除内存任务 if._jobs:for _job in _jobs:    job_id &#x3D; int(_job.split(&#39;:&#39;)[0])    print(u&#39;清除进程任务:%s&#39; % _job)     try:        pcl.scriptJob(kill&#x3D;job_id, force&#x3D;True)    except:        pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="排错记录" scheme="http://mirrorcg.github.io/tags/%E6%8E%92%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    
    <category term="锦囊小妙招" scheme="http://mirrorcg.github.io/tags/%E9%94%A6%E5%9B%8A%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Maya软件小问题集锦</title>
    <link href="http://mirrorcg.github.io/posts/20220503a3.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a3.html</id>
    <published>2022-05-03T07:02:20.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了一些Maya中出现的一些小问题：<span id="more"></span></p><ol><li><p>AOV无法正常创建</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcmc.lockNode(&#39;initialParticleSE&#39;,l&#x3D;0,lu&#x3D;0)mc.lockNode(&#39;initialShadingGroup&#39;,l&#x3D;0,lu&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Maya 操作总是提示 “&#x2F;&#x2F; Error: line 1: Cannot find procedure “onModelChange3dc”. &#x2F;&#x2F;“，这可能是模型制作的时候打开了某个窗口，maya在关闭的时候会保存一份配置在maya文件里，可以从Expression Editor的By Script Node Name里看到，虽然没什么影响，但是真的很烦。解决办法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymel.core as pm# 获取Maya中的所有模型编辑器并重置 editorChanged 事件for item in pm.lsUI(editors&#x3D;True):   if isinstance(item, pm.ui.ModelEditor):       pm.modelEditor(item, edit&#x3D;True, editorChanged&#x3D;&quot;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>RenderSetting渲染面板内容空白，执行mel脚本:</p><pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">deleteUI unifiedRenderGlobalsWindow;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>关闭“cannot find procedrure ‘look’”：</p><ul><li><p>执行mel脚本:</p><ul><li>方法一：<pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>方法二：<pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">global proc look()&#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>执行python脚本:</p> <pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">maya.mel.eval(&#39;outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;&#39;) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>删除TurtleDefaultBakeLayer层：</p><ul><li><p>执行mel脚本</p> <pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">&#x2F;&#x2F;删除海龟渲染 mel脚本lockNode -l off TurtleDefaultBakeLayer;delete TurtleDefaultBakeLayer;lockNode -l off TurtleRenderOptions;delete TurtleRenderOptions;lockNode -l off TurtleBakeLayerManager;delete TurtleBakeLayerManager;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行python脚本</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">def delTurtleRender():    if mc.objExists(&#39;TurtleRenderOptions&#39;):        mc.lockNode(&#39;TurtleRenderOptions&#39;, &#39;TurtleUIOptions&#39;, &#39;TurtleBakeLayerManager&#39;, &#39;TurtleDefaultBakeLayer&#39;, lock&#x3D;0)        mc.delete(&#39;TurtleRenderOptions&#39;, &#39;TurtleUIOptions&#39;, &#39;TurtleBakeLayerManager&#39;, &#39;TurtleDefaultBakeLayer&#39;)        print u&quot;海龟渲染节点清理完成&quot;    else:        print u&quot;场景中海龟渲染节点已清理干净&quot;delTurtleRender()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Maya Arnold不能渲染:<br> &#x2F;&#x2F; Rendering with Arnold Renderer… &#x2F;&#x2F;<br> &#x2F;&#x2F; Result: Rendering Completed. See mayaRenderLog.txt for information. &#x2F;&#x2F;<br> 是因为Maya 的mtoa环境变量丢失，导致渲染器使用的部分文件没有调用到，因此直接结束渲染。<br> 解决办法：<br> <a href="https://support.solidangle.com/display/AFMUG/Batch+Rendering">https://support.solidangle.com/display/AFMUG/Batch+Rendering</a> 的Batch Render Flags   提到了解决问题的办法，就是在环境变量中增加如下环境变量（对应maya版本号）：<br> MAYA_RENDER_DESC_PATH&#x3D;C:\solidangle\mtoadeploy\对应maya版本号<br> 然后，重新打开maya渲染。或者，重新安装渲染器，此办法有概率解决问题。</p></li><li><p>高版本Maya(2020以上)不能加载Arnold渲染器的问题：需要打补丁程序VC_redist.x64.exe。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录了一些Maya中出现的一些小问题：</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="排错记录" scheme="http://mirrorcg.github.io/tags/%E6%8E%92%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    
    <category term="锦囊小妙招" scheme="http://mirrorcg.github.io/tags/%E9%94%A6%E5%9B%8A%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Maya文件打开慢或者崩溃的检查办法</title>
    <link href="http://mirrorcg.github.io/posts/20220503a2.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a2.html</id>
    <published>2022-05-03T06:07:21.000Z</published>
    <updated>2022-05-03T07:07:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目制作过程中常常会遇到制作文件打不开或者打开慢的情况，对于此类问题：<span id="more"></span></p><ol><li><p>如果是’.mb’文件，会比较麻烦些，需要在打开文件时不加载引用文件，然后一个一个加载引用文件，根据引用文件的加载情况进行判断是否有引用文件有问题。一般会出现：单个引用文件加载崩溃、单个引用文件加载慢、所有引用文件加载都没问题，但是保存后还是打开有问题，这时就需要分别尝试打开带有加载不同引用文件的maya文件。（之前碰到过引用文件中有的节点有冲突：相同的引用文件单独加载都没问题，但保存后加载会崩溃，然后逐步定位加载有问题的文件一步一步排除，最后将有冲突的节点重建才解决问题。）</p></li><li><p>如果是’.ma’文件：</p><ul><li>使用上面的’.mb’文件的办法。</li><li>在文件中插入 mel 脚本，在打开脚本的同时，执行mel脚本，通过脚本的日志内容情况来判断是什么文件导致的‘.ma’文件打不开，或者打开慢的情况。</li></ul></li></ol><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import codecsdef checkMayaAsciiFile(source_file, target_file, log_file):    &quot;&quot;&quot;    1. 用于检查 Maya Ascii 文件打开崩溃    2. - - - - - - - - - - - - - -耗时    Args:        source_file: ma 文件        target_file: 修改后的文件        log_file: logging    Returns: none    &quot;&quot;&quot;    # # 记录打不开的ma文件是从哪一行崩溃的    # __startMel &#x3D; &#39;&#39;&#39;python(&quot;logFile&#x3D;&#39;%s&#39;;ff &#x3D; open(logFile,&#39;w&#39;);ff.write(&#39; &#39;);ff.close();&quot;);&#39;&#39;&#39; % log_file    # __proc &#x3D; &#39;&#39;&#39;python(&quot;ff &#x3D; open(logFile,&#39;a&#39;);ff.write(&#39;%s - &#123;0&#125;\\\\n&#39;.format(comp_time));ff.close();&quot;);\n&#39;&#39;&#39;    # __endMel &#x3D; &quot;&quot;    # 记录打开文件时的耗时信息    __startMel &#x3D; &#39;&#39;&#39;python(&quot;from datetime import datetime;import time;line_time&#x3D;datetime.now();time.sleep(0.002);threshold_time&#x3D;datetime.now() - line_time;start_time&#x3D;line_time;logging&#x3D;list();logFile&#x3D;&#39;%s&#39;&quot;);&#39;&#39;&#39; % log_file    __proc &#x3D; &#39;&#39;&#39;python(&quot;comp_time &#x3D; datetime.now() - line_time;logging.append(&#39;%s - &#39;+ str(comp_time)) if comp_time &gt; threshold_time else None;line_time &#x3D; datetime.now();&quot;);\n&#39;&#39;&#39;    __endMel &#x3D; &#39;&#39;&#39;python(&quot;logging.append(&#39;\\\\n\\\\nStart Time - &#39;+ str(start_time) + &#39;\\\\nEnd Time - &#39;+ str(line_time) + &#39;\\\\nTotal Time - &#39; + str(line_time - start_time));ff &#x3D; open(logFile,&#39;w&#39;);[ff.write(line+&#39;\\\\n&#39;) for line in logging];ff.close();&quot;);&#39;&#39;&#39;    with codecs.open(source_file, &quot;r&quot;, &quot;gbk&quot;) as f:        aLines &#x3D; f.readlines()    fileter &#x3D; (&quot;select&quot;, &quot;connectAttr&quot;, &quot;dataStructure&quot;, &quot;createNode&quot;, &quot;requires&quot;, &quot;currentUnit&quot;)    # other relationship fileInfo    rule &#x3D; 1    for num, line in enumerate(aLines):        line_add &#x3D; &quot;&quot;.join([aLines[num - 1][:-1], __proc % str(num)])        if rule:  # 文件开头的 file 每一行都加 mel            if __startMel:  # 文件开头结尾初始化命令                aLines[num] &#x3D; __startMel + line                if __endMel:                    aLines[num - 1] &#x3D; __endMel + aLines[num - 1]                __startMel &#x3D; 0                continue            if &quot;file&quot; in line:  # 可能有的设置里会有file字符串,所以这里要独立规则                if &quot;;\n&quot; not in aLines[num - 1]:                    continue                aLines[num - 1] &#x3D; line_add            if &quot;requires&quot; in line:  # requires 之后改变规则                rule &#x3D; 0        # 在 fileter 参数里的,对它的前一行添加 mel        # setAttr 用的是 .attr 的方式,在它之后加 mel 会影响下一个 setAttr 所以这里添加这个过滤        for _ in fileter:            if _ in line:                if &quot;;\n&quot; in aLines[num - 1]:                    aLines[num - 1] &#x3D; line_add    with codecs.open(target_file, &quot;w&quot;, &quot;gbk&quot;) as ff:        for lines in aLines:            ff.write(lines)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    srcFile &#x3D; r&quot;E:\test\shot00401.ma&quot;    srcFile &#x3D; srcFile.replace(&quot;\\&quot;, &quot;&#x2F;&quot;)    sourceFile &#x3D; srcFile    targetFile &#x3D; srcFile[:-3] + &quot;_v01.ma&quot;    logFile &#x3D; srcFile[:-3] + &quot;_v01.txt&quot;    # print(sourceFile, targetFile, logFile)    checkMayaAsciiFile(sourceFile, targetFile, logFile)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，需要将”E:\test\shot00401.ma”替换成你的‘.ma’文件路径，执行完成后，会在同级文件目录下生成一个版本号为‘-v01’的‘.ma’文件，使用Maya打开该文件，打开文件的同时会执行文件中的mel脚本保存日志信息，文件读取完成后，也会在统计目录下生成一个版本号为‘-v01’的txt日志文件，打开文件分析即可。</p><h4 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h4><p>部分内容转载自：<a href="https://ruben.blog.csdn.net/article/details/90082639">https://ruben.blog.csdn.net/article/details/90082639</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目制作过程中常常会遇到制作文件打不开或者打开慢的情况，对于此类问题：</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="小工具" scheme="http://mirrorcg.github.io/categories/Maya/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="检查" scheme="http://mirrorcg.github.io/tags/%E6%A3%80%E6%9F%A5/"/>
    
    <category term="排错记录" scheme="http://mirrorcg.github.io/tags/%E6%8E%92%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
