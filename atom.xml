<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mirror的个人博客</title>
  
  <subtitle>Mirror的博客</subtitle>
  <link href="http://mirrorcg.github.io/atom.xml" rel="self"/>
  
  <link href="http://mirrorcg.github.io/"/>
  <updated>2022-07-29T15:16:15.000Z</updated>
  <id>http://mirrorcg.github.io/</id>
  
  <author>
    <name>Mirror</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maya中Xgen毛发渲染问题</title>
    <link href="http://mirrorcg.github.io/posts/20220729a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220729a1.html</id>
    <published>2022-07-29T15:16:15.000Z</published>
    <updated>2022-07-29T15:16:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了一些Maya中Xgen毛发渲染的相关的问题：<span id="more"></span></p><ol><li>Xgen 毛发渲染运动模糊时，角色ABC和毛发ABC的运动迷糊不匹配的问题（小概率事件）：<p style="text-indent:2em">原因是生长面缓存只有整数帧采样并且在渲染运动模糊时，Xgen没有计算生长面的插值,或者由于前后帧的运动差异过大，Xgen计算出错误的生长面插值，导致毛发生长面的缓存和角色缓存的插值不匹配，生长面缓存和角色缓存在小数帧位置不同，就会导致运动模糊不同。也可以通过实际文件观测到，在运动模糊有问题的小数帧，毛发不加载缓存时，其毛发引导线跟随动画缓存，加载了毛发缓存后，毛发缓存曲线和动画缓存的位置一致，而毛发引导线却和缓存曲线不在相同的位置，毛发引导线和动画缓存脱离，但是毛发引导线的形态和毛发缓存一致，说明毛发引导线只是从毛发缓存继承了形态，并不继承其位置。而毛发引导线的位置是从毛发生长面继承的，此时毛发引导线的位置和动画缓存不一致，那么小数帧时生长面的缓存和动画缓存位置不一致，因此，毛发生长面缓存在计算小数帧时有问题。解决此类问题，最好为动画缓存、曲线缓存、生长面缓存都添加缓存的小数帧采样插值。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录了一些Maya中Xgen毛发渲染的相关的问题：</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Deadline中调试编写的事件</title>
    <link href="http://mirrorcg.github.io/posts/20220721a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220721a1.html</id>
    <published>2022-07-21T15:55:44.000Z</published>
    <updated>2022-07-21T17:09:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h4><p style="text-indent:2em">Deadline 事件依赖于其软件框架，不能进行实时调试，但是可以通过 Console 窗口快速获取获取事件反馈信息。</p><span id="more"></span><p style="text-indent:2em">若想快速查看事件处理的过程，获取结果，首先通过Panels > Console 开启 Console 窗口。</p><p><img src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/Console.jpg" alt="Console图片" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/Console.jpg" class="lozad post-image"></p><p style="text-indent:2em">对于事件编写，除了要先配置正确的事件文件以外，还要在代码中加入打印（可通过 DeadlineEventListener 类的 self.LogInfo 或者 print 等方法将调试信息写入代码中，或通过ClientUtils.LogText(str)方法将信息写入 Deadline 的日志文件中），由于 Deadline 会每隔一段时间才会扫描储存库，扫描的默认值一般为5分钟，当扫描过程中发现事件脚本有新的修改时，才会将修改的事件脚本重新构建到任务中，所以，为了让 Deadline 后台及时更新并构建我们修改的事件脚本，我们需要通过Tools > Synchronize Monitor Script and Plugins 功能手动更新事件脚本。</p><p><img src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC.jpg" alt="同步脚本" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E8%B0%83%E8%AF%95%E7%BC%96%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6/%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC.jpg" class="lozad post-image"></p><p style="text-indent:2em">此时，Console 窗口会提示：***事件脚本有修改，将重新构建事件脚本的提示语。如果你的脚本有语法错误，Console 窗口还会给你打印一条简短的报错信息。然后 Requeue 目标任务，再将任务切换到我们所要的任务状态（先更新脚本，再操作任务，不能先操作任务再更新脚本，否则，事件不会被更新到任务状态中），Deadline 便会通过当前执行任务的机器执行事件脚本，并在Console 窗口显示反馈信息。通过此方法，可以快速对我们的事件脚本进行编写和调试。</p><h4 id="关于事件脚本中使用中文"><a href="#关于事件脚本中使用中文" class="headerlink" title="关于事件脚本中使用中文"></a>关于事件脚本中使用中文</h4><p style="text-indent:2em">有时会想在日志中打印中文信息，则我们需要将中文字符串解码为"utf8"的人类可读懂的代码。需要注意的是：</p><ul><li>了解事件脚本文件在储存时，使用的编码格式，以及系统文件流的编码格式。不仅如此，我们还会在 python 脚本文件中加入 “# -<em>- coding:utf-8 -</em>-” 类型的注释，因此需要做相应的修改。</li><li>中文字符很容易出错，导致插件执行被打断却没有任何反馈信息的假成功状态，这是由于当Deadline后台检测脚本有字符转换的错误时，它可不执行事件脚本。</li></ul><pre class="language-python" data-language="python"><code class="language-python">self.LogInfo(&quot;测试打印&quot;.decode(&quot;utf8&quot;))</code></pre><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/2_Scripting%20Reference/index.html" title="" target="">官方文档中事件脚本文档</a></br><a href="http://www.mirrorcg.com/posts/20220306a1.html" title="" target="">往期相关文章：Deadline中的事件示例</a>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;详情&quot;&gt;&lt;a href=&quot;#详情&quot; class=&quot;headerlink&quot; title=&quot;详情&quot;&gt;&lt;/a&gt;详情&lt;/h4&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;Deadline 事件依赖于其软件框架，不能进行实时调试，但是可以通过 Console 窗口快速获取获取事件反馈信息。&lt;/p&gt;</summary>
    
    
    
    <category term="Deadline" scheme="http://mirrorcg.github.io/categories/Deadline/"/>
    
    <category term="插件" scheme="http://mirrorcg.github.io/categories/Deadline/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="插件" scheme="http://mirrorcg.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>CG流程中的ACES概念解释</title>
    <link href="http://mirrorcg.github.io/posts/20220706a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220706a1.html</id>
    <published>2022-07-06T15:18:49.000Z</published>
    <updated>2022-07-06T15:18:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="ACES-一些散记"><a href="#ACES-一些散记" class="headerlink" title="ACES 一些散记"></a>ACES 一些散记</h4><p>  经过IDT转换的图片只能保证其在AECS色域中渲染的颜色信息和ACES相比较是正确的，不能保证渲染的效果和SRGB的原效果一致。<br>  线性图和非线性图的区别在于是否经过Gamma1.8到gamma2.2的曲线矫正,矫正的目的是为了迎合人眼观察的同时，方便使用8位图存储色彩信息。浮点图没有色彩存储空间不够的情况，因此浮点图一般是线性图。<br>  ACES推荐使用EXR、TIF、HDR等浮点图存储信息，最少使用16位(exr是HDR标准的图片格式，拥有多通道存储的能力，使用1位、5位、10位分段分别存储不同的信息)。<br>  CG流程中ODT用于ACES到SRGB色域的转换，通常是使用‘output_srgb’类型。<br>  Maya中输出的16位ACES图和32位图色彩信息有些许肉眼可见的不同。请自行测试。</p><h4 id="一些文章参考"><a href="#一些文章参考" class="headerlink" title="一些文章参考"></a>一些文章参考</h4><br><p style="text-indent:2em">国内网页：</p><a href="https://www.bilibili.com/video/BV1jM4y1N7yT?spm_id_from=444.41.top_right_bar_window_default_collection.content.click&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">ACES编码及色彩原理（CG）</a><br><a href="https://www.bilibili.com/video/BV1Fg411M7H6?p=1&share_medium=android&share_plat=android&share_session_id=665fc73f-fd8b-484a-9cb2-7bf453d6035e&share_source=WEIXIN&share_tag=s_i&timestamp=1656295742&unique_k=SDBzFDb&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">ACES通俗讲解</a><br><a href="https://www.bilibili.com/read/cv9842761" title="" target="">色彩原理</a><br><a href="https://www.bilibili.com/video/BV1dV411i7M1?spm_id_from=333.788.top_right_bar_window_default_collection.content.click&vd_source=171f08b062938f0a4038de13d7e2c9a2" title="" target="">Nuke色彩空间（Gamma）的转换和原理</a><br><a href="https://www.shangyexinzhi.com/article/1960438.html" title="" target="">参考文章1</a><br><a href="https://www.toadstorm.com/blog/?p=694" title="" target="">参考文章2</a><br><a href="https://chrisbrejon.com/cg-cinematography/chapter-1-5-academy-color-encoding-system-aces/" title="" target="">参考文章3</a><br><br><p style="text-indent:2em">以下需科学上网：</p><a href="https://www.youtube.com/watch?v=W9Z1Std_1Kc" title="" target="">ACES Workflow in Maya with Redshift and Arnold</a>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Doc/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="灯光合成" scheme="http://mirrorcg.github.io/tags/%E7%81%AF%E5%85%89%E5%90%88%E6%88%90/"/>
    
    <category term="ACES" scheme="http://mirrorcg.github.io/tags/ACES/"/>
    
  </entry>
  
  <entry>
    <title>Maya中常用的部分环境变量</title>
    <link href="http://mirrorcg.github.io/posts/20220521a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220521a1.html</id>
    <published>2022-05-21T13:33:36.000Z</published>
    <updated>2022-07-25T14:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录 maya 中常用的部分环境变量。<span id="more"></span></p><ul><li>MAYA_ENABLE_LEGACY_RENDER_LAYERS      开启旧版灯光渲染分层系统（maya2017以后可使用）</li></ul><p>屏蔽 maya 连接网络</p><ul><li>MAYA_DISABLE_CIP &#x3D; 1</li><li>MAYA_DISABLE_CLIC_IPM &#x3D; 1</li><li>MAYA_DISABLE_CER &#x3D; 1</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录 maya 中常用的部分环境变量。</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
    <category term="环境变量" scheme="http://mirrorcg.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows任务计划</title>
    <link href="http://mirrorcg.github.io/posts/20220510a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220510a1.html</id>
    <published>2022-05-10T04:51:16.000Z</published>
    <updated>2022-05-10T05:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>工作中有时需要定时执行一些规律性的脚本操作<span id="more"></span>，比如，清除磁盘垃圾、定时下载任务等。这些任务执行虽然简单，但是需要人力进行日常维护。通常有两种方式可以方便处理这类型任务：</p><ol><li>以本机作为脚本任务的执行者，开启电脑后，通过ide运行任务，但是每次开机都需要手动执行，或者将程序打包成exe程序再放入启动文件夹。</li><li>以本机作为服务器，通过任务计划的触发器，自动执行指定任务，不需要每次开机后再手动执行。</li></ol><p>下面将介绍第二种方式——任务计划</p><ul><li><p>打开计划任务程序</p><table><tr><td><img src="/images/Windows任务计划/打开管理工具.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Windows任务计划/打开管理工具.png" class="lozad post-image"></td><td><img src="/images/Windows任务计划/任务计划程序.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Windows任务计划/任务计划程序.png" class="lozad post-image"></td></tr></table></li><li><p>创建一个新的任务计划文件夹（推荐）或在“任务计划程序库”中创建基本任务:提一下”创建基本任务”和”创建任务”的区别是一个有引导界面，一个直接弹出设置界面直接设置。</p></li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1.png" alt="创建基本任务 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1.png" class="lozad post-image">  </p><ul><li>输入任务名称和描述。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%BE%93%E5%85%A5%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0.png" alt="输入任务名称和描述 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%BE%93%E5%85%A5%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0.png" class="lozad post-image">  </p><ul><li>选择触发器，修改触发器触发的时间和间隔，这里暂时只能创建一个触发器，我们可以创建完任务计划后进行添加或修改触发器。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="选择触发器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E8%A7%A6%E5%8F%91%E5%99%A8.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E4%BF%AE%E6%94%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E9%80%89%E9%A1%B9.png" alt="修改触发器选项 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E4%BF%AE%E6%94%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E9%80%89%E9%A1%B9.png" class="lozad post-image"> </p><ul><li>选择任务操作，并填入相关参数，这里很重要，它可以决定你的任务计划是否正常执行，原则上越简单越好（后面会进行详解）；然后点击完成。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C.png" alt="选择任务操作 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E9%80%89%E6%8B%A9%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%84%9A%E6%9C%AC.png" alt="设置启动程序的脚本 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%84%9A%E6%9C%AC.png" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%AE%8C%E6%88%90%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1.png" alt="完成创建任务 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%AE%8C%E6%88%90%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1.png" class="lozad post-image"> </p><ul><li>“创建基本任务”完成后，我们还需要对其进行一些的修改；选择任务点击属性对任务进行修改。</li></ul><p><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%B8%B8%E8%A7%84%E8%AE%BE%E7%BD%AE.jpg" alt="常规设置 jpg" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E5%B8%B8%E8%A7%84%E8%AE%BE%E7%BD%AE.jpg" class="lozad post-image"><br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="触发器 png" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%A7%A6%E5%8F%91%E5%99%A8.png" class="lozad post-image"><br>  “操作”项暂不做修改；”条件”项也比较简单，都是字面意思，这里不做讲解；<br><img src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E8%AE%BE%E7%BD%AE.jpg" alt="设置设置 jpg" srcset="/images/home/Myhead.jpg" data-src="/images/Windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/%E8%AE%BE%E7%BD%AE%E8%AE%BE%E7%BD%AE.jpg" class="lozad post-image"><br>  note：每次手动运行任务后，若任务状态没有更改成预期状态，可通过右键任务选择“刷新”选项进行任务状态的刷新。</p><ul><li>关于”操作”项中的设置需要注意：由于我们使用的是.bat脚本中通过python程序调用.py脚本，因此这里的”程序或脚本”填入 XXX\test.bat(不加引号)，”添加参数（可选）”为空，“起始于（可选）”则是.py文件所在的目录，而不是执行程序或者.bat脚本所在的目录，否则执行的结果会出错；若不填(缺省状态)，那么自动将该处的目录位置定位到”程序或脚本”的目录位置。并且调用的程序需要传入参数，例如”程序或脚本”填入Python编译器路径 C:\Python27\python.exe ，而”添加参数（可选）”为.py文件，那么“起始于（可选）”则是.py文件所在的目录。最后说一下，任务计划中所用到的所有的文件最好放置在本地路径。</li></ul><h4 id="实践踩坑和解决办法"><a href="#实践踩坑和解决办法" class="headerlink" title="实践踩坑和解决办法"></a>实践踩坑和解决办法</h4><p style="text-indent:2em">在这次工作中由于需要每天调用pythonAPI对程序的服务端进行调整，因此使用了任务计划调用bat脚本的方式执行任务。该bat脚本中，仅简单的一句'XXX/python.exe XXX/XXX/xxx.py'---使用编译器编译python脚本，该任务在我本机上执行没有任务问题，于是将任务计划部署到农场机器上，此时任务就出现了问题：创建的任务不会成功执行，或者执行结果不为'成功执行（0X0）',或者执行结果为'成功执行（0X1）'（失败状态）或者直接失败，找了很久的原因，排除几乎所有的可能性（计算机休眠、计算机系统配置不对、任务权限不够、bat脚本有问题、.py脚本有问题、任务手动运行后状态没有及时切换导致新实例不能创建、不能访问网络盘资源、脚本“起始于（可选）”参数不对、执行程序带引号等等）。最后本着"越简单越好"的原则，直接将bat脚本拆开，将python编译器的位置填入"程序或脚本"，"添加参数（可选）"填入.py脚本，“起始于（可选）”填入.py脚本路径，问题才得到解决。</p><p style="text-indent:2em">猜测和计算机系统有关，由于我本机使用的是Windows10 的操作系统，而农场机使用的是Windows server2012 的操作系统。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>官方介绍：<a href="https://forsenergy.com/zh-cn/gpmc/html/688d2d42-454a-4e2e-90c0-557f959d49b0.htm">https://forsenergy.com/zh-cn/gpmc/html/688d2d42-454a-4e2e-90c0-557f959d49b0.htm</a><br>参考文章：<a href="https://www.jianshu.com/p/c627c77f6ea3">https://www.jianshu.com/p/c627c77f6ea3</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作中有时需要定时执行一些规律性的脚本操作</summary>
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    
    <category term="windows" scheme="http://mirrorcg.github.io/tags/windows/"/>
    
    <category term="排错记录" scheme="http://mirrorcg.github.io/tags/%E6%8E%92%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Deadline如何使用PythonAPI</title>
    <link href="http://mirrorcg.github.io/posts/20220505a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220505a1.html</id>
    <published>2022-05-05T12:46:35.000Z</published>
    <updated>2022-05-05T12:46:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p style="text-indent:2em">本文介绍如何使用 Deadline 的 Python API 操作Deadline。<span id="more"></span>通过 Python API 可在 Python 中与 HTTP API 通信。</p><h4 id="拷贝-PythonAPI-模块"><a href="#拷贝-PythonAPI-模块" class="headerlink" title="拷贝 PythonAPI 模块"></a>拷贝 PythonAPI 模块</h4><p style="text-indent:2em">首先在使用 API 之前，需要配置python环境使我们可以调用到 API。我们需要安装和使用 python2.7.9或 3.7 以上的python版本，然后将 Deadline 储存库路径（//your/repository/api/python）下的整个“Deadline”文件夹复制到Python 安装路径下的的“site-packages”文件夹，API 即可调用。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E6%8B%B7%E8%B4%9DPythonAPI.png" alt="Deadline拷贝PythonAPI" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E6%8B%B7%E8%B4%9DPythonAPI.png" class="lozad post-image"></p><h4 id="开启-WebService-服务"><a href="#开启-WebService-服务" class="headerlink" title="开启 WebService 服务"></a>开启 WebService 服务</h4><p style="text-indent:2em">我们还需要通过 WebService 通信以发送和接收请求，因此，还要在 Deadline 管理的局域网中的任何一台可见的设备上运行 WebService服务，该服务为“C:\Program Files\Thinkbox\Deadline10\bin\deadlinewebservice.exe”，打开后，我们就可以通过该设备的设备名称或者Ip地址进行通讯，API访问的端口默认情况下为8082。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/DeadlineWebServer.png" alt="DeadlineWebServer" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/DeadlineWebServer.png" class="lozad post-image"></p><h4 id="使用-PythonAPI"><a href="#使用-PythonAPI" class="headerlink" title="使用 PythonAPI"></a>使用 PythonAPI</h4><p style="text-indent:2em">使用时，必须创建一个 DeadlineCon 对象。该对象用于与 WebService 通信以发送和接收请求，该对象需要两个参数：“运行 WebService 服务的设备名或IP地址”、“该设备上允许 WebService 通信的端口号（默认为8082）”，这两个参数可以从已经运行的 WebService 通讯服务上找到。</p><p><img src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="Deadline设备名称和端口号" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PythonAPI/Deadline%E8%AE%BE%E5%A4%87%E5%90%8D%E7%A7%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" class="lozad post-image"></p><p>然后我们就可以使用API创建一个连接对象“connectionObject &#x3D; Deadline.DeadlineConnect.DeadlineCon(‘WebServiceName’, WebServicePortNumber)”， 通过该对象，我们可以查询、修改 Deadline 上的大部分信息。</p><p>示例代码1：查询作业组、暂停指定作业</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import Deadline.DeadlineConnect as Connect  # 导入 Deadline.DeadlineConnect 作为连接connectionObject &#x3D; Connect.DeadlineCon(&#39;DESKTOP-Mirror&#39;, 8082)print(connectionObject.Groups.GetGroupNames())#[&quot;group1&quot;,&quot;group2&quot;,&quot;group3&quot;]jobId &#x3D; &quot;622c38262812473ba4c08eca&quot;  #(有效的job ID号)print(connectionObject.Jobs.SuspendJob(jobId))# &#39;Success&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码2：提交作业</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import Deadline.DeadlineConnect as ConnectDeadline &#x3D; Connect.DeadlineCon(&#39;DESKTOP-Mirror&#39;, 8082)JobInfo &#x3D; &#123;    &quot;Name&quot;: &quot;Submitted via Python&quot;,    &quot;UserName&quot;: &quot;UserName&quot;,    &quot;Frames&quot;: &quot;0-1&quot;,    &quot;Plugin&quot;: &quot;VraySpawner&quot;&#125;PluginInfo &#x3D; &#123;    &quot;Version&quot;: &quot;Max2014&quot;&#125;try:    newJob &#x3D; connectionObject.Jobs.SubmitJob(JobInfo, PluginInfo)    print(newJob)except:    print(&quot;Sorry, Web Service is currently down!&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li>官方说明：<a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/3_Python%20Reference/index.html#intro_sec">https://docs.thinkboxsoftware.com/products/deadline/10.1/3_Python%20Reference/index.html#intro_sec</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;本文介绍如何使用 Deadline 的 Python API 操作Deadline。</summary>
    
    
    
    <category term="Deadline" scheme="http://mirrorcg.github.io/categories/Deadline/"/>
    
    <category term="插件" scheme="http://mirrorcg.github.io/categories/Deadline/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="插件" scheme="http://mirrorcg.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Maya中材质文件和缓存文件相结合进行渲染的几种方式</title>
    <link href="http://mirrorcg.github.io/posts/20220503a6.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a6.html</id>
    <published>2022-05-03T08:48:37.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p style="text-indent:2em">本文记录材质文件和缓存文件相结合，组装渲染镜头文件的几种方式.<span id="more"></span></p><h3 id="缓存驱动材质文件进行渲染"><a href="#缓存驱动材质文件进行渲染" class="headerlink" title="缓存驱动材质文件进行渲染"></a>缓存驱动材质文件进行渲染</h3><p>使用缓存文件驱动材质文件的方式进行渲染。</p><h3 id="缓存文件直接替换材质文件的几何体进行渲染"><a href="#缓存文件直接替换材质文件的几何体进行渲染" class="headerlink" title="缓存文件直接替换材质文件的几何体进行渲染"></a>缓存文件直接替换材质文件的几何体进行渲染</h3><h3 id="缓存文件包裹材质文件进行渲染"><a href="#缓存文件包裹材质文件进行渲染" class="headerlink" title="缓存文件包裹材质文件进行渲染"></a>缓存文件包裹材质文件进行渲染</h3><h3 id="给缓存文件赋予材质进行渲染"><a href="#给缓存文件赋予材质进行渲染" class="headerlink" title="给缓存文件赋予材质进行渲染"></a>给缓存文件赋予材质进行渲染</h3>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;本文记录材质文件和缓存文件相结合，组装渲染镜头文件的几种方式.</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
    <category term="灯光" scheme="http://mirrorcg.github.io/tags/%E7%81%AF%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>Maya软件渲染问题集锦</title>
    <link href="http://mirrorcg.github.io/posts/20220503a5.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a5.html</id>
    <published>2022-05-03T08:01:45.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>渲染崩溃可能的问题：</p><ul><li>被赋予Arnold材质3s散射的物体是片，导致散射时不是在物体内部散射，而是在整个场景中散射，计算量特别大从而崩溃。</li><li>文件中毛发的密度太大导致渲染机内存不够用。</li><li>文件本身有问题。</li><li>具体问题，具体分析。</li></ul></li><li><p>Redshift:提示：’Mesh pCubeShape1 is instanced and uses adaptive tessellation, which isn’t supported. Disabling tessellation. If you need tessellation, please use fixed tessellation settings: i.e. disable ‘screen space adaptive’ and set ‘min edge length’ to zero to force a maximum tessellation level’。对象细分后在实例错误提示：对象在实例化后细分，被实例化对象在屏幕自适应时找不到细分对象，就不会进行细分。如果需要细分，就关闭屏幕自适应，并把最小边缘强度设置为零，以强制使用最大边缘强度，如图：</p><p> <img src="/images/Maya%E8%BD%AF%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/Redshift%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%86%E5%88%86.png" alt="Redshift实例对象自适应细分" srcset="/images/home/Myhead.jpg" data-src="/images/Maya%E8%BD%AF%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/Redshift%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%86%E5%88%86.png" class="lozad post-image"></p></li><li><p>农场机提示找不到可执行渲染的文件：“Katana render executable was not found in the semicolon separated list”（在分号分隔的列表中没有找到Katana渲染的可执行文件），该机器上没有安装相应的软件，或软件没有安装在默认的路径。</p></li><li><p>Cannot find procedure “pgYetiVRayPreRender”（或”pgYetiPreRender”）报错导致渲染暂停：渲染文件中没有Yeti毛发节点，却在渲染文件的渲染设置中填入了“pgYetiVRayPreRender”（或”pgYetiPreRender”）代码，导致渲染器找不到对应的节点而报错，我们只需要打开文件，删除渲染设置中的以下代码就行了（Render Settings &gt; Common &gt; Render Options，删除报错的MEL，一般情况下也可以全部删除）：</p> <table><tr> <td><img src="/images/Maya软件渲染问题集锦/Yeti报错.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/Yeti报错.png" class="lozad post-image"></td> <td><img src="/images/Maya软件渲染问题集锦/删除Yeti报错设置.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/删除Yeti报错设置.png" class="lozad post-image"></td> </tr></table></li><li><p>贴图文件正在上传或修改。日志出现：File“*******”was modified after being opened by OIIO，这是因为文件在渲染的时候，被文件IO读取的贴图文件还在上传或更新中<br> 解决办法：等待贴图上传完成后再渲染文件</p></li><li><p>盘符掉了或没有输出磁盘：<br> 解决办法：映射一个盘符</p> <pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">subst D: C:\D  ::映射D盘盘符到C盘的D文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Deadline农场渲染报错“defaultRenderLayer” is a layer from a referenced and is not allowed to be the current layer ,其可能是之一是：maya 的 renderLayerManage节点被改名导致 maya 不能生成默认的master layer渲染层（在.ma文件中的名称为defaultRenderLayer），因此可以将文件保存为.ma格式的文件，用文本的方式打开，将renderLayerManager节点的名称改为默认的’renderLayerManager’(没有任何修饰)，同时由于默认的renderLayerManager节点已经被修改过，默认的渲染层名称也发生了改变，导致渲染程序在调用的代码中，该层被判定为非默认的渲染层而报错“unable to modify overrides to the default layer”,因此，还需要将文件中的 defaultRenderLayer节点 (本问题记录时该节点名称为 defaultRenderLayer1 ),改为默认的名称defaultRenderLayer，即可。</p></li><li><p>maya动画文件直渲，后台批量渲染时，角色控制器带动角色模型不规则抖动的可能原因：这是旧版绑定系统的问题，这种问题一般可通过走 abc 流程规避，否则需要更新绑定的 cluster 节点选项。禁用”cluster.relative”，并将”cluster.angleInterpolation”的值设置为3，代码如下：</p> <pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">import maya.cmds as mcfor each in mc.ls(typ&#x3D;&quot;cluster&quot;):mc.setAttr(&quot;cluster1.relative&quot;, 0)mc.setAttr(&quot;cluster1.angleInterpolation&quot;, 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>maya动画文件直渲，后台批渲时，动画文件中的约束失效，例如角色对道具的约束丢失或者效果不对；可能原因：</p><ul><li>动画文件后台渲染其中的动力学不出缓存，会重新计算。</li><li>动画文件后台渲染时表达式会失效。<br>解决办法：（1）烘焙动画曲线：选择绑定组大组执行 Animation &gt; Key &gt; Bake Simulation 等待读条完成后会将控制器的每一帧都K上关键帧，然后再提交渲染即可；（2）在Premel中填入可拖动时间滑块到当前帧的mel表达式，该表达式会在渲染开始前对镜头中的帧进行切换，从开始帧逐渐切换至当前帧，相当于对文件中的控制器进行了一次”脏”运算。达到数据正确的目的。（3）走 abc 流程。</li></ul></li><li><p>maya 创建polygon报错：error line0:connection not made :”****.instObjGroup[0]”-initalShaderGroup.dagSetMembers[-1].destination is locked:可能原因：</p><ul><li>相关节点被锁</li><li>相关属性被锁<br>解决办法：解锁相关节点或相关属性，或者重启 Maya 可解决问题。</li></ul></li><li><p>后台渲染丢材质报错：[mtoa][translator polymesh] ShadingGroup ******:*****SG has no faceShader input …。可能原因：材质没有连接上对应模型或制作过程中切换过不同的渲染器，导致材质与物体mesh的链接断开；<br>解决办法：修改材质文件中的材质链接或重新连接材质，注意查看材质文件的材质、渲染器输出信息；或先赋予Lambert材质,再重新赋予原来的材质。</p></li><li><p>后台渲染和前台渲染的exr图片颜色空间不一致，或颜色不一致。可能原因：</p><ol><li>首选项中勾选了的 Preferences &gt; Output color preferences &gt; Apply Output Transform to Render ，并将Output Transform 设置为 Use View Transform ,该选项会应用 Preferences &gt; Color Transform Preferences 中的 View Transform 值到输出图片，该选项的作用是将渲染预览的结果转换并应用到输出图片（包括色彩空间），如果渲染预览的图片为sRGB编码的色彩空间图，则输出图片也会转换为sRGB色彩空间的图（如下图左1）。</li><li>渲染器驱动节点的”defaultArnoldDriver.colorManagement”渲染设置为了 Use View Transform ，其默认值为 Use Output Transform，原因和 1 一致（正确设置如下图右1所示）。<br>选中驱动节点代码：<pre class="line-numbers language-doc" data-language="doc"><code class="language-doc">mc.select(&quot;defaultArnoldDriver.colorManagement&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><tr><td><img src="/images/Maya软件渲染问题集锦/渲染空间不一致首选项设置 .png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/渲染空间不一致首选项设置 .png" class="lozad post-image"></td><td><img src="/images/Maya软件渲染问题集锦/渲染空间不一致节点选项设置.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/Maya软件渲染问题集锦/渲染空间不一致节点选项设置.png" class="lozad post-image"></td></tr></table></li></ol></li><li><p>同一个场景代理文件，渲染颜色不一致、闪烁，可能原因：代理文件导入maya后，其材质网络被修改过，使两个aistand_in使用相同的代理颜色却不一样，从而产生错误（原因未知）。解决办法：1.改会原来的材质。2.修改使用两个不同的代理文件。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="锦囊小妙招" scheme="http://mirrorcg.github.io/tags/%E9%94%A6%E5%9B%8A%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Maya软件小知识点</title>
    <link href="http://mirrorcg.github.io/posts/20220503a4.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a4.html</id>
    <published>2022-05-03T07:54:38.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>贴图色彩空间被锁定的情况，解锁所有节点贴图的贴图色彩空间选项：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmdsfor i in cmds.ls(type&#x3D;&#39;file&#39;):    cmds.connectAttr(&quot;:defaultColorMgtGlobals.cme&quot;,i+&quot;.cme&quot;,f&#x3D;1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>脚本切换渲染器:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">cmds.setAttr(&quot;defaultRenderGlobals.currentRenderer&quot;, &quot;arnold&quot;, type&#x3D;&quot;string&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取当前视图快照拍屏：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">ws &#x3D; cmds.workspace(q &#x3D; True, fullName &#x3D; True)wsp &#x3D; ws + &quot;&#x2F;&quot; + &quot;images&quot;imageSnapshot &#x3D; wsp + &quot;&#x2F;&quot; + &quot;endSnapshot.jpg&quot;cmds.refresh(cv&#x3D;True, fe &#x3D; &quot;jpg&quot;, fn &#x3D; imageSnapshot)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>脚本设置渲染设置的输出序列图选项：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">mc.setAttr(&quot;defaultRenderGlobals.animation&quot;, True)  # 开启动画帧序列mc.setAttr(&quot;defaultRenderGlobals.animationRange&quot;,1)  # 开启动画帧的范围mc.setAttr(&quot;defaultRenderGlobals.outFormatControl&quot;, 1)  # 设置帧格式mc.setAttr(&quot;defaultRenderGlobals.putFrameBeforeExt&quot;, 1) # 设置图片格式在数字后面（name.#.ext）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建多相机渲染：</p><ul><li>选择相机&gt;AtteibutsEdit&gt;OutputSettings&gt;Renderable(勾选)</li><li>RenderSetting&gt;RednderableCamera&gt;Add RenderableCamera</li></ul></li><li><p>Arnold开关运动模糊要同时设置运动模糊可见性:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">mc.setAttr(&quot;defaultRenderGlobals.motionBlur&quot;, 0) #关闭运动模糊（针对于Arnold）mc.setAttr(&quot;defaultArnoldRenderOptions.motion_blur_enable&quot;, 0) #关闭运动模糊可见性mc.setAttr(&quot;defaultRenderGlobals.motionBlur&quot;, 1) #开启运动模糊mc.setAttr(&quot;defaultArnoldRenderOptions.motion_blur_enable&quot;, 1) #开启运动模糊可见性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>脚本打印部分渲染节点属性名称和值的方式:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as cmds render_glob &#x3D; &quot;defaultRenderGlobals&quot;list_Attr &#x3D; cmds.listAttr(render_glob, r&#x3D;True, s&#x3D;True)for attr in list_Attr:    get_attr_name &#x3D; &quot;%s.%s&quot;%(render_glob, attr)    print &quot;setAttr %s %s&quot;%(get_attr_name, cmds.getAttr(get_attr_name))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>mtoa 创建和访问AOV:</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import mtoa.aovs as aovs# 添加aovaovs.AOVInterface().addAOV(&#39;aov名称&#39;, aovType&#x3D;&#39;float&#39;)# 列出活动状态的aovsaovs.AOVInterface().getAOVs()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Arnold代码加载arnold渲染器并创建默认节点：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcimport mtoa.coremc.setAttr(&quot;defaultRenderGlobals.currentRenderer&quot;,&quot;arnold&quot;,typ&#x3D;&quot;string&quot;)mtoa.core.createOptions()  # 创建ar默认节点网络<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看 mel 函数帮助：<br>使用 “whatIs ‘mel命令’;” 可以查看mel函数帮助。</p></li><li><p>设置maya视图窗口为非显卡（不使用显卡）支持的窗口模式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcdef switch_preview():    all_model_panel &#x3D; mc.getPanel(typ&#x3D;&quot;modelPanel&quot;)    for each in all_model_panel:        mc.modelEditor(each,e&#x3D;True,rnm&#x3D;&quot;base_OpenGL_Renderer&quot;)  # 查询可用的渲染器名称 mc.modelEditor(each,q&#x3D;True,rendererList&#x3D;True) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Xgen相关:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import xgenm.xmaya.xgmExternalAPI as xgenmExternalAPIimport xgenm as xgpalettes &#x3D; xg.palettes()  # 获取Xgen 所有描述if not (xgenmExternalAPI.xgg.DescriptionEditor is None):    xgenmExternalAPI.xgg.DescriptionEditor.refresh(&quot;Full&quot;)  # 刷新所有Xgen面板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="锦囊小妙招" scheme="http://mirrorcg.github.io/tags/%E9%94%A6%E5%9B%8A%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Maya软件小问题集锦</title>
    <link href="http://mirrorcg.github.io/posts/20220503a3.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a3.html</id>
    <published>2022-05-03T07:02:20.000Z</published>
    <updated>2022-05-03T09:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了一些Maya中出现的一些小问题：<span id="more"></span></p><ol><li><p>AOV无法正常创建</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import maya.cmds as mcmc.lockNode(&#39;initialParticleSE&#39;,l&#x3D;0,lu&#x3D;0)mc.lockNode(&#39;initialShadingGroup&#39;,l&#x3D;0,lu&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Maya 操作总是提示 “&#x2F;&#x2F; Error: line 1: Cannot find procedure “onModelChange3dc”. &#x2F;&#x2F;“，这可能是模型制作的时候打开了某个窗口，maya在关闭的时候会保存一份配置在maya文件里，可以从Expression Editor的By Script Node Name里看到，虽然没什么影响，但是真的很烦。解决办法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymel.core as pm# 获取Maya中的所有模型编辑器并重置 editorChanged 事件for item in pm.lsUI(editors&#x3D;True):   if isinstance(item, pm.ui.ModelEditor):       pm.modelEditor(item, edit&#x3D;True, editorChanged&#x3D;&quot;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>RenderSetting渲染面板内容空白，执行mel脚本:</p><pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">deleteUI unifiedRenderGlobalsWindow;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>关闭“cannot find procedrure ‘look’”：</p><ul><li><p>执行mel脚本:</p><ul><li>方法一：<pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>方法二：<pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">global proc look()&#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>执行python脚本:</p> <pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">maya.mel.eval(&#39;outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;&#39;) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>删除TurtleDefaultBakeLayer层：</p><ul><li><p>执行mel脚本</p> <pre class="line-numbers language-mel" data-language="mel"><code class="language-mel">&#x2F;&#x2F;删除海龟渲染 mel脚本lockNode -l off TurtleDefaultBakeLayer;delete TurtleDefaultBakeLayer;lockNode -l off TurtleRenderOptions;delete TurtleRenderOptions;lockNode -l off TurtleBakeLayerManager;delete TurtleBakeLayerManager;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行python脚本</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">def delTurtleRender():    if mc.objExists(&#39;TurtleRenderOptions&#39;):        mc.lockNode(&#39;TurtleRenderOptions&#39;, &#39;TurtleUIOptions&#39;, &#39;TurtleBakeLayerManager&#39;, &#39;TurtleDefaultBakeLayer&#39;, lock&#x3D;0)        mc.delete(&#39;TurtleRenderOptions&#39;, &#39;TurtleUIOptions&#39;, &#39;TurtleBakeLayerManager&#39;, &#39;TurtleDefaultBakeLayer&#39;)        print u&quot;海龟渲染节点清理完成&quot;    else:        print u&quot;场景中海龟渲染节点已清理干净&quot;delTurtleRender()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Maya Arnold不能渲染:<br> &#x2F;&#x2F; Rendering with Arnold Renderer… &#x2F;&#x2F;<br> &#x2F;&#x2F; Result: Rendering Completed. See mayaRenderLog.txt for information. &#x2F;&#x2F;<br> 是因为Maya 的mtoa环境变量丢失，导致渲染器使用的部分文件没有调用到，因此直接结束渲染。<br> 解决办法：<br> <a href="https://support.solidangle.com/display/AFMUG/Batch+Rendering">https://support.solidangle.com/display/AFMUG/Batch+Rendering</a> 的Batch Render Flags   提到了解决问题的办法，就是在环境变量中增加如下环境变量（对应maya版本号）：<br> MAYA_RENDER_DESC_PATH&#x3D;C:\solidangle\mtoadeploy\对应maya版本号<br> 然后，重新打开maya渲染。或者，重新安装渲染器，此办法有概率解决问题。</p></li><li><p>高版本Maya(2020以上)不能加载Arnold渲染器的问题：需要打补丁程序VC_redist.x64.exe。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录了一些Maya中出现的一些小问题：</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="杂项" scheme="http://mirrorcg.github.io/categories/Maya/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="锦囊小妙招" scheme="http://mirrorcg.github.io/tags/%E9%94%A6%E5%9B%8A%E5%B0%8F%E5%A6%99%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Maya文件打开慢或者崩溃的检查办法</title>
    <link href="http://mirrorcg.github.io/posts/20220503a2.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a2.html</id>
    <published>2022-05-03T06:07:21.000Z</published>
    <updated>2022-05-03T07:07:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目制作过程中常常会遇到制作文件打不开或者打开慢的情况，对于此类问题：<span id="more"></span></p><ol><li><p>如果是’.mb’文件，会比较麻烦些，需要在打开文件时不加载引用文件，然后一个一个加载引用文件，根据引用文件的加载情况进行判断是否有引用文件有问题。一般会出现：单个引用文件加载崩溃、单个引用文件加载慢、所有引用文件加载都没问题，但是保存后还是打开有问题，这时就需要分别尝试打开带有加载不同引用文件的maya文件。（之前碰到过引用文件中有的节点有冲突：相同的引用文件单独加载都没问题，但保存后加载会崩溃，然后逐步定位加载有问题的文件一步一步排除，最后将有冲突的节点重建才解决问题。）</p></li><li><p>如果是’.ma’文件：</p><ul><li>使用上面的’.mb’文件的办法。</li><li>在文件中插入 mel 脚本，在打开脚本的同时，执行mel脚本，通过脚本的日志内容情况来判断是什么文件导致的‘.ma’文件打不开，或者打开慢的情况。</li></ul></li></ol><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import codecsdef checkMayaAsciiFile(source_file, target_file, log_file):    &quot;&quot;&quot;    1. 用于检查 Maya Ascii 文件打开崩溃    2. - - - - - - - - - - - - - -耗时    Args:        source_file: ma 文件        target_file: 修改后的文件        log_file: logging    Returns: none    &quot;&quot;&quot;    # # 记录打不开的ma文件是从哪一行崩溃的    # __startMel &#x3D; &#39;&#39;&#39;python(&quot;logFile&#x3D;&#39;%s&#39;;ff &#x3D; open(logFile,&#39;w&#39;);ff.write(&#39; &#39;);ff.close();&quot;);&#39;&#39;&#39; % log_file    # __proc &#x3D; &#39;&#39;&#39;python(&quot;ff &#x3D; open(logFile,&#39;a&#39;);ff.write(&#39;%s - &#123;0&#125;\\\\n&#39;.format(comp_time));ff.close();&quot;);\n&#39;&#39;&#39;    # __endMel &#x3D; &quot;&quot;    # 记录打开文件时的耗时信息    __startMel &#x3D; &#39;&#39;&#39;python(&quot;from datetime import datetime;import time;line_time&#x3D;datetime.now();time.sleep(0.002);threshold_time&#x3D;datetime.now() - line_time;start_time&#x3D;line_time;logging&#x3D;list();logFile&#x3D;&#39;%s&#39;&quot;);&#39;&#39;&#39; % log_file    __proc &#x3D; &#39;&#39;&#39;python(&quot;comp_time &#x3D; datetime.now() - line_time;logging.append(&#39;%s - &#39;+ str(comp_time)) if comp_time &gt; threshold_time else None;line_time &#x3D; datetime.now();&quot;);\n&#39;&#39;&#39;    __endMel &#x3D; &#39;&#39;&#39;python(&quot;logging.append(&#39;\\\\n\\\\nStart Time - &#39;+ str(start_time) + &#39;\\\\nEnd Time - &#39;+ str(line_time) + &#39;\\\\nTotal Time - &#39; + str(line_time - start_time));ff &#x3D; open(logFile,&#39;w&#39;);[ff.write(line+&#39;\\\\n&#39;) for line in logging];ff.close();&quot;);&#39;&#39;&#39;    with codecs.open(source_file, &quot;r&quot;, &quot;gbk&quot;) as f:        aLines &#x3D; f.readlines()    fileter &#x3D; (&quot;select&quot;, &quot;connectAttr&quot;, &quot;dataStructure&quot;, &quot;createNode&quot;, &quot;requires&quot;, &quot;currentUnit&quot;)    # other relationship fileInfo    rule &#x3D; 1    for num, line in enumerate(aLines):        line_add &#x3D; &quot;&quot;.join([aLines[num - 1][:-1], __proc % str(num)])        if rule:  # 文件开头的 file 每一行都加 mel            if __startMel:  # 文件开头结尾初始化命令                aLines[num] &#x3D; __startMel + line                if __endMel:                    aLines[num - 1] &#x3D; __endMel + aLines[num - 1]                __startMel &#x3D; 0                continue            if &quot;file&quot; in line:  # 可能有的设置里会有file字符串,所以这里要独立规则                if &quot;;\n&quot; not in aLines[num - 1]:                    continue                aLines[num - 1] &#x3D; line_add            if &quot;requires&quot; in line:  # requires 之后改变规则                rule &#x3D; 0        # 在 fileter 参数里的,对它的前一行添加 mel        # setAttr 用的是 .attr 的方式,在它之后加 mel 会影响下一个 setAttr 所以这里添加这个过滤        for _ in fileter:            if _ in line:                if &quot;;\n&quot; in aLines[num - 1]:                    aLines[num - 1] &#x3D; line_add    with codecs.open(target_file, &quot;w&quot;, &quot;gbk&quot;) as ff:        for lines in aLines:            ff.write(lines)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    srcFile &#x3D; r&quot;E:\test\shot00401.ma&quot;    srcFile &#x3D; srcFile.replace(&quot;\\&quot;, &quot;&#x2F;&quot;)    sourceFile &#x3D; srcFile    targetFile &#x3D; srcFile[:-3] + &quot;_v01.ma&quot;    logFile &#x3D; srcFile[:-3] + &quot;_v01.txt&quot;    # print(sourceFile, targetFile, logFile)    checkMayaAsciiFile(sourceFile, targetFile, logFile)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，需要将”E:\test\shot00401.ma”替换成你的‘.ma’文件路径，执行完成后，会在同级文件目录下生成一个版本号为‘-v01’的‘.ma’文件，使用Maya打开该文件，打开文件的同时会执行文件中的mel脚本保存日志信息，文件读取完成后，也会在统计目录下生成一个版本号为‘-v01’的txt日志文件，打开文件分析即可。</p><h4 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h4><p>部分内容转载自：<a href="https://ruben.blog.csdn.net/article/details/90082639">https://ruben.blog.csdn.net/article/details/90082639</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目制作过程中常常会遇到制作文件打不开或者打开慢的情况，对于此类问题：</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="小工具" scheme="http://mirrorcg.github.io/categories/Maya/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="检查" scheme="http://mirrorcg.github.io/tags/%E6%A3%80%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>在物体的点上创建跟踪对象</title>
    <link href="http://mirrorcg.github.io/posts/20220503a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220503a1.html</id>
    <published>2022-05-03T05:28:40.000Z</published>
    <updated>2022-05-03T06:28:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">之前做测量相机焦距工具的时候发现不能把焦距添加约束到物体上的点，尤其是做了abc缓存之后，由于并没有对点进行编辑，不管是在自身空间还是世界空间中，点的位置在数值上都没有变换，被约束的相机的焦点依旧保持在原地，因此对点添加普通的的约束并不能达到效果，我们需要换一种方式进行约束。<span id="more"></span></p><p style="text-indent:2em">可以使用给点创建毛囊的办法，利用uv映射的点的位置始终保持不变，但是物体的世界矩阵在变化的原理，将点世界坐标的信息传递给毛囊，毛囊会一直跟着点的，此时我们只需要约束毛囊就能达到我们想要的效果了。</p><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-# !&#x2F;usr&#x2F;bin&#x2F;env python27# @Author: Mirror# @Time: 2022-03-15# description: 该脚本用于在选中点的位置上创建定位毛囊，该毛囊通过UV点定位，所有使用后不能调整点所在的UV# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;import maya.cmds as mcdef buildFollicle(points):    if not points:        return    if type(points).__name__ &#x3D;&#x3D; &quot;str&quot;:        points &#x3D; [points]    for point in points:        poly_transform &#x3D; mc.listRelatives(mc.listRelatives(point, p&#x3D;True, s&#x3D;True)[0], p&#x3D;True, s&#x3D;True)[0]        point_uvVertex &#x3D; mc.polyListComponentConversion(point, fv&#x3D;True, tuv&#x3D;True)        point_uvposition &#x3D; mc.polyEditUV(point_uvVertex[0], q&#x3D;1)        follicle &#x3D; mc.createNode(&quot;follicle&quot;, n&#x3D;&quot;follicle_%s&quot; % point.replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;, &quot;&quot;).replace(&quot;.&quot;, &quot;_&quot;))        follicle_transform &#x3D; mc.listRelatives(follicle, p&#x3D;True)[0]        mc.connectAttr(poly_transform + &quot;.worldMatrix[0]&quot;, follicle + &quot;.inputWorldMatrix&quot;)        mc.connectAttr(poly_transform + &quot;.outMesh&quot;, follicle + &quot;.inputMesh&quot;)        mc.connectAttr(follicle + &quot;.outTranslate&quot;, follicle_transform + &quot;.translate&quot;)        mc.connectAttr(follicle + &quot;.outRotate&quot;, follicle_transform + &quot;.rotate&quot;)        mc.setAttr(follicle_transform + &quot;.parameterU&quot;, point_uvposition[0])        mc.setAttr(follicle_transform + &quot;.parameterV&quot;, point_uvposition[1])if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    vertexs &#x3D; mc.ls(sl&#x3D;True,fl&#x3D;True)    buildFollicle(vertexs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：在添加了定位的毛囊之后，不能修改UV，否则毛囊会回到原点，约束失效，需要重新创建毛囊和约束。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>官网中相关的介绍：<a href="https://help.autodesk.com/view/MAYAUL/2018/CHS/?guid=GUID-A0D2DD53-FE41-4244-8635-CD4651ABF97F">https://help.autodesk.com/view/MAYAUL/2018/CHS/?guid=GUID-A0D2DD53-FE41-4244-8635-CD4651ABF97F</a></p>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-indent:2em&quot;&gt;之前做测量相机焦距工具的时候发现不能把焦距添加约束到物体上的点，尤其是做了abc缓存之后，由于并没有对点进行编辑，不管是在自身空间还是世界空间中，点的位置在数值上都没有变换，被约束的相机的焦点依旧保持在原地，因此对点添加普通的的约束并不能达到效果，我们需要换一种方式进行约束。</summary>
    
    
    
    <category term="Maya" scheme="http://mirrorcg.github.io/categories/Maya/"/>
    
    <category term="小工具" scheme="http://mirrorcg.github.io/categories/Maya/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="灯光" scheme="http://mirrorcg.github.io/tags/%E7%81%AF%E5%85%89/"/>
    
    <category term="UV" scheme="http://mirrorcg.github.io/tags/UV/"/>
    
  </entry>
  
  <entry>
    <title>一些好用的网站</title>
    <link href="http://mirrorcg.github.io/posts/20220501a2.html"/>
    <id>http://mirrorcg.github.io/posts/20220501a2.html</id>
    <published>2022-05-01T11:57:59.000Z</published>
    <updated>2022-07-08T11:57:59.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">本文推荐一些多快好省的网站、技术大佬的博客网站、专业网站。<span id="more"></span></p><ol><li><p>图标下载</p><ul><li>Icon图标下载：<a href="https://icon-icons.com/zh/">https://icon-icons.com/zh/</a></li><li>阿里巴巴矢量图库：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></li><li>图片格式转换： <a href="https://www.butterpig.top/ico/">https://www.butterpig.top/ico/</a></li></ul></li><li><p>影视行业软件下载网站：</p><ul><li>画忆大佬的软件下载网站(无毒无公害)：<a href="http://www.iiicg.com/">www.iiicg.com</a></li></ul></li><li><p>技术大佬们的博客网页</p><ul><li>TD手册：<a href="https://cg-td-course.readthedocs.io/zh_CN/latest/index.html">https://cg-td-course.readthedocs.io/zh_CN/latest/index.html</a></li><li>凌云大佬技术博客分享：<a href="https://lingyunfx.com/">https://lingyunfx.com/</a></li><li>汝小右大佬博客：<a href="https://ruben.blog.csdn.net/?type=blog">https://ruben.blog.csdn.net/?type=blog</a></li></ul></li><li><p>行业官网</p><ul><li>Maya2022 用户文档：<a href="https://help.autodesk.com/view/MAYAUL/2022/CHS/">https://help.autodesk.com/view/MAYAUL/2022/CHS/</a></li><li>Yeti 用户文档：<a href="https://support.peregrinelabs.com/support/solutions/66000172201">https://support.peregrinelabs.com/support/solutions/66000172201</a></li><li>Arnold 用户文档：<a href="https://www.arnoldrenderer.com/news/">https://www.arnoldrenderer.com/news/</a></li><li>Nuke 用户文档：<a href="https://learn.foundry.com/nuke/13.1/content/learn_nuke.html">https://learn.foundry.com/nuke/13.1/content/learn_nuke.html</a></li><li>Katana 用户文档：<a href="https://learn.foundry.com/katana/5.0/Content/learn_katana.html">https://learn.foundry.com/katana/5.0/Content/learn_katana.html</a></li><li>Deadline 用户文档：<a href="https://docs.thinkboxsoftware.com/">https://docs.thinkboxsoftware.com/</a></li><li>Pyside2 用户文档：<a href="https://wiki.qt.io/Main">https://wiki.qt.io/Main</a></li><li>ShotGrid 用户文档：<a href="https://help.autodesk.com/view/SGSUB/CHS/">https://help.autodesk.com/view/SGSUB/CHS/</a></li><li>AutoIt3 用户文档：<a href="https://www.autoitscript.com/autoit3/docs/">https://www.autoitscript.com/autoit3/docs/</a></li><li>USD 用户文档：<a href="https://graphics.pixar.com/usd/release/index.html">https://graphics.pixar.com/usd/release/index.html</a></li><li>UE4 官网：<a href="https://www.unrealengine.com/zh-CN">https://www.unrealengine.com/zh-CN</a></li><li>ACES 用户手册：<a href="https://acescentral.com/knowledge-base-2/">https://acescentral.com/knowledge-base-2/</a></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-indent:2em&quot;&gt;本文推荐一些多快好省的网站、技术大佬的博客网站、专业网站。</summary>
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    
    <category term="网站推荐" scheme="http://mirrorcg.github.io/tags/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>QT中的系统托盘图标和系统消息推送</title>
    <link href="http://mirrorcg.github.io/posts/20220501a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220501a1.html</id>
    <published>2022-05-01T09:40:20.000Z</published>
    <updated>2022-05-01T11:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-indent:2em">本文记录: 使用 PySide2 编写工具界面时，需要为工具创建系统托盘图标以及推送消息的方法。<span id="more"></span>以方便用户对工具进行操作。</p><p style="text-indent:2em">通过 PySide2 创建系统托盘，需要使用 PySide2.QtWidgets.QSystemTrayIcon 这个类。这个类中需要使用了以下常用方法，就可以创建最基本的系统托盘图标：</p><ul><li>QSystemTrayIcon   创建一个系统托盘对象</li><li>QSystemTrayIcon.setContextMenu    添加右键菜单(QMenu)</li><li>QSystemTrayIcon.showMessage   在右下角弹出要提示消息</li><li>QObject.connect 连接信号和槽</li></ul><p>使用上面的方法，可以完成：</p><ol><li>在系统托盘中创建一个程序图标。</li></ol><p><img src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87.png" alt="创建的系统托盘图标.png" srcset="/images/home/Myhead.jpg" data-src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87.png" class="lozad post-image">  </p><ol start="2"><li>在程序创建完成托盘图标后，推送一条提示程序已经启动的系统消息。</li></ol><p><img src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E6%8E%A8%E9%80%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF.png" alt="推送的系统消息.png" srcset="/images/home/Myhead.jpg" data-src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E6%8E%A8%E9%80%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF.png" class="lozad post-image">  </p><ol start="3"><li>鼠标点击图标时的左右键功能。</li></ol><p><img src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E5%B7%A6%E5%8F%B3%E9%94%AE%E5%8A%9F%E8%83%BD.png" alt="点击图标左右键功能.png" srcset="/images/home/Myhead.jpg" data-src="/images/QT%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/%E7%82%B9%E5%87%BB%E5%9B%BE%E6%A0%87%E5%B7%A6%E5%8F%B3%E9%94%AE%E5%8A%9F%E8%83%BD.png" class="lozad post-image">  </p><p>代码示例如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import sysfrom PySide2.QtWidgets import QApplication, QAction, QMenu, QSystemTrayIconfrom PySide2.QtCore import SIGNAL, QObjectfrom PySide2.QtGui import QIcondef close():    print(&quot;close&quot;)def restart():    print(&quot;restart&quot;)def show():    print(&quot;show&quot;)app &#x3D; QApplication(sys.argv)exit &#x3D; QAction(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu.ico&quot;), &quot;Exit&quot;, )QObject.connect(exit, SIGNAL(&quot;triggered()&quot;), close)res &#x3D; QAction(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu1.ico&quot;), &quot;Restart&quot;, )QObject.connect(res, SIGNAL(&quot;triggered()&quot;), restart)menu &#x3D; QMenu()  # 创建菜单，添加菜单选项menu.addAction(exit)menu.addAction(res)trayIcon &#x3D; QSystemTrayIcon(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu4.ico&quot;))  # 创建系统托盘trayIcon.setContextMenu(menu)QObject.connect(trayIcon, SIGNAL(&quot;activated(QSystemTrayIcon::ActivationReason)&quot;), show)trayIcon.show()trayIcon.setToolTip(&quot;启动器&quot;)trayIcon.showMessage(&quot;启动器已经启动!&quot;, &quot;左击显示窗口\n右击显示菜单&quot;, QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu_Note1.ico&quot;))sys.exit(app.exec_())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行代码后，会在电脑桌面系统托盘创建一个本程序的图标，同时会推送一条启动信息，该信息会自动收回。<br>上面的代码没有判断点的是左还是右键，所以只要鼠标点击图标都会先打印一遍 “show”,请自行判断。</p>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-indent:2em&quot;&gt;本文记录: 使用 PySide2 编写工具界面时，需要为工具创建系统托盘图标以及推送消息的方法。</summary>
    
    
    
    <category term="Qt" scheme="http://mirrorcg.github.io/categories/Qt/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Qt/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="QT事件" scheme="http://mirrorcg.github.io/tags/QT%E4%BA%8B%E4%BB%B6/"/>
    
    <category term="信号&amp;槽" scheme="http://mirrorcg.github.io/tags/%E4%BF%A1%E5%8F%B7-%E6%A7%BD/"/>
    
    <category term="系统托盘图标和消息" scheme="http://mirrorcg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87%E5%92%8C%E6%B6%88%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>USD框架的搭建</title>
    <link href="http://mirrorcg.github.io/posts/20220421a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220421a1.html</id>
    <published>2022-04-20T16:02:26.000Z</published>
    <updated>2022-04-20T16:02:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天来介绍一下 windows 环境下 USD 的独立安装过程。<span id="more"></span><br>首先，我们需要了解几个网站：</p><p style="text-indent:2em">USD 的帮助文档 ：https://graphics.pixar.com/usd/release/index.html</p><p style="text-indent:2em">USD 的Github仓库 ：https://github.com/PixarAnimationStudios/USD</p><h4 id="安装准备："><a href="#安装准备：" class="headerlink" title="安装准备："></a>安装准备：</h4><p>需要准备：Python2、Cmake、NASM、Microsoft Visual Studio2017、Microsoft Visual Studio Code</p><p style="text-indent:2em">1. 确认环境中有Python2。在 windows 上安装 USD 需要我们的环境中有 Python， 由于 USD 目前还不支持Python3 ，因此我使用的是 Python2.7.16 ,没有Python2 的小伙伴可以从<a href="https://www.python.org/downloads/release/python-2710/" title="" target="">官网下载</a>，下载安装好后，需要调整一下环境变量的顺序，将Python2的相关环境变量提升到Python3的前面，这样可以在后面安装的时候直接调用Python2的环境,就不会出现一些奇怪的问题导致安装失败，如下图。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E5%89%8D%E7%BD%AEpython2%E7%9A%84%E7%8E%AF%E5%A2%83.png" alt="前置python2的环境" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E5%89%8D%E7%BD%AEpython2%E7%9A%84%E7%8E%AF%E5%A2%83.png" class="lozad post-image"></p><p style="text-indent:2em">2. 安装CMAKE工具，如果电脑上没有CMAKE，可以<a href="https://cmake.org/download/" title="" target="">从这里下载</a>，往下翻，找到相应的平台和系统版本，下载到一个可安装的文件，使用默认安装就好。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDCMAKE.png" alt="下载CMAKE" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDCMAKE.png" class="lozad post-image"></p><p style="text-indent:2em">3. 安装NASM，如果电脑上也没有NASM，则可以<a href="https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=D" title="" target="">从这里下载</a>，打开链接后选择一个合适的版本，我使用的是2.15.05版本的NASM，双击文件夹，选择自己系统对应的文件夹，再次双击，可以看到一个安装程序，点击即可下载，没有特殊需求的话，尽量使用默认安装。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDNASM.png" alt="下载NASM" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E4%B8%8B%E8%BD%BDNASM.png" class="lozad post-image"></p><p style="text-indent:2em">4. 安装Microsoft Visual Studio，USD 暂时不支持较新的版本，本案例使用的是VS2017版本，可以<a href="https://my.visualstudio.com/Downloads?q=visual%20studio%202017&wt.mc_id=o~msft~vscom~older-downloads" title="" target="">从这里下载</a>，选择一个合适的版本，安装过程中选择使用C++的桌面开发。</p><p style="text-indent:2em">5. 安装Microsoft Visual Studio Code，如果没有VSCode，可以<a href="https://code.visualstudio.com/download" title="" target="">从这里下载</a>，选择一个合适的版本，下载后默认安装好，打开下载Python拓展插件，并将上面安装的Python2的执行程序路径填入对应位置，如下图所示。</p><table><tr><td><img src="/images/USD框架的搭建/下载VSCode.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/USD框架的搭建/下载VSCode.png" class="lozad post-image"></td><td><img src="/images/USD框架的搭建/安装Python插件.png" border=0 srcset="/images/home/Myhead.jpg" data-src="/images/USD框架的搭建/安装Python插件.png" class="lozad post-image"></td></tr></table>接下来我们还需要为Python2安装一些功能模块：PySide、pyd、pyopengl、Jinja2，在cmd中依次执行下面的指令即可<p style="text-indent:2em">pip install PySide</p><p style="text-indent:2em">pip install pyd</p><p style="text-indent:2em">pip install pyopengl</p><p style="text-indent:2em">pip install Jinja2</p>注：这里如果出现“pip Fatal error in launcher: Unable to create process...”错误，可以通过python安装文件的修复功能来解决，点击repair。<h4 id="构建-USD"><a href="#构建-USD" class="headerlink" title="构建 USD"></a>构建 USD</h4><p style="text-indent:2em">先从USD 的Github仓库<a href="https://github.com/PixarAnimationStudios/USD" title="" target="">下载 USD 源码</a>到本地，打开“x86 Native Tools Command Prompt VS 2017”界面，这里不能使用x64,并且对于高版本的VS,不管是"X64" 还是 "x86" 均不能安装成功。输入 python "你的USD源码下载位置"\build_scripts\build_usd.py "C:\USD" ，其中"C:\USD"是你的安装位置（安装位置中似乎不能有空格，我尝试了几次将usd安装在带空格的"Program Files (x86)"中，都没有成功）。程序会自动为你安装zlib，boost，TBB，OpenSubdiv用来构建USD环境。这个过程只有简单的几条语句提示，没有进度条，并且可能会报错或者安装不成功（也许是下载速度的原因），多执行几次上面的构建指令就好了，我也是安装了三次才成功。成功后会提示你，需要将 "C:\USD\lib\python"添加进系统变量PYTHONPATH中，再在系统变量 PATH 中添加 "C:\USD\bin" 和 "C:\USD\lib"两个路径，如下图所示。<p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E6%9E%84%E5%BB%BA%E7%95%8C%E9%9D%A2.png" alt="构建界面" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/%E6%9E%84%E5%BB%BA%E7%95%8C%E9%9D%A2.png" class="lozad post-image"></p><p>至此USD环境就搭建好了。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>打开一个cmd窗口，cd 进入你的USD源代码目录,然后输入指令：“usdview .\extras\usd\tutorials\convertingLayerFormats\Sphere.usd”，出现下面的界面就表示成功了。</p><p><img src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/USD%E7%95%8C%E9%9D%A2.png" alt="USD界面" srcset="/images/home/Myhead.jpg" data-src="/images/USD%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/USD%E7%95%8C%E9%9D%A2.png" class="lozad post-image"></p><p>接下来就可以愉快地<a href="https://graphics.pixar.com/usd/release/tut_usd_tutorials.html#" title="" target="">学习案例</a>了！！！</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol><li><a href="https://zhuanlan.zhihu.com/p/437422802">https://zhuanlan.zhihu.com/p/437422802</a></li><li><a href="https://github.com/PixarAnimationStudios/USD/blob/release/README.md#getting-and-building-the-code">https://github.com/PixarAnimationStudios/USD/blob/release/README.md#getting-and-building-the-code</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天来介绍一下 windows 环境下 USD 的独立安装过程。</summary>
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Doc/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="USD" scheme="http://mirrorcg.github.io/tags/USD/"/>
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>QT中的异形窗口</title>
    <link href="http://mirrorcg.github.io/posts/20220326a2.html"/>
    <id>http://mirrorcg.github.io/posts/20220326a2.html</id>
    <published>2022-03-26T07:07:25.000Z</published>
    <updated>2022-03-26T07:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录一下 QT 中异形窗口的创建。<span id="more"></span></p><h4 id="主要标志"><a href="#主要标志" class="headerlink" title="主要标志"></a>主要标志</h4><p>在 QWidget 中，通过给窗口设置特定的标志，可以将窗口设置为不同的形状，比如让窗口无标题，或者直接让主窗口透明</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">setWindowFlags(Qt.FramelessWindowHint)      # 去掉标题栏setMask(QPixmap(img).mask())                # 设置图片透明的地方为穿透setAttribute(Qt.WA_TranslucentBackground)   # 设置窗口透明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当为窗口设置了使用图片作为 Mask 遮罩后，Qt.FramelessWindowHint 标志会自动指定。</p><h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><h5 id="创建一个基本窗口"><a href="#创建一个基本窗口" class="headerlink" title="创建一个基本窗口"></a>创建一个基本窗口</h5><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># Author: Mirrorimport sysfrom PySide2.QtWidgets import QApplication, QWidgetfrom PySide2.QtCore import Qtfrom PySide2.QtGui import QPixmapclass MainWindow(QWidget):    def __init__(self,):        super().__init__()if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app &#x3D; QApplication(sys.argv)    form &#x3D; MainWindow()  # 实例化窗口小部件    form.show()    sys.exit(app.exec_())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>窗口效果<br><img src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E5%8E%9F%E7%AA%97%E5%8F%A3.png" alt="原窗口.png" srcset="/images/home/Myhead.jpg" data-src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E5%8E%9F%E7%AA%97%E5%8F%A3.png" class="lozad post-image"></p><h5 id="设置窗口标志"><a href="#设置窗口标志" class="headerlink" title="设置窗口标志"></a>设置窗口标志</h5><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">self.setWindowFlags(Qt.FramelessWindowHint)  # 去掉标题<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>窗口效果<br>窗口会变成一块没有标题的白板<br><img src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E6%97%A0%E6%A0%87%E9%A2%98%E7%AA%97%E5%8F%A3.png" alt="无标题窗口.png" srcset="/images/home/Myhead.jpg" data-src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E6%97%A0%E6%A0%87%E9%A2%98%E7%AA%97%E5%8F%A3.png" class="lozad post-image"></p><h5 id="设置窗口Mask"><a href="#设置窗口Mask" class="headerlink" title="设置窗口Mask"></a>设置窗口Mask</h5><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">self.starticon &#x3D; QPixmap(r&quot;ImagePath&quot;)self.setMask(self.starticon.mask())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>窗口效果窗口会根据你使用的 Mask 图片进行裁剪<br><img src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E8%AE%BE%E7%BD%AEMask%E7%9A%84%E7%AA%97%E5%8F%A3.png" alt="设置Mask的窗口.png" srcset="/images/home/Myhead.jpg" data-src="/images/Qt%E4%B8%AD%E7%9A%84%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/%E8%AE%BE%E7%BD%AEMask%E7%9A%84%E7%AA%97%E5%8F%A3.png" class="lozad post-image"></p><h4 id="窗口重写事件"><a href="#窗口重写事件" class="headerlink" title="窗口重写事件"></a>窗口重写事件</h4><p>由于窗口被设置为无标题窗口后，鼠标不能对窗口进行移动，因此，我们还需要将窗口的鼠标事件进行重写。<br>完整代码：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># !&#x2F;user&#x2F;bin&#x2F;python37# -*- coding: utf-8 -*-# Author:Mirror# Time: 2022&#x2F;03&#x2F;26# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;import sysfrom PySide2.QtWidgets import QApplication,QWidgetfrom PySide2.QtCore import Qtfrom PySide2.QtGui import QPixmap, QCursorclass MainWindow(QWidget):    def __init__(self,):        super().__init__()        self.setWindowFlags(Qt.FramelessWindowHint)  # 去掉标题（还有一些别的窗口类型选择，请自行查阅）        self.starticon &#x3D; QPixmap(r&quot;E:\Python_study\startLauncher\Icon\startBackgroundMask.svg&quot;)        self.setMask(self.starticon.mask())    # 鼠标按下    def mousePressEvent(self, event):        if event.button() &#x3D;&#x3D; Qt.LeftButton:            self.m_drag &#x3D; True  # 鼠标按下或抬起标志位            self.m_DragPosition &#x3D; event.globalPos() - self.pos()  # 当前单击点相对于窗口本身的坐标(只检测窗口中的点击)            self.setCursor(QCursor(Qt.SizeAllCursor))  # 设置光标形状 小手抓取        if event.button() &#x3D;&#x3D; Qt.RightButton:  # 按下右键 取消左键按下，结束鼠标移动时间            if self.m_drag &#x3D;&#x3D; True:                self.m_drag &#x3D; False    # 鼠标移动    def mouseMoveEvent(self, QMouseEvent):        if Qt.LeftButton and self.m_drag:            # 当左键移动窗体修改偏移值            self.move(QMouseEvent.globalPos() - self.m_DragPosition)    # 鼠标抬起    def mouseReleaseEvent(self, QMouseEvent):        self.m_drag &#x3D; False        self.setCursor(QCursor(Qt.ArrowCursor))if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app &#x3D; QApplication(sys.argv)    form &#x3D; MainWindow()    form.show()    sys.exit(app.exec_())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的代码，我们就可以获得一个可以被鼠标移动的异形窗口啦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下 QT 中异形窗口的创建。</summary>
    
    
    
    <category term="Qt" scheme="http://mirrorcg.github.io/categories/Qt/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Qt/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="QT事件" scheme="http://mirrorcg.github.io/tags/QT%E4%BA%8B%E4%BB%B6/"/>
    
    <category term="异形窗口" scheme="http://mirrorcg.github.io/tags/%E5%BC%82%E5%BD%A2%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>QT中QToolButton的双击事件</title>
    <link href="http://mirrorcg.github.io/posts/20220326a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220326a1.html</id>
    <published>2022-03-26T05:25:06.000Z</published>
    <updated>2022-03-26T07:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p style="text-indent:2em">写工具界面的时候，发现 QPushButton 按钮不能被图标完全覆盖，而选择使用 QToolButton 按钮，但是 QToolButton 按钮本身是没有双击事件的，我在写工具的时候又对这个双击事件很执着，就自己实现一下<span id="more"></span>，并为该结果做记录。</p><h4 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h4><p style="text-indent:2em">要实现 QToolButton 按钮的双击事件：需要新建一个继承于 QToolButton 的子类，该类继承 QToolButton 的 click 鼠标单击事件，添加 singleClicked 和 doubleClicked 两个信号用于发送我们想要的单/双击信号，并在子类中添加一个 Qtimer 作为判断依据：将 QTimer 设置为单次触发, 并为QTimer 设定一个较短的时间，在该时间内，click信号链接到事件判断函数，如果再次点击该按钮则判断为双击事件，同时将 QTimer 停止；反之 QTimer 超时，QTimer 发送超时信号到单击事件函数，也需要将Qtimer 停止。当实例化这个子类后，点击按钮，该 click 信号即在实例内部进行判断。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># !&#x2F;user&#x2F;bin&#x2F;python37# -*- coding: utf-8 -*-# Author:Mirror# Time: 2022&#x2F;03&#x2F;26# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;import sysfrom PySide2.QtWidgets import QApplication, QToolButtonfrom PySide2.QtCore import Qt, Signal, QTimerclass DccButton(QToolButton):    &quot;&quot;&quot;定义ToolButton按钮双击事件&quot;&quot;&quot;    doubleClicked &#x3D; Signal()  # 双击信号    singleClicked &#x3D; Signal()  # 单击信号    def __init__(self):        super(DccButton, self).__init__()        self.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)  # 设置图标在字体之上        self.timer &#x3D; QTimer()  # 创建触发器        self.timer.setSingleShot(True) # 仅单次触发        self.timer.setInterval(200) # 触发间隔，用于判断是否为双击        self.timer.timeout.connect(self.singleClick) # 超时信号连接至单击        self.clicked.connect(self.checkDoubleClick) # 连接至成员函数判断是否为双击    def singleClick(self):        &quot;&quot;&quot;            发送单击信号        &quot;&quot;&quot;        self.timer.stop()        self.setDown(False)        self.singleClicked.emit()        print(&quot;单击&quot;)    def checkDoubleClick(self):        &quot;&quot;&quot;            判断是否为双击信号，否则信号超时        &quot;&quot;&quot;        if not self.isDown():            self.setDown(True)        if self.timer.isActive():            self.timer.stop()            self.setDown(False)            self.doubleClicked.emit()            print(&quot;双击&quot;)            return        else:            self.timer.start()if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app &#x3D; QApplication(sys.argv)    form &#x3D; DccButton()    form.show()    sys.exit(app.exec_())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;写工具界面的时候，发现 QPushButton 按钮不能被图标完全覆盖，而选择使用 QToolButton 按钮，但是 QToolButton 按钮本身是没有双击事件的，我在写工具的时候又对这个双击事件很执着，就自己实现一下</summary>
    
    
    
    <category term="Qt" scheme="http://mirrorcg.github.io/categories/Qt/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Qt/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="QT事件" scheme="http://mirrorcg.github.io/tags/QT%E4%BA%8B%E4%BB%B6/"/>
    
    <category term="信号&amp;槽" scheme="http://mirrorcg.github.io/tags/%E4%BF%A1%E5%8F%B7-%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>rez安装使用</title>
    <link href="http://mirrorcg.github.io/posts/20220314a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220314a1.html</id>
    <published>2022-03-14T11:24:28.000Z</published>
    <updated>2022-06-30T14:12:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Rez 是一个跨平台程序包管理器，通过它可以给程序配置独立的环境<span id="more"></span>，每个独立环境中只是引用了这些包。所以它的环境配置是轻量级的，与其它程序包环境管理不同的是，所有的程序包都安装在一个中央统一的位置，尽管有几百个包，通常也只需要几秒就可以进行配置。将 Rez 作为工作室 DCC 软件启动器依赖项，是个不错的选择。下面将简单介绍 Windows 环境下，Rez 包管理器如何安装使用。</p><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><p>从 GitHub 上拉取 <a href="https://github.com/nerdvegas/rez" title="" target="">Rez 原项目的的相关仓库</a>，然后打开CMD<br>进入拉取仓库所在的目录中执行(建议在C盘根目录)：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">python .&#x2F;install.py </code></pre><p>这将会把包安装在当前位置的 &#x2F;opt&#x2F;rez 目录下<br>也可以使用Pip进行安装：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">pip install rez</code></pre><p>但使用 pip 的安装方式并不能很好的用在生产环境中,使用 install 脚本安装是推荐的方法，它可以保证 Rez 拥有独立 python 于的环境独立运行。<br>安装完成后，cmd中会出现提示信息。然后，需要在环境变量 PATH 中添加值 ‘安装rez的路径’&#x2F;opt&#x2F;rez&#x2F;bin&#x2F;rez。</p><h4 id="创建基本的-Rez-包"><a href="#创建基本的-Rez-包" class="headerlink" title="创建基本的 Rez 包"></a>创建基本的 Rez 包</h4><p>这里需要使用管理员权限去安装包，rez-bind 工具创建基于已安装在系统上的软件的 Rez 包：（–quickstart是以标准形式安装包）</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-bind --quickstart</code></pre><p>你也可以分开安装</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-bind platformrez-bind archrez-bind osrez-bind python</code></pre><p>安装好之后，会在 %userprofile%&#x2F;packages 目录下找到已经安装的 Rez 包</p><h4 id="验证安装结果"><a href="#验证安装结果" class="headerlink" title="验证安装结果"></a>验证安装结果</h4><p>为了验证是否安装成功，可以使用下面的命令：（其中 “which python”是你的python版本）</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-env python-which python</code></pre><p>使用 exit 退出环境。</p><h4 id="构建第一个包"><a href="#构建第一个包" class="headerlink" title="构建第一个包"></a>构建第一个包</h4><p>.需要确认%userprofile%&#x2F;packages 存在且可写入<br>.需要确认cmake 工具安装且可用（注：官方文档中会使用这个工具在ios系统上安装下面的包，但我还未在Windows10系统上成功安装该包，似乎有些依赖包的冲突问题，但好像不影响使用，正在求证中。。。）<br>rez-build 工具用于构建包并在本地安装它们（%userprofile%&#x2F;packages下）。 完成后，您可以通过 rez-env 使用它们，就像任何其他软件包一样：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">cd example_packages&#x2F;hello_worldrez-build --install</code></pre><h4 id="测试构建的包"><a href="#测试构建的包" class="headerlink" title="测试构建的包"></a>测试构建的包</h4><p>使用rez-env命令来请求一个（或多个）你已经安装的软件包环境</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-env hello_world</code></pre><p>提示符前的插入符号 (&gt;) 是一个视觉提示，告诉你现在位于 rez 配置的子 shell 中。 Rez 不会更新当前环境，而是配置一个子shell 并将你置于其中。<br>如果你已经在rez shell的配置环境中，并且忘记了当前可用的软件包列表。可以使用 rez-context 工具查看：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-context</code></pre><p>退出这个环境，使用exit命令。</p><p>你还可以创建一个已配置的环境并在其中运行一个命令，只需一个命令。 当您使用这种形式时，shell 会在命令运行后立即退出：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-env hello_world -- hello </code></pre><h4 id="软件包命令"><a href="#软件包命令" class="headerlink" title="软件包命令"></a>软件包命令</h4><p>查看搜索路径:</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-config</code></pre><p>查看当前配置环境：</p><pre class="language-cmd" data-language="cmd"><code class="language-cmd">rez-context</code></pre><h4 id="在共享路径下搜索插件包"><a href="#在共享路径下搜索插件包" class="headerlink" title="在共享路径下搜索插件包"></a>在共享路径下搜索插件包</h4><p>首先，需要为系统设置配置文件的用户环境变量 REZ_CONFIG_FILE 指向 rezconfig.py文件；为系统用户的环境变量中添加环境变量 REZ_CONFIG_FILE ，并且值为”S:\opt\rez\Lib\site-packages\rez\rezconfig.py”(本文将 rez安装在S盘，对应安装的根目录即可)，然后添加插件包的存放路径即可，若不添加环境变量，则默认从安装路径获取配置文件信息。<br>下面是配置文件中，通过修改packages_path变量修改获取共享路径中的插件路径：</p><pre class="language-python" data-language="python"><code class="language-python"># The package search path. Rez uses this to find packages. A package with the# same name and version in an earlier path takes precedence.packages_path &#x3D; [    &quot;~&#x2F;packages&quot;,           # locally installed pkgs, not yet deployed    &quot;~&#x2F;.rez&#x2F;packages&#x2F;int&quot;,  # internally developed pkgs, deployed    &quot;~&#x2F;.rez&#x2F;packages&#x2F;ext&quot;,  # external (3rd party) pkgs, such as houdini, boost    &quot;S:&#x2F;rez&#x2F;packages&#x2F;dcc&quot;,  # dcc软件共享路径    &quot;S:&#x2F;rez&#x2F;packages&#x2F;plugins&quot;,  # 插件共享路径    &quot;S:&#x2F;rez&#x2F;packages&#x2F;third_party&quot;, # 第三方插件路径    &quot;S:&#x2F;rez&#x2F;packages&#x2F;tools&quot; # 自定义工具路径]</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rez 是一个跨平台程序包管理器，通过它可以给程序配置独立的环境</summary>
    
    
    
    <category term="Rez" scheme="http://mirrorcg.github.io/categories/Rez/"/>
    
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
    <category term="包管理" scheme="http://mirrorcg.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CG流程中&quot;USD&quot;的探索与运用</title>
    <link href="http://mirrorcg.github.io/posts/20220307a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220307a1.html</id>
    <published>2022-03-06T16:13:03.000Z</published>
    <updated>2022-06-08T04:56:27.544Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>USD部分名词中文概述<a href="https://szxk.github.io/docs.usd/" title="" target="">点击这里</a>查看。</li><li>maya输出USD：当一个USD文件输出错误，不能用于reference要重新输出USD文件时，需将错误的文件删除再输出USD文件（覆盖无效依旧会使用内存中暂存的USD数据），若不删除，即使设置正确，输出的数据依旧是错误的（maya2023.0测试结果）。</li><li>从maya导出usd,不勾选任何材质球，导入后即为干净的模型USD文件。</li><li>导出设置“Create USD Parent Scope”可用于编辑Layerusd时，识别usd文件中的prom模型分类，在USD文件中会将defaultPrim值设置为“Create USD Parent Scope”的值，并且会在xfrom外多定义一层Scope。</li></ul><p><img src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E2%80%9DUSD%E2%80%9C%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%BF%90%E7%94%A8/%E5%AF%BC%E5%87%BA%E6%97%B6%E8%AE%BE%E7%BD%AEcreateUseParentScope%E5%B1%9E%E6%80%A7%E6%95%88%E6%9E%9C.png" alt="导出时设置createUseParentScope属性效果 png" srcset="/images/home/Myhead.jpg" data-src="/images/CG%E6%B5%81%E7%A8%8B%E4%B8%AD%E2%80%9DUSD%E2%80%9C%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E8%BF%90%E7%94%A8/%E5%AF%BC%E5%87%BA%E6%97%B6%E8%AE%BE%E7%BD%AEcreateUseParentScope%E5%B1%9E%E6%80%A7%E6%95%88%E6%9E%9C.png" class="lozad post-image"></p><ul><li>maya2023 自身的USD导出的USD数据，其中材质网络的部分虽有记录但不能在maya中直接使用。</li><li>maya2023 自身的USD导出的USD数据，可以reference但是没材质，不能用于Arnold的StandIn;arnold插件导出的USD数据，携带ArnoldOptions设置。其可以用于StandIn，也可以用于USD层编辑器，但是不能reference。</li><li>目前maya 2023 自身的USD功能以及Arnold的USD功能还不完善，还有许多功能需要开发才能用于项目流程中。</li></ul><p>————— 更新于2022-06-01 —————</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Doc" scheme="http://mirrorcg.github.io/categories/Doc/"/>
    
    <category term="学习笔记" scheme="http://mirrorcg.github.io/categories/Doc/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="USD" scheme="http://mirrorcg.github.io/tags/USD/"/>
    
    <category term="Pipeline" scheme="http://mirrorcg.github.io/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>Deadline中的事件示例</title>
    <link href="http://mirrorcg.github.io/posts/20220306a1.html"/>
    <id>http://mirrorcg.github.io/posts/20220306a1.html</id>
    <published>2022-03-06T10:01:02.000Z</published>
    <updated>2022-07-21T17:07:01.314Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此文章是记录Deadline农场管理软件中的消息事件插件编写的示例。<span id="more"></span></p><h3 id="事件插件的作用和执行顺序"><a href="#事件插件的作用和执行顺序" class="headerlink" title="事件插件的作用和执行顺序"></a>事件插件的作用和执行顺序</h3><p>Deadline 的所有插件都是Python写的，事件插件可用于更新新快照或任务的状态，或者可用于在一个作业状态更改时处理相关的作业。并且插件都是以非交互式的方式执行，编写插件时不应该包含阻塞操作(如无限循环)或需要用户输入的界面。当我们的事件插件被执行时，日志中会显示插件是从哪里加载的。<br>Deadline中有很多事件，事件插件的触发是按顺序的，并且顺序是可配置的：</p><p><img src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E9%A1%BA%E5%BA%8F%E4%BF%AE%E6%94%B9.png" alt="event顺序修改" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E9%A1%BA%E5%BA%8F%E4%BF%AE%E6%94%B9.png" class="lozad post-image"></p><h3 id="创建事件脚本"><a href="#创建事件脚本" class="headerlink" title="创建事件脚本"></a>创建事件脚本</h3><p>首先要在存储库的custom\events文件夹中创建一个文件夹，并为其命名您的事件插件，如：</p><p><img src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="event创建事件文件夹" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9.png" class="lozad post-image"></p><p>创建好文件夹后，我们需要新建一个和该文件夹相同明明的 .py 文件，并在文件中写入相应的基本内容（导入deadline事件命名空间；GetDeadlineEventListener()函数获取MyEvent类的一个实例，没有会报错；MyEvent类将需要基于想要响应的事件实现某些回调；当不再使用该事件插件，CleanupDeadlineEventListener()函数进行自动清理。）：</p><p><img src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6.png" alt="event创建事件脚本文件" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6.png" class="lozad post-image"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from Deadline.Events import *def GetDeadlineEventListener():    &quot;&quot;&quot;This is the function that Deadline calls to get an instance of the    main DeadlineEventListener class.    &quot;&quot;&quot;    return MyEvent()def CleanupDeadlineEventListener(deadlinePlugin):    &quot;&quot;&quot;This is the function that Deadline calls when the event plugin is    no longer in use so that it can get cleaned up.    &quot;&quot;&quot;    deadlinePlugin.Cleanup()class MyEvent(DeadlineEventListener):    &quot;&quot;&quot;This is the main DeadlineEventListener class for MyEvent&quot;&quot;&quot;    # TODO: Place code here to replace &quot;pass&quot;    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们完成上述脚本文件的内容后，我们将会得到下面的脚本内容：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python3# -*- coding:utf-8 -*-# @Auther: Mirror# @Time: 2020&#x2F;07&#x2F;01# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;from System import *from System.Collections.Specialized import *from System.IO import *from System.Text import *from Deadline.Scripting import *from Deadline.Events import *import time######################################################################## This is the function that Deadline calls to get an instance of the## main DeadlineEventListener class.######################################################################def GetDeadlineEventListener():    return MyEvent()######################################################################## This is the function that Deadline calls when the event plugin is## no longer in use so that it can get cleaned up.######################################################################def CleanupDeadlineEventListener(deadlinePlugin):    deadlinePlugin.Cleanup()######################################################################## This is the main DeadlineEventListener class for MyEvent.######################################################################class MyEvent(DeadlineEventListener):    def __init__(self):        # Set up the event callbacks here        self.OnJobFinishedCallback +&#x3D; self.OnJobFinished        self.OnJobFailedCallback +&#x3D; self.OnJobFailed    def Cleanup(self):        del self.OnJobFinishedCallback        del self.OnJobFailedCallback    def OnJobFinished(self, job):        # TODO: Connect to pipeline site to notify it that the job for a particular        # shot or task is complete.        job_name &#x3D; job.JobName        job_mach &#x3D; job.GetJobInfoKeyValue(&quot;MachineName&quot;)        job_user &#x3D; job.JobUserName        if job_mach.lower() &#x3D;&#x3D; &quot;renderfarm&quot;:            slaves &#x3D; None        else:            slaves &#x3D; [job_mach]        if slaves:            for each in slaves:                curr_time &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))                slave &#x3D; each                massages &#x3D; &quot;Cur_time:  &#123;curtime&#125;\nJob_user:  &#123;user&#125;\n\nmassages:  Job named \&#39;&#123;jobname&#125;\&#39; had been complate&quot;.format(                    curtime&#x3D;curr_time, user&#x3D;job_user, jobname&#x3D;job_name)                self.sendmessages(slave, massages)        print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)        self.LogInfo(&quot;\&#39;%s\&#39; is complated&quot; % job_name)        self.LogInfo(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)    def OnJobFailed(self, job):        &quot;&quot;&quot;        Deadline will to do sometion when job or task is faild        :param job: which Work being monitored        :return: None        &quot;&quot;&quot;        job_name &#x3D; job.JobName        job_mach &#x3D; job.GetJobInfoKeyValue(&quot;MachineName&quot;)        job_user &#x3D; job.JobUserName        if job_mach.lower() &#x3D;&#x3D; &quot;renderfarm&quot;:            slaves &#x3D; [&quot;DESKTOP-Mirror&quot;]        else:            if job_mach &#x3D;&#x3D; &quot;DESKTOP-Mirror&quot;:                slaves &#x3D; [job_mach]            else:                slaves &#x3D; [job_mach, &quot;DESKTOP-Mirror&quot;]        for each in slaves:            curr_time &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))            slave &#x3D; each            massages &#x3D; &quot;Cur_time:  &#123;curtime&#125;\nJob_user:  &#123;user&#125;\nmassages:  Job named \&#39;&#123;jobname&#125;\&#39; had been failed&quot;.format(                curtime&#x3D;curr_time, user&#x3D;job_user, jobname&#x3D;job_name)            self.sendmessages(slave, massages)        print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)        self.LogInfo(&quot;\&#39;%s\&#39; is failed&quot; % job_name)        self.LogInfo(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)    def sendmessages(self, slaves, messages):        &quot;&quot;&quot;        :param            slaves: machines&#96;s machines name or IP address.            messages: the messages which is send by current serve]        :return            cmd is executed by system        &quot;&quot;&quot;        args &#x3D; StringCollection()        args.Add(&quot;-SendPopupMessage&quot;)        args.Add(&quot;%s&quot; % slaves)        args.Add(&quot;%s&quot; % messages)        ClientUtils.ExecuteCommand(args)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建事件参数文件"><a href="#创建事件参数文件" class="headerlink" title="创建事件参数文件"></a>创建事件参数文件</h3><p>创建完事件插件的脚本后，我们需要在上述文件夹中为事件插件添加与文件夹同名的参数文件（.param）供 Deadline 进行读取，创建参数界面：</p><p><img src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6.png" alt="event创建事件参数文件" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6.png" class="lozad post-image"><br>参数文件内容：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">[State]Type=EnumItems=Global Enabled;Opt-In;DisabledCategory=OptionsCategoryOrder=0Index=0Label=StateDefault=DisabledDescription=How this event plug-in should respond to events. If Global, all jobs and slaves will trigger the events for this plugin. If Opt-In, jobs and slaves can choose to trigger the events for this plugin. If Disabled, no events are triggered for this plugin.[EventCallbacks]Type=LabelDescription=The Event Callbacks that this Event Plugin subscribes to.Default=OnJobFailed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它将声明 Monitor 用来生成用户界面的属性，该用户界面用于修改数据库中的自定义设置，创建该文件后，打开监视器并进入超级用户模式。然后选择Tools -&gt; Configure Events，在左边的列表中查找该事件插件。</p><p><img src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E4%BA%8B%E4%BB%B6%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE.png" alt="event事件插件配置" srcset="/images/home/Myhead.jpg" data-src="/images/Deadline%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%A4%BA%E4%BE%8B/event%E4%BA%8B%E4%BB%B6%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE.png" class="lozad post-image"></p><p>至此，在 Deadline 中创建自定义任务消息失败&#x2F;成功的事件已经完成，每当Deadline 中有任务失败时&#x2F;成功时，Deadline 会自动给任务的提交者发送一条相关的消息弹框，用于给制作人员反馈及时的渲染消息。</p><p>注意：需要注意 Deadline 当前使用的 Python 版本，避免出现不兼容的情况</p><p>咱们有空可以看看<a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/1_User%20Manual/manual/event-plugins.html" title="" target="">官方文档</a>是怎么说的，里面有更加详细的内容哦。</p><a href="https://docs.thinkboxsoftware.com/products/deadline/10.1/2_Scripting%20Reference/index.html" title="" target="">官方文档中事件脚本文档</a>]]></content>
    
    
    <summary type="html">&lt;p&gt;此文章是记录Deadline农场管理软件中的消息事件插件编写的示例。</summary>
    
    
    
    <category term="Deadline" scheme="http://mirrorcg.github.io/categories/Deadline/"/>
    
    <category term="插件" scheme="http://mirrorcg.github.io/categories/Deadline/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="插件" scheme="http://mirrorcg.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
</feed>
