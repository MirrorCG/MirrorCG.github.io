[{"title":"rez安装使用","url":"/posts/20220314a1.html","content":"Rez 是一个跨平台程序包管理器，通过它可以给程序配置独立的环境,每个独立环境中只是引用了这些包。所以它的环境配置是轻量级的，与其它程序包环境管理不同的是，所有的程序包的安装都在一个中央统一的位置，尽管有几百个包，通常也只需要几秒就可以进行配置。将 Rez 作为工作室 DCC 软件启动器依赖项是个不错的选择。下面将简单介绍 Windows环境下，Rez 包管理器如何安装使用。\n下载安装包从 GitHub 上拉取 Rez 原项目的的相关仓库，然后打开CMD进入拉取仓库所在的目录中执行：\npython .&#x2F;install.py \n这将会把包安装在当前位置的 &#x2F;opt&#x2F;rez 目录下也可以使用Pip进行安装：\npip install rez\n但使用 pip 的安装方式并不能很好的用在生产环境中,使用 install 脚本安装是推荐的方法，它可以保证 Rez 拥有独立 python 于的环境独立运行。\n创建基本的 Rez 包这里需要使用管理员权限去安装包，rez-bind 工具创建基于已安装在系统上的软件的 Rez 包：（–quickstart是以标准形式安装包）\nrez-bind --quickstart\n你也可以分开安装\nrez-bind platform\nrez-bind arch\nrez-bind os\nrez-bind python\n安装好之后，会在 %userprofile%&#x2F;packages 目录下找到已经安装的 Rez 包\n验证安装结果为了验证是否安装成功，可以使用下面的命令：（其中 “which python”是你的python版本）\nrez-env python-which python\n使用 exit 退出环境。\n构建第一个包.需要确认%userprofile%&#x2F;packages 存在且可写入.需要确认cmake 工具安装且可用（注：官方文档中会使用这个工具在ios系统上安装下面的包，但我还未在Windows系统上成功安装，但好像不影响使用，正在找求证正中）rez-build 工具用于构建包并在本地安装它们（%userprofile%&#x2F;packages下）。 完成后，您可以通过 rez-env 使用它们，就像任何其他软件包一样：\ncd example_packages&#x2F;hello_world\nrez-build --install\n\n测试构建的包使用rez-env命令来请求一个（或多个）你已经安装的软件包环境\nrez-env hello_world\n提示符前的插入符号 (&gt;) 是一个视觉提示，告诉你现在位于 rez 配置的子 shell 中。 Rez 不会更新当前环境，而是配置一个子shell 并将你置于其中。如果你已经在rez shell的配置环境中，并且忘记了当前可用的软件包列表。可以使用 rez-context 工具查看：\nrez-context\n退出这个环境，使用exit命令。\n你还可以创建一个已配置的环境并在其中运行一个命令，只需一个命令。 当您使用这种形式时，shell 会在命令运行后立即退出：\n","categories":["Rez"],"tags":["Pipeline","包管理"]},{"title":"USD流程的探索与运用","url":"/posts/20220307a1.html","content":"","categories":["Maya","杂项"],"tags":["USD","Pipeline"]},{"title":"Deadline中的事件示例","url":"/posts/20220306a1.html","content":"此文章是记录Deadline农场管理软件中的消息事件插件编写的示例。\n事件插件的作用和执行顺序Deadline 的所有插件都是Python写的，事件插件可用于更新新快照或任务的状态，或者可用于在一个作业状态更改时处理相关的作业。并且插件都是以非交互式的方式执行，编写插件时不应该包含阻塞操作(如无限循环)或需要用户输入的界面。当我们的事件插件被执行时，日志中会显示插件是从哪里加载的。Deadline中有很多事件，事件插件的触发是按顺序的，并且顺序是可配置的：\n\n创建事件脚本首先要在存储库的custom\\events文件夹中创建一个文件夹，并为其命名您的事件插件，如：\n\n创建好文件夹后，我们需要新建一个和该文件夹相同明明的 .py 文件，并在文件中写入相应的基本内容（导入deadline事件命名空间；GetDeadlineEventListener()函数获取MyEvent类的一个实例，没有会报错；MyEvent类将需要基于想要响应的事件实现某些回调；当不再使用该事件插件，CleanupDeadlineEventListener()函数进行自动清理。）：\n\nfrom Deadline.Events import *\n\ndef GetDeadlineEventListener():\n    \"\"\"This is the function that Deadline calls to get an instance of the\n    main DeadlineEventListener class.\n    \"\"\"\n    return MyEvent()\n\ndef CleanupDeadlineEventListener(deadlinePlugin):\n    \"\"\"This is the function that Deadline calls when the event plugin is\n    no longer in use so that it can get cleaned up.\n    \"\"\"\n    deadlinePlugin.Cleanup()\n\nclass MyEvent(DeadlineEventListener):\n    \"\"\"This is the main DeadlineEventListener class for MyEvent\"\"\"\n    # TODO: Place code here to replace \"pass\"\n    pass\n\n当我们完成上述脚本文件的内容后，我们将会得到下面的脚本内容：\n#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n# @Auther: Mirror\n# @Time: 2020/07/01\n# =========================================\nfrom System import *\nfrom System.Collections.Specialized import *\nfrom System.IO import *\nfrom System.Text import *\nfrom Deadline.Scripting import *\nfrom Deadline.Events import *\nimport time\n\n\n######################################################################\n## This is the function that Deadline calls to get an instance of the\n## main DeadlineEventListener class.\n######################################################################\ndef GetDeadlineEventListener():\n    return MyEvent()\n\n\n######################################################################\n## This is the function that Deadline calls when the event plugin is\n## no longer in use so that it can get cleaned up.\n######################################################################\ndef CleanupDeadlineEventListener(deadlinePlugin):\n    deadlinePlugin.Cleanup()\n\n\n######################################################################\n## This is the main DeadlineEventListener class for MyEvent.\n######################################################################\nclass MyEvent(DeadlineEventListener):\n\n    def __init__(self):\n        # Set up the event callbacks here\n        self.OnJobFinishedCallback += self.OnJobFinished\n        self.OnJobFailedCallback += self.OnJobFailed\n\n    def Cleanup(self):\n        del self.OnJobFinishedCallback\n        del self.OnJobFailedCallback\n\n    def OnJobFinished(self, job):\n        # TODO: Connect to pipeline site to notify it that the job for a particular\n        # shot or task is complete.\n        job_name = job.JobName\n        job_mach = job.GetJobInfoKeyValue(\"MachineName\")\n        job_user = job.JobUserName\n        if job_mach.lower() == \"renderfarm\":\n            slaves = None\n        else:\n            slaves = [job_mach]\n        if slaves:\n            for each in slaves:\n                curr_time = time.strftime('%Y-%m-%d', time.localtime(time.time()))\n                slave = each\n                massages = \"Cur_time:  &#123;curtime&#125;\\nJob_user:  &#123;user&#125;\\n\\nmassages:  Job named \\'&#123;jobname&#125;\\' had been complate\".format(\n                    curtime=curr_time, user=job_user, jobname=job_name)\n                self.sendmessages(slave, massages)\n        print(\"================================================================================================\")\n        self.LogInfo(\"\\'%s\\' is complated\" % job_name)\n        self.LogInfo(\"================================================================================================\")\n\n    def OnJobFailed(self, job):\n        \"\"\"\n        Deadline will to do sometion when job or task is faild\n        :param job: which Work being monitored\n        :return: None\n        \"\"\"\n        job_name = job.JobName\n        job_mach = job.GetJobInfoKeyValue(\"MachineName\")\n        job_user = job.JobUserName\n        if job_mach.lower() == \"renderfarm\":\n            slaves = [\"DESKTOP-Mirror\"]\n        else:\n            if job_mach == \"DESKTOP-Mirror\":\n                slaves = [job_mach]\n            else:\n                slaves = [job_mach, \"DESKTOP-Mirror\"]\n        for each in slaves:\n            curr_time = time.strftime('%Y-%m-%d', time.localtime(time.time()))\n            slave = each\n            massages = \"Cur_time:  &#123;curtime&#125;\\nJob_user:  &#123;user&#125;\\nmassages:  Job named \\'&#123;jobname&#125;\\' had been failed\".format(\n                curtime=curr_time, user=job_user, jobname=job_name)\n            self.sendmessages(slave, massages)\n        print(\"================================================================================================\")\n        self.LogInfo(\"\\'%s\\' is failed\" % job_name)\n        self.LogInfo(\"================================================================================================\")\n\n    def sendmessages(self, slaves, messages):\n        \"\"\"\n        :param\n            slaves: machines`s machines name or IP address.\n            messages: the messages which is send by current serve]\n        :return\n            cmd is executed by system\n        \"\"\"\n        args = StringCollection()\n        args.Add(\"-SendPopupMessage\")\n        args.Add(\"%s\" % slaves)\n        args.Add(\"%s\" % messages)\n        ClientUtils.ExecuteCommand(args)\n\n\n\n创建事件参数文件创建完事件插件的脚本后，我们需要在上述文件夹中为事件插件添加与文件夹同名的参数文件（.param）供 Deadline 进行读取，创建参数界面：\n参数文件内容：\n[State]\nType=Enum\nItems=Global Enabled;Opt-In;Disabled\nCategory=Options\nCategoryOrder=0\nIndex=0\nLabel=State\nDefault=Disabled\nDescription=How this event plug-in should respond to events. If Global, all jobs and slaves will trigger the events for this plugin. If Opt-In, jobs and slaves can choose to trigger the events for this plugin. If Disabled, no events are triggered for this plugin.\n\n[EventCallbacks]\nType=Label\nDescription=The Event Callbacks that this Event Plugin subscribes to.\nDefault=OnJobFailed\n\n它将声明 Monitor 用来生成用户界面的属性，该用户界面用于修改数据库中的自定义设置，创建该文件后，打开监视器并进入超级用户模式。然后选择Tools -&gt; Configure Events，在左边的列表中查找该事件插件。\n\n至此，在 Deadline 中创建自定义任务消息失败&#x2F;成功的事件已经完成，每当Deadline 中有任务失败时&#x2F;成功时，Deadline 会自动给任务的提交者发送一条相关的消息弹框，用于给制作人员反馈及时的渲染消息。\n注意：需要注意 Deadline 当前使用的 Python 版本，避免出现不兼容的情况\n咱们有空可以看看官方文档是怎么说的，里面有更加详细的内容哦。\n","categories":["Deadline","插件"],"tags":["插件"]},{"title":"如何搭建个人博客","url":"/posts/20220302a1.html","content":"作为一名学习任何技术都习惯做笔记的好学生，还在使用思维导图记录知识点？或是用word写文档，甚至是\"白纸黑字\"码字！！！都2202年了，是不是该寻找一种既方便自己随时查找翻看，又可以和小朋友们一起分享知识和经验的方式呢？这时，拥有一个属于自己的个人博客，实属是一个迫在眉睫的需求。于是，我有了自己的博客。接下来将介绍从无到有搭建属于自己的个人博客过程。\n\n准备材料1.一台能联网、没有脑梗的计算机2.Windows系统（我就只会用“窗口”）3.git包管理工具4.一个知道账号和密码的github账号5.记住这个网址，一会儿要用：https://www.nodejs.org/6.随时准备问候度娘，因为我也不清楚你会遇到些什么疑难杂症\n开始搭建本地环境首先，点击下载git，下载适合自己系统的最新git版本安装包，以默认方式安装。 \n然后，我们再在电脑上访问刚才让你记住的网址，从网址上下载我们需要的LTS版node.js安装包，直接双击安装它。不出意外的话，安装好的node.js会给你反馈安装了两个组件（node.js和npm包管理工具），我们可以直接去cmd中验证。\n\n打开cmd,利用npm包管理工具安装今天的主角Hexo博客，先输入命令行安装cnpm的同时将镜像源指向淘宝：\n\nnpm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org\n\n安装hexo-cli：\n\ncnpm install -g hexo-cli\n\n找个你觉得合适的位置创建一个文件夹，用于存放你的博客产生的所有文件，在cmd中将路径切换到创建的文件夹：\n\ncd &#x2F;d &quot;你刚刚创建的文件夹路径&quot;\n\n初始化咱们的博客目录：\n\nhexo init \n\n启动我们的Hexo本地服务，可在https://localhost:4000访问，但博客中只有一篇和hexo用户指南相关的文章：\n\nhexo s\n\n如果网页打不开，win10执行下面代码后再重复上一步： \n\nnpm install hexo-server\n\n创建新的博客文章： \n\nhexo new &quot;我的第一篇博客文章&quot;\n\n创建好后，在刚刚创建的博客文件夹的\\source\\_posts\\路径下能看到刚才创建的\"我的第一篇博客文章.md\"文件，用文本编辑器即可对内容进行编辑，然后刷新https://localhost:4000，就能看到刚刚创建的博客文章出现在网页上，ctrl + C 退出本地服务，。\n\n清除产生的静态博客文件(public)文件夹： \n\nhexo clean\n\n\n构建存储库登录github,创建一个新的仓库用于存储从本地推送的静态博客文件：repository neme 必须是：\"GitHub昵称加.github.io\"，description添加自定义描述，创建库。\ncmd下载hexo插件：\n\ncnpm install --save hexo-deployer-git\n\n文本打开博客文件夹根目录下的\"_config.yml\"文件，在文件尾部添加在文件尾部添加：\n\n## 添加储存库配置\ndeploy:\n  type: git\n  repo: (你的储存库地址)\n  branch: master \n## 注意：冒号后面有空格\n\n要将博客部署到github上，需要先配置git全局用户名和邮箱：\n\ngit config --global user.email \"github中的邮箱地址\"\ngit config --global user.name \"github中的用户名\"\n\n从22021年8月14日(七夕)那天开始，推送代码到GitHub需要使用token登录而不是密码，因此，我们需要先获取token。\n\n使用git生成SSH，运行 git Bash 客户端，检测是否存在ssh文件,换句话说就是检查是否存在 id_rsa.pub 或 id_dsa.pub 文件,如果存在可以跳过下面两步，输入如下代码：\n\ncd ~/.ssh\nls\n\n创建SSH：\n\nssh-keygen -t rsa -C &quot;你的邮箱&quot;\n\n等待一会儿，当看到\"Your identification has been saved in /c/Users/you/.ssh/id_rsa.\nYour public key has been saved in /c/Users/you/.ssh/id_rsa.pub.\nThe key fingerprint is:.............\"内容时，表示创建成功。在C盘User文件夹（可能会在桌面）可以找到ssh文件夹， 需要把id_rsa.pub文件中的内容添加到github。步骤是 Settings-->SSH and GPG Keys --->News SSH key，然后把id_rsa里的内容复制进去。\n\n回到cmd,部署博客到Github,两次输入都需要输入用户名和令牌(令牌不要手动输入，可以直接复制粘贴，尽管看不到粘贴内容，但还是要操作，才能成功):\n\nhexo d\n\n稍等两分钟，就可以访问博客页啦：https://github昵称加.github.io\n\n\n更换主题可以 点击这里 获取更多主题仓库地址，克隆主题到本地：\n\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/主题名称\n\n修改博客根目录_config.yml文件，修改theme字段后的内容为 “主题名称”。\n\n清理hexo目录：\n\nhexo clean\n\n重新生成hexo静态博客文件夹及其内容：\n\nhexo g\n\n推送远端：\n\nhexo d\n\n\n大佬的博客搭建教程视频：点击这里，更多的部署细节可在视频中找到哦。\n","categories":["Doc","学习笔记"],"tags":["Blog","Hexo","github"]},{"title":"CG流程中使用ACES色彩管理","url":"/posts/20220302a1.html","content":"构建CG流程中的ACES色彩管理流程 ,为什么要构建呢？因为：1.色域更高，能容纳更多的色彩，显示的色彩更丰富；2.能接受更高的灯光强度，画面比较不会过曝（不要调皮地将灯光强度调的特别高哦）;3.更物理更真实，颜色会随着亮度地提升，饱和度逐渐降低。相对的就会有些缺点：图片占用存储空间会变大。\n在CG流程中的大概过程就是，sRGB图片进入DCC软件被AECSCG线性转换函数转换编码到ACES色域中被管理&gt;渲染器处理贴图信息后生成ACES色域图片&gt;经过编码转换到视图中显示或输出为指定色域的图片用于存储(srgb或ACES)、进一步编辑（ACES）\n测试环境Substance painter 7.1 + Maya 2020.4 + Nukel2.3 + ACES1.1\n\nSP软件配置由于SP要在7.4版本以后才支持 OCIO 配置文件，并且目前大部分资产贴图都采用sRGB色域编码，因此默认使用传统 SP(sRGB)到 MAYA(ACES) 中进行 sRGB 色域空间转换到 ACES 色域空间的方式。传统SP流程可以通过LMT(外观转换)的LUT(查找表)文件用于显示（只是看起来和AECES差不多，但实除上还是SRGB色域的图片）具体方法是：file > import resource > 添加资源 > 选择Lut文件 > 修改定义为 colorLut > 导入到\"工具架\" > 导入，然后在显示设置中将 activate post effects恢复默认,勾选activate post effects，勾选activate post effects > tone mapping(色调映射),将 activate post effects > tone mapping > function(功能)设置为log(日志)，并勾选activate color porfile > porfile 修改为 ACES_Standard_log,white_Point 设置为默认值，此时我们从SP软件的视口中看见的色彩在视觉上基本等同ACES色域图显示的效果。\n\nMay启动时配置 ACES 色彩管理Maya中使用 ACES 色彩管理空间，在具备有效的 config.ocio 配置文件的情况下，为 Maya 设置环境变量\"OCIO = 文件全路径\",此时Maya中的色彩管理空间将使用 OCIO 配置文样中的设置，该设置会在基于ACES 色彩管理的基础上自动修改渲染预览界面和视图界面的色彩空间，我们在显示器中看到的色彩信息并非线性空间的色彩信息，Maya后台输出的图片也是经 ACES 色彩空间编码后的图片，此时将渲染图片放入使用相同 ACES 配置文件的 Nuke 软件中，即可直接对 ACES 图片进行线性数据的操作。\n\n\nMaya 应用 OCIO 输入色彩空间规则到图片使用 OCIO 配置文件后，若勾选\"使用 OCIO 输入颜色空间规则\"则会使用\"OCIO Standard Rule\"对输入的文件进行色彩空间的转换，若不使用，则需要手动制定规则（自定义的配置不起作用时，可尝试将软件切成英文版)，然后将自定义的标准的色彩管理策略导出为 CM 文件,并添加环境变量\"MAYA_COLOR_MANAGEMENT_POLICY_FILE=CM文件全路径\"、\"MAYA_COLOR_MANAGEMENT_POLICY_LOCK=1\",用以全局配置所有渲染制作机，使保持相同的色彩配置，手动指定规则将按照规则的从上往下的顺序应用规则，由匹配成功的第一个规则指定输入的色彩空间。\n\n\n色彩空间管理的其他设置Ui 设置:启用后 Maya中的色彩盒子会显示得较灰一些，但不影响 ACES 色域着色。\n\n浮点渲染目标:开启色彩管理后，该选项也应该开启,才能在 Maya2020 中查看到正确的显示结果，并且应该使用32位格式，否则可能会出现色彩信息的裁剪，显示不正确，吸管吸取不到正确的色彩信息等情况。导出 CM 首选项：将自定义的色采管理首选项导出到指定的 CM 文件中，可用于软件启动的环境变量。\nNuke 中配置使用 ACES 色彩管理手动配置：\n仅为当前项目配置 ACES:\n打开软件后，按S键进行项目配置：点击 project setting >color栏，将\"color management\"修改为\"OCIO\",将COIO_config 修改为\"custom\", 然后将 OCIO 配置文件填入“custom_OCIO_config\"选项中（需保证Nuke中使用的 OCIO 配置文件和 MAYA 中使用的保持一致)或选择 Nuke 自带的 OCIO 配置文件，然后Nuke 即可自动设置部分常用的色彩空间编码设置。对于实拍源素材需要单独配置 Lut格式。\n\n  \n为 Nuke 默认启动配置 ACES\n为软件默认配置:\n1.打开Nuke首选项:选择 Color Management 选择 Nuke 自带的 OCIO 配置或使用自己的 OCIO 配置，即可为软件配置 ACES 色彩管理空间，重启软件即可生效。\n2.环境变量配置，启动环境中添加环境变量：OCIO = 文件位置\n\n\n\nNuke 输出sRGB素材对于使用EXR输出作为合成过程的中间素材，使用默认的 ACES 色域编码的exr格式文件，保持图片信息的完整，勾选\"输出保持ACES 兼容的EXR\"；输出序列时，则直接转回sRGB色域编码（使用output_srgb编码方式输出）\n\n\n\n\n\n\n相关软件插件下载链接Substance Painter插件滤镜：https://pan.baidu.com/s/1FFpBeih902gMJWVQrzEwbw 提取码: anqqOCIO配置文件下载地址：https://github.com/colour-science/OpenColorIO-Configs/tree/feature/aces-1.2-config\n","categories":["Maya","杂项"],"tags":["灯光","合成","ACES"]},{"title":"Maya获取选中相机视口中的对象","url":"/posts/20220228a1.html","content":"从Maya视图窗口中获取相机视角中所有的对象，可以利用OpenMaya和OpenMayaUI两个模块来完成此功能，首先需要指定相机，并通过遍历相机视口，来获取相机视口中的对象：\n\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n# @Auth0r: Mirror\n# @Time: ----\n# =========================================\n\nimport maya.cmds as cmds\nimport maya.OpenMaya as OpenMaya\nimport maya.OpenMayaUI as OpenMayaUI\n\n\ndef getObjInView(cam):\n    # 添加相机到 MDagPath\n    mdag_path = OpenMaya.MDagPath()\n    sel = OpenMaya.MSelectionList()\n    sel.add(cam)\n    sel.getDagPath(0, mdag_path)\n\n    # 遍历视口\n    draw_traversal = OpenMayaUI.MDrawTraversal()\n\n    # 创建视锥\n    draw_traversal.setFrustum(mdag_path, cmds.getAttr(\"defaultResolution.width\"),cmds.getAttr(\"defaultResolution.height\"))\n    draw_traversal.traverse()\n    frustum_objs = []\n\n    # Loop through obiects within frustum\n    for i in range(draw_traversal.numberOfItems()):\n        # 先返回shape, 所以需要先获取它的transforn\n        shape_dag_path = OpenMaya.MDagPath()\n        draw_traversal.itemPath(i, shape_dag_path)\n        transform_dag_path = OpenMaya.MDagPath()\n        OpenMaya.MDagPath.getAPathTo(shape_dag_path.transform(), transform_dag_path)\n        # 获取物体的长名并且确保它是有效的transform\n        obj = transform_dag_path.fullPathName()\n\n        if cmds.objExists(obj):\n            frustum_objs.append(obj)\n            cmds.select(frustum_objs)\n\n\nif __name__ == \"__main__\":\n    # 需要指定相机\n    cam = 'persp'  # 指定相机\n    getObjInView(cam) \n\n","categories":["Maya","杂项"],"tags":["OpenMaya"]},{"title":"Maya获取指定物体到Camera焦点平面的距离","url":"/posts/20220227a1.html","content":"文章介绍在Maya中获取物体到相机焦点所在平面的距离，并将获取到的距离写入相机的焦距属性，使用Arnold渲染。\n本文介绍两种获取相机焦距的方法提供参考：一种是利用向量的办法计算向量之间的投射长度获取焦距，另一种是使用约束的方式获取焦距。\n\n方法一：计算向量在三维空间中，已知相机单位向量、位置和物体坐标，可计算出相机焦点到物体的距离（该距离并非我们所要求的焦点平面到物体的距离），得到一个空间中存在的长方体，经过对物体和相机两点之间构成的向量投射到相机单位向量方向上的投影长度，即我们所求的相机焦点平面到物体的距离。如下图所示，空间中，我们需要获取线段ob之间的距离，其中线段oa之间的距离可根据相机和物体的坐标计算得出，相机法向量v可从相机中获取，由此我们可计算得出线段oa在向量v方向的投影。\n\n\n首先，我们需要通过xfrom方法获取相机的法向量：\n\nCam = mc.xform(cam.name(), q=True, ws=True, m=True)[8:11]  # 数组第8到第10位为相机法向量\nCam_vector = np.array(Cam) * -1   # 由于取出的数据是列表，这里需要转换成向量再取反，即为相机单位向量方向\n\n\n获取相机的坐标和物体的坐标，计算得出向量oa：\n\ndef getVector(locatorP, camP):\n    \"\"\"计算向量坐标\n        locatorP: 物体坐标\n        camP：相机坐标\n    \"\"\"\n    newVector = (locatorP[0] - camP[0], locatorP[1] - camP[1], locatorP[2] - camP[2])\n    return newVector\n\n\n由于需要区分向量之间的夹角，若为锐角，焦距为正，反之为负：\n\ndef judgeAngle(_ang):\n    \"\"\"计算向量角度为锐角还是钝角\"\"\"\n    _flag = (_ang * 180.0) / pi\n    print(u\"向量间的角度为: %s 度(角度制)\" % _flag)\n    if (_flag > 90) and (_flag &lt;= 180):\n        return -1\n    elif (_flag &lt; 90) and (_flag >= 0):\n        return 1\n    elif _flag == 90:\n        return 0\n\n\n使用上面获得的数据，即可求出相机焦点平面到物体的距离。以下为工具完整脚本：\n\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n# @Author: MirrorCG\n# @Time: 2021/12/28\n# =========================================\nimport maya.cmds as mc\nimport pymel.core as pm\nimport maya.mel as mel\nfrom math import pi, cos\nimport numpy as np\n\n\ndef getVector(locatorP, camP):\n    \"\"\"计算向量坐标\"\"\"\n    newVector = (locatorP[0] - camP[0], locatorP[1] - camP[1], locatorP[2] - camP[2])\n    return newVector\n\n\ndef squareRVector(_vector):\n    \"\"\"计算平方根，向量长度\"\"\"\n    AB = (_vector[0] * _vector[0] + _vector[1] * _vector[1] + _vector[2] * _vector[2]) ** 0.5\n    return AB\n\n\ndef judgeAngle(_ang):\n    \"\"\"计算向量角度为锐角还是钝角\"\"\"\n    _flag = (_ang * 180.0) / pi\n    print(u\"向量间的角度为: %s 度(角度制)\" % _flag)\n    if (_flag > 90) and (_flag &lt;= 180):\n        return -1\n    elif (_flag &lt; 90) and (_flag >= 0):\n        return 1\n    elif _flag == 90:\n        return 0\n\n\ndef getCam(camName):\n    \"\"\"获取选中的相机，填入窗口\"\"\"\n    try:\n        cam = pm.ls(sl=True)[0].getChildren()[0]  # 选择相机\n    except IndexError as e:\n        mc.warning(u\"未选中对象\")\n        return\n    if (not cam) or (cam.nodeType() != \"camera\"):\n        mc.warning(u\"未选中相机\")\n        return\n    _camName = cam.longName()\n    mc.textField(camName, e=True, tx=_camName)\n\n\ndef createLocator(locName, camName):\n    \"\"\"创建/获取locator,移动至相机位置，并将改1ocator填入窗口中\"\"\"\n    try:\n        cam = pm.ls(mc.textField(camName, q=True, tx=True))[0].getParent()\n    except IndexError as e:\n        mc.warning(u\"请选择并添加相机\")\n        return\n    camP = cam.getTranslation().get()  # 相机坐标\n    if mc.objExists(\"find_focous\") and pm.nodeType(pm.ls(\"find_focous\")[0].getChildren()[0]) == \"locator\":\n        loc = pm.ls(\"find_focous\")[0]\n    else:\n        loc = pm.createNode(\"locator\").getParent()\n        loc.rename(\"find_focous\")\n    loc.setAttr(\"translate\", camP)\n    mc.textField(locName, e=True, tx=loc.name())\n\n\ndef getInstance(instName, camName, locName, *args):\n    \"\"\"计算焦距，判断距离方向\"\"\"\n    if (not mc.textField(camName, q=True, tx=True)) or (not mc.textField(locName, q=True, tx=True)):\n        mc.warning(u\"请填入相机或locator(`find_focous`)\")\n        return\n    cam = pm.ls(mc.textField(camName, q=True, tx=True))[0].getParent()\n    camP = cam.getTranslation().get()\n    loc = pm.ls(mc.textField(locName, q=True, tx=True))[0]\n    cam_vector = np.array(mc.xform(cam.name(), q=True, ws=True, m=True)[8:11]) * -1  # 获取相机单位向量(从maya获取的向量需要取反\n    locatorP = loc.getAttr(\"translate\")  # 定位器坐标\n    AB_vector = getVector(locatorP, camP)\n    AB = squareRVector(AB_vector)  # 定位器距离相机距离\n    print(u\"定位器距离相机: %s 个单位\" % AB)\n    x = np.array(cam_vector)\n    y = np.array(AB_vector)\n    lx = np.sqrt(x.dot(x))\n    ly = np.sqrt(y.dot(y))\n    cos_angle = x.dot(y) / (lx * ly)\n    _angle = np.arccos(cos_angle)\n    _flag = judgeAngle(_angle)\n    if AB == 0:\n        focus = 0.1\n    else:\n        focus = abs(cos(_angle) * AB)\n    if _flag == 1:\n        pass\n    elif _flag == -1:\n        focus = (-1 * focus)\n    elif _flag == 0:\n        focus = 0.1\n    print(u\"相机焦距为: %s 个单位\" % focus)\n    mc.textField(instName, e=True, tx=\"%s\" % focus)\n    try:\n        cam.setAttr(\"focusDistance\", focus)\n    except RuntimeError as e:\n        print(u\"焦距小于默认最小值,设定为0.1\")\n    cam.setAttr(\"focusDistance\", 0.1)\n    print(\"=\" * 40)\n\n\ndef toolDoc(winName):\n    \"\"\"工具帮助\"\"\"\n    win_name = u\"工具帮助\"\n    if mc.window(win_name, q=True, ex=True):\n        mc.deleteUI(win_name, window=True)\n    helpWin= mc.window(u\"工具帮助\", t=u\"工具帮助\", wh=(700, 70), p=winName)\n    mc.paneLayout()\n    mc.textScrollList(\"line\",\n                      append=[u\"1.选择相机：先选择要测量焦距的相机，再点击按钮(相机名可以手动填入，但相机名为长名，防止错误选择相机)\",\n                              u\"2.创建locator：点击后创建定位器，或手动填入已有的locator(默认创建的1ocator为'find_focous',手动填入不用点击)\",\n                              u\"3.计算焦距按钮：先移动调整好位置的1ocator，点击'移动locator，计算焦距'按钮，即可测出想要的焦距\",\n                              u\"4.帮 助：本工具的使用说明\"])\n    mc.textScrollList(\"line\", edit=True, lf=[(1, \"fixedWidthFont\"), (2, \"fixedWidthFont\"), (3, \"fixedWidthFont\"), (4, \"fixedWidthFont\")])\n    mc.showWindow(helpWin)\n\n\nif __name__ == \"__main__\":\n    win_name = u\"测量相机焦距\"\n    if mc.window(win_name, q=True, ex=True):\n        mc.deleteUI(win_name, window=True)\n    win = mc.window(win_name, title=u\"测量相机焦距\", iconName=u\"Short_Name\", widthHeight=(400, 110))\n    mc.columnLayout(adjustableColumn=True, rs=2)\n    mc.rowColumnLayout(numberOfColumns=3, columnAttach=(1, \"right\", 0), columnWidth=[(1, 60), (2, 240), (3, 100)])\n    mc.text(label=u'相 机 名:', align='left')\n    camName = mc.textField()\n    mc.button(label=u'选择相机', command=\"getCam(camName)\")\n    mc.setParent('..')\n    mc.rowColumnLayout(numberOfColumns=3, columnAttach=(1, 'right', 0), columnWidth=[(1, 60), (2, 240), (3, 100)])\n    mc.text(label=u'locator: ', align='left')\n    locName = mc.textField()\n    mc.button(label=u'创建1ocator', command=\"createLocator(locName,camName)\")\n    mc.setParent('..')\n    mc.button(label=u\"移动locator,计算距离\", command=\"getInstance(instName, camName, 1ocName)\", bgc=(1, 0.73, 0.14))\n    mc.rowColumnLayout(numberOfColumns=4, columnAttach=(1, 'right', 0), columnWidth=[(1, 60), (2, 200), (3, 100), (4, 40)])\n    mc.text(label=u'焦  距:', align='left')\n    instName = mc.textField(ed=False, bgc=(0.64, 0.79, 10.48))\n    mc.text(label=u\" \", align='left')\n    mc.button(label=u'帮助', command=\"toolDoc(win)\")\n    mc.setParent(\"..\")\n    mc.setParent(\"..\")\n    mc.showWindow(win)\n\n\n若要动态获取相机焦距，可将下面的脚本修改后填入相机属性的表达式中。\n\nvector $camP = `getAttr camera1.translate`; //相机坐标\nfloat $camVct[16] = `xform -q -m -ws camera1`; //相机世界空间矩阵\nvector $camVector = &lt;&lt;$camVct [8],$camVct[9],$camVct [10]>>*-1;  //从maya中获取的相机向量，需要取反\nvector $locP = `getAttr find_focous.translate`;\nvector $lcInstance = $locP - $camP;\nfloat $inst = mag($locP - $camP); //物体距离相机的距离\nfloat $_angle = angle($camVector,$lcInstance); //向量间的夹角\nfloat $_focus = cos($_angle)*$inst; //焦距\nfloat $flag = ($_angle*180)/3.141592657;\nif ($flag >= 90)\n&#123;\n    $focus = 0.1;\n&#125;\nprint $_focus;\ncameraShape1.focusDistance = $_focus;\n\n\n\n方法二：添加约束在相机位置创建两个定位器：其中一号定位器p到相机上，使用二号定位器约束一号定位器的Z轴，并设置Z轴数值的最大值（因为方向是反的，所以设置最大值，可以自己尝试一下），将二号定位器移动到物体的位置并添加约束，此时，一号定位器的Z轴数值即是相机焦距，将此属性连接到相机的aifocus属性即可动态获取相机焦距，如下图所示：\n\n\n约束工具如下：\n\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n# @Auth0r: MirrorCG\n# @Time: 2021/12/28\n# =========================================\n\nimport maya.cmds as mc\nimport pymel.core as pm\n\n\nclass getDistance():\n    def __init__(self):\n        win_name = u\"测量相机焦距\"\n        if mc.window(win_name, q=True, ex=True):\n            mc.deleteUI(win_name, window=True)\n        self.win = mc.window(win_name, title=u\"测量相机焦距\", iconName=u'short Name', widthHeight=(400, 120))\n        mc.columnLayout(adjustableColumn=True, rs=2)\n        mc.rowColumnLayout(numberOfColumns=3, columnAttach=(1, 'right', 0), columnWidth=[(1, 60), (2, 240), (3, 100)])\n        mc.text(label=u\"相 机 名:\", align='left')\n        self.camName = mc.textField()\n        mc.button(label=u\"选择相机\", command=lambda x: self.getCam(self.camName))\n        mc.setParent('..')\n        mc.rowColumnLayout(numberOfColumns=3, columnAttach=(1, 'right', 0), columnWidth=[(1, 60), (2, 240), (3, 100)])\n        mc.text(label=u\"locator:\", align='left')\n        self.locName = mc.textField()\n        mc.button(label=u\"创建locator\", command=lambda x: self.createLocators(self.locName))\n        mc.setParent(\"..\")\n        mc.rowColumnLayout(numberOfColumns=3, columnWidth=[(1, 180), (2, 40), (3, 180)])\n        mc.button(label=u\"约束到选择的物体\", command=lambda x: self.addCtrlWithObj(), bgc=(1, 0.73, 0.14))\n        mc.text(label=u' ', align='right')\n        mc.button(label=u\"清除产生的对象\", command=lambda x: self.cleanAll(), bgc=(1, 0.73, 0.14))\n        mc.setParent(\"..\")\n        mc.rowColumnLayout(numberOfColumns=2, columnAttach=(1, 'right', 0), columnWidth=[(1, 360), (2, 40)])\n        mc.text(label=u' ' * 8, align='left')\n        mc.button(label=u\"帮助\", command=lambda x: self.toolDoc())\n        mc.setParent('..')\n        mc.setParent('..')\n        mc.showWindow(self.win)\n\n    def getCam(self, *args):\n        \"\"\"获取选中的相机，填入窗口\"\"\"\n        try:\n            cam = pm.ls(sl=True)[0].getChildren()[0]  # 选择相机\n        except IndexError as e:\n            mc.warning(u\"未选中对象\")\n            return\n        if (not cam) or (cam.nodeType() != \"camera\"):\n            mc.warning(u\"未选中相机\")\n            return\n        _camName = cam.longName()\n        mc.textField(self.camName, e=True, tx=_camName)\n\n    def connectParm(self, loc_a):\n        \"\"\"连接相机属性\"\"\"\n        cam = pm.ls(mc.textField(self.camName, q=True, tx=True))[0]\n        # cam.setAttr(\"aiEnableDOF\",1)\n        node_name = \"distance_data\"\n        if mc.objExists(node_name):\n            mc.delete(node_name)\n        mc.createNode(\"floatMath\", n=node_name)\n        mc.setAttr(node_name + \".operation\", 2)\n        mc.setAttr(node_name + \".floatB\", -1)\n        mc.connectAttr(loc_a.name() + \".translateZ\", node_name + \".floatA\", f=True)\n        mc.connectAttr(node_name + \".outFloat\", cam.name() + \".aiFocusDistance\", f=True)\n\n    def addCtrl(self, loc_m, loc_a):\n        \"\"\"m添加约束和设置可见性\"\"\"\n        cam = mc.textField(self.camName, q=True, tx=True)\n        mc.parent(loc_a.name(), cam)\n        mc.transformLimits(loc_a.name(), tz=(-1, -0.02), etz=(0, 1))\n        mc.setAttr(loc_a.fullPath() + \".visibility\", 0)\n        mc.setAttr(loc_a.fullPath() + \".visibility\", lock=True)\n\n        mc.parentConstraint(loc_m.name(), loc_a.name(), mo=True, st=[\"x\", \"y\"], sr=[\"x\", \"y\", \"z\"])\n\n    def createLocators(self, *args):\n        \"\"\"创建 / 获取1ocator, 移动至相机位置，并将该主1ocator填入窗口中\"\"\"\n        try:\n            cam = pm.ls(mc.textField(self.camName, q=True, tx=True))[0].getParent().fullPath()\n        except IndexError as e:\n            mc.warning(u\"请选择并添加正确的相机\")\n            return\n        cam_p = mc.xform(cam, q=True, ws=True, t=True)  # 相机世界坐标\n        if mc.objExists(\"find_focus\"):  # 用于移动的locator\n            loc_m = pm.ls(\"find_focus\")[0]\n            pm.delete(loc_m)\n        loc_m = pm.createNode(\"locator\").getParent()\n        loc_m.rename(\"find_focus\")\n\n        if mc.objExists(\"cam_center\"):\n            loc_a = pm.ls(\"cam_center\")[0]\n            pm.delete(loc_a)\n        loc_a = pm.createNode(\"locator\").getParent()\n        loc_a.rename(\"cam_center\")\n\n        loc_m.setAttr(\"translate\", cam_p)\n        loc_a.setAttr(\"translate\", cam_p)\n        mc.textField(self.locName, e=True, tx=loc_m.name())\n\n        self.addCtrl(loc_m, loc_a)  # 添加约束和设置可见性\n        self.connectParm(loc_a)\n\n    def addCtrlWithObj(self, *args):\n        \"\"\"约束到物体\"\"\"\n        try:\n            loc_m = pm.ls(mc.textField(self.locName, q=True, tx=True))[0].fullPath()\n        except IndexError as e:\n            mc.warning(u\"未创建或填入定位器\")\n            return\n        obj = \"\"\n        for i in mc.ls(sl=True):\n            if \"find focus\" not in i:\n                obj = i\n                break\n            continue\n        if not obj:\n            mc.warning(u\"未选择约束物体，或约束物体名称中含有'find_focus'字符串\")\n        mc.parentConstraint(obj, loc_m, mo=True, sr=[\"x\", \"y\", \"z\"])\n\n    def cleanAll(self, *arqs):\n        \"\"\"清除本工具产生的所有节点\"\"\"\n        node_list = [\"distance_data\", \"find_focus\", \"cam_center\"]\n        for i in node_list:\n            if mc.objExists(i):\n                mc.delete(i)\n\n    def toolDoc(self):\n        \"\"\"工具帮助\"\"\"\n        win_name = u\"工具帮助\"\n        if mc.window(win_name, q=True, ex=True):\n            mc.deleteUI(win_name, window=True)\n        help_win = mc.window(u\"工具帮助\", t=u\"工具帮助\", wh=(640, 100), p=self.win)\n        mc.paneLayout()\n        mc.textScrollList(\"line\", append=[u\"1.选择相机:先选择要测量焦距的相机，再点击按钮(相机名可以手动填入，但相机名为长名，防止错误选择相机)\",\n                                          u\"2,创建locator:点击后，在相机处创建定位器，创建的1ocator名称为'find focous'\",\n                                          u\"3.约束到选择物体:先调整好locator(find focous)的位置，选择约束物体，点击'约束到选择物体'，即测出想要的焦距，属性将自动连接\",\n                                          u\"4.清除对象，清除本工具产生的相关节点\", u\"5.帮助:本工具的使用说明\"])\n        mc.textScrollList(\"line\", edit=True, lf=[(1, \"fixedWidthFont\"), (2, \"fixedWidthFont\"), (3, \"fixedWidthFont\"),\n                                                 (4, \"fixedWidthFont\"), (5, \"fixedWidthFont\")])\n\n        mc.showWindow(help_win)\n\n\nif __name__ == \"__main__\":\n    tool = getDistance()\n\n\n\n","categories":["Maya","Arnold"],"tags":["灯光","向量计算"]},{"title":"关于Aitoon材质灯光分层的探索","url":"/posts/20220226a1.html","content":"起因前段时间，开始对在 Maya 中进行三渲二的渲染分层有了兴趣。于是，我就尝试自己探索一下：在 Maya 中使用 Aitoon 材质进行三渲二的灯光分层，以及在 Nuke中进行合成的流程。现在的三渲二影视作品普遍采用亮面、暗面加边缘光的方式进行灯光分层，部分镜头需要以亮面、灰面和暗面加边缘光的方式进行灯光分层，灯光师仅完成灯光角度的设计即可，最终画面氛围和效果需要合成师完成，这种分层方式使用aitoon材质球可以很容易地完成。\n\n测试环境:maya 2018.5+Arnold 6.0.1.0测试角色:不要钱的派大星\n一. 材质相关前期部门仅制作卡通材质，不需要在材质球中为rim、highlight 指定灯光。材质球的base 权重需要设定为1（下图1），关闭材质的能量守恒选项和间接反射（下图2），材质的baseTonemap属性都链接ramp节点并保持只有两个点。调节材质、线框效果与贴图的阴影融合等步骤需要前期部门调整到最终效果。如果做了材质阴影融合，材质部门需要提供另一套只带有阴影贴图的 aimatte 材质球用于切换，供灯光部门渲染阴影通道使用。\n\n\n\n\n\n二．灯光环节流程1.灯光使用要求\n\n由于卡通材质的特殊性，灯光渲染需要至少一盏光源即可区分亮暗，根据官方介绍虽然 aitoon 材质并不挑剔灯光类型，但由于面光源和skydome等灯光的性质，可能会导致受光面的强度大于1，从而导致莫名的错误，灯光的要求使用平行光、点光源或者聚光灯，并且这三种光源对于风格化高光的形成效果较好，可控性更高。\n    2.Aov及渲染分层\n通过对aitoon材质的渲染，我们可以获取Arnold提供的所有的Aov通道，但由于aitoon材质球并非基干物理的材质球，并不能按照LPE的方式进行分层，传统的分成方式需要考虑灯光的强度和颜色对贴图的影响以及材质之间的影响，而卡通渲染并不计算diffuse的灯光颜色信息，因此我们可以采用diffusealbedo+主光照射范围+暗部颜色+平面反射+透射的方式进行分层，此方法能保持合成的可调性的同时也最大限度保留了材质的效果。通过读取模型的材质信息，给模型添加附加属性，用aiuserdata节点传递已经记录的每个模型的材质球信息，即可确认模型被灯光照射的亮暗面的范围，最终输出通道，具体方式如下：\n    (1)主光照射范围+暗部颜色\n给每一个材质为aitoon的物体添加Arnold额外属性(color1,color2.pos1,pos2.interpolation)用于记录数据（下图左一），该属性记录材质球的basetonemap中ramp 的信息（下图右一），其中颜色数据使用vector类型 ，位置数据使用float类型，ramp的过度类型使用int类型，这三种类型分别可对应用户数据节点的 aiUserDataColor、aiUserDataFloat、aiUserDatalnt。\n\n\n\n\n以 toon_key 为例创建自定义 aov（下图左一），通过创建自定义的aov，将aov色器选择为新创建的 aitoon 卡通材质球 关闭该aitoon 材质球的能量守恒，边缘，高光。将basecolor调为1，并给basetonemap链接一个默认的ramp节点。创建2个aiUserDataColor2个aiUserDataFloat1个aiUserDatalnt节点，并将color1、color2分别填入aiUserDataColor，pos1、pos2分别填入aiUserDataFloat，interpolation填入aiUserDatalnt，将五个节点链接到上一步的ramp中即可渲染出，所需要的包含有灯光照射的两部范围信息的aov，该aov的色彩信息为仅为灯光照射的亮面（toon_key）(不含材质信息)，以此类推，可获得暗面的颜色（toon_env），渲染出的aov（下图右一）\n\n\n\n\n至此，我们获得需要的灯光层，该灯光层保留材质的 ramp 亮暗面信息和亮暗部区域(非aitoon 材质渲染为黑色。\n    (2) Diffuse abedle、高光和透射\n材质本身的高光和透射可利用maya自身的aov输出，分别为specular direct、specular indirect，transmission direct， transmission indirect。\n    (3) edge\n物体的边缘线输出，需要通过自定义edge aov进行输出，需要将aov的filter设定为 contour类型否则渲染不出线框（如下图）。\n\n\n\n\n    (4) 边缘光和风格化高光\n为了便于调节，aitoon材质的rim边缘光和风格化高光可通过单独分层并对层中的物体进行材质覆盖的方式进行提取aov，单独分层也有利于控制效果。\n    (5) 其他需要的aov\n除上述aov外,其他一些aov可根据需求添加，本文考虑使用的辅助aov包括:N、 fresnel、OCC、RBzd、P、crypto_matte(三种)、direct和indirect 可在含有非aitoon材质时输出，用于调整非aitoon材质物体。\n    (6)文件分层\n文件的分层方式通过maya的renderSetup分层方式进行分层，最后以模板的形式导出渲染层，供流程使用。使用render Setup的方 式分层可以很方便地对模型进行材质覆盖、属性覆盖和导出自定义aov的操作，以边光和风格化层高光为例，为保持物体边缘光的统一性，需要整体赋予一个aitoon材质球，用于调整边缘光效果;而材质球的边缘光和风格化高光属性是没有填入对应灯光的shape名称的，因此可以在覆盖材质或者属性的基础上，统一给相关的模型覆盖属性或材质球，达到渲染效果。\n\n三．合成通过上面的方法，我们可以得到合成所需要的aov，通过合成树即可还原灯光渲染的效果（合成树中的图片不是本例的图片，此处仅做示范），并在此基础上由合成师进行环境氛围和灯光效果的调整即可（如下图）。\n\n\n\n\n\n四．写在最后此方法按照aitoon材质球的非基于物理渲染的特性，以basetonemap的ramp与贴图相乘得出最终颜色信息的特点，进行aov分层;它相对于单纯使用aitoon材质球对物体进行材质覆盖的方式进行亮暗部区分的优点在于，不以单一的材质覆盖的亮暗部过度信息、能更准确地保留材质的亮暗部范围和过度方式、能分别获取到材质的亮暗部rgb信息。相对于传统基于物理的分层方式，能单独调整亮暗面颜色信息，由于三渲二不能在灯光中处理氛围，此方式在合成中可调性更高。\n\n注意：在输出AOV通道时，若自定义的AOV和Arnold渲染器自带的AOV一起渲染出图时，会导致Arnold渲染器自带的Aov渲染错误，不渲染出正确的信息，因此，自定义的AOV需要单独分层渲染。\n","categories":["Maya","Arnold"],"tags":["灯光","Aitoon","aiUserData"]},{"title":"博客文章语法示例","url":"/posts/20220220a1.html","content":"这是文章摘要 ，下面是废话\n文件最上方以 — 分隔的区域称为”Front_matter”\n第一章首行缩进\n内容\n\n这是引用块\nNEW: DevDocs now comes with syntax highlighting. http://devdocs.io\n@DevDocswww.baidu.com\n\n这是文字链接\n下载git\n\n这是代码块\nalert(&#39;Hello World!&#39;);\n\n[rectangle setX: 10 y: 10 width: 20 height: 20];\n\nArray.maparray.map(callback[, thisArg])\n\n_.compactUnderscore.js_.compact([0, 1, false, 2, &#39;&#39;, 3]);\n&#x3D;&gt; [1, 2, 3]\n\n这是反引号代码块 [1, 2, 3] 标题  https://www.baidu.com 百度地址 code snippet array.map(callback[, thisArg])\npull quote\ncontentsssssssss\n\n\n这是jsFiddle(jsFiddle是一个在线的shell编辑器)\n\n\n在文章中插入指定大小的图片\n\nhtml支持的使用表放置图片的方式\n\n\n\n\n\n\n这是视频\n\n这是文本引用\nPost not found: hexo-4-released How to use  tag in title\n\n这是数据引用&lt;% for (var link in site.data.menu) { %&gt;  <a href=\"\"> &lt;%&#x3D; link %&gt; &lt;% } %&gt;\n\n第二章内容\n\n参考文献www.codesheep.cn\n\n\n\n\n\nvar gitalk = new Gitalk({\n    id: '',\n    clientID: '',\n    clientSecret: '',\n    repo: 'gitalk',\n    owner: 'JairusTse',\n    admin: ['JairusTse'],\n    labels: ['Gitalk'],\n    perPage: 50\n})\ngitalk.render('gitalk-container')\n\n","categories":["Doc","学习笔记"],"tags":["Blog","Markdown"]},{"title":"Hexo文档","url":"/posts/20220220a1.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Doc"],"tags":["Blog","Hexo"]}]