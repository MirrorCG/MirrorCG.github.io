[{"title":"Maya创建操纵器","url":"/posts/20221212a1.html","content":"在 maya 中创建操纵器的示例，根据官方文档描述，所有要创建的操纵器，都应该满足以下要求：\n\n\n所有基本操纵器都应该在实例化的 OpenMayaMPx.MPxManipContainer() 容器中生成\n在容器中实现 createChildren(self) 函数功能，使用与容器对应的方法生成指定的操纵器\nconnectToDependNode(self, node) 函数用于链接操纵器到选中的节点的属性接口\n完成 addPlugToManipConversion(theIndex) 和 manipToPlugConversion(index) 并通过其对应的回调函数,分别可以进行节点属性接口控制容器值，以及容器值控制节点属性接口的目的\n\n  以下示例插件完成类似Maya默认快捷键“T”的方向操纵器的功能：\n\n# -*- coding:utf-8 -*-\n# !&#x2F;usr&#x2F;bin&#x2F;env python2\n# Author: Mirror\n# File: MayaPlugins_AimMinapulator.py\n# Time: 2022-12-03 21:43\n# Update： 2022-12-11 22:05\n# Environment:PyCharm\n# Blog: www.mirrorcg.com\n# Description: 旨在给 arnold 面光源添加一个方向操控器，在大纲中不产生节点，可用于任何节点\n# 插件工具架使用示例:\n#         import maya.mel as mm\n#         import maya.cmds as cmds\n#\n#         if not cmds.shelfLayout(&quot;Shelf1&quot;,q&#x3D;1,ex&#x3D;1) :\n#             mainTopShelfTab &#x3D; mm.eval(&#39;global string $gShelfTopLevel;string $a&#x3D;$gShelfTopLevel;&#39;)  # 获取工具架顶级布局\n#             newShelfLayout &#x3D; cmds.shelfLayout(&quot;Shelf1&quot;,p&#x3D;mainTopShelfTab)  # 创建工具架分页\n#         cmds.loadPlugin(&quot;MayaPlugins_AimMinapulator.py&quot;)\n#         if not cmds.aimManipCtxCmd(&quot;aimManipCtxCmd1&quot;, ex&#x3D;1, q&#x3D;1):\n#             cmds.aimManipCtxCmd( &#39;spAimManipContext1&#39; )\n#         cmds.setParent( &#39;AimMinap&#39; )\n#         cmds.toolButton( &#39;aimManip&#39;, cl&#x3D;&#39;toolCluster&#39;, t&#x3D;&#39;spAimManipContext1&#39;, i1&#x3D;&quot;aimManip.xpm&quot; )\n# 这将在工具架的&quot;Shelf1&quot;选项卡中创建一个名为&quot;AimMinap&quot;的新按钮。创建一个arnold 面光源，然后单击工具架上的按钮。选择对象时，将出现Z轴方向操纵器。\n#\n# 插件快捷键使用示例：\n#         在快捷键中设置以下命令,并设置快捷键为 Ctrl+Shift+T(可自行设置):\n#             import maya.mel as mm\n#             import maya.cmds as cmds\n#             pluginNmae &#x3D; &#39;Maya_pythonPlugin.py&#39;\n#             try:\n#                 if not cmds.pluginInfo(pluginNmae,l&#x3D;True,q&#x3D;1):\n#                     cmds.loadPlugin(pluginNmae)\n#             except:\n#                 cmds.warning(u&quot;插件路径中没有名为&#39;%s&#39;的插件&quot; % pluginNmae)\n#                 raise\n#             if not cmds.aimManipCtxCmd(&quot;aimManipCtxCmd1&quot;, ex&#x3D;1, q&#x3D;1):\n#                 cmds.aimManipCtxCmd( &#39;aimManipCtxCmd1&#39; )\n#             mm.eval(&quot;setToolTo aimManipCtxCmd1&quot;)\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport sys\nimport maya.OpenMaya as OpenMaya\nimport maya.OpenMayaUI as OpenMayaUI\nimport maya.OpenMayaMPx as OpenMayaMPx\n\naimManipId &#x3D; OpenMaya.MTypeId(0x8, 133)  # 自定义ID 防止冲突\ncontextCmdName &#x3D; &quot;aimManipCtxCmd&quot;\nnodeName &#x3D; &quot;aimManip&quot;\n\n\nclass AimManip(OpenMayaMPx.MPxManipContainer):\n\n    def __init__(self):\n        OpenMayaMPx.MPxManipContainer.__init__(self)\n        self.fFreePointManip &#x3D; OpenMaya.MDagPath()\n        self.fDirectionManip &#x3D; OpenMaya.MDagPath()\n        self.fScaleManip &#x3D; OpenMaya.MDagPath()\n\n        self.fNodePath &#x3D; OpenMaya.MDagPath()\n        self.initiDirection &#x3D; OpenMaya.MVector()\n        self.startDirection &#x3D; OpenMaya.MVector()  # 记录物体的初始位置\n        self.endDirection &#x3D; OpenMaya.MVector()  # 记录物体移动后的位置\n\n    def createChildren(self):\n        u&quot;&quot;&quot;添加基础操纵器&quot;&quot;&quot;\n        # FreePointTriadManip\n        self.fFreePointManip &#x3D; self.addFreePointTriadManip(&quot;pointManip&quot;, &quot;freePoint&quot;)\n        freePointTriadManipFn &#x3D; OpenMayaUI.MFnFreePointTriadManip(self.fFreePointManip)\n\n        # # ScaleManip\n        # self.fScaleManip &#x3D; self.addScaleManip(&quot;scaleManip&quot;, &quot;scale&quot;)\n        # scaleManipFn &#x3D; OpenMayaUI.MFnScaleManip(self.fScaleManip)\n\n        # DirectionManip\n        self.fDirectionManip &#x3D; self.addDirectionManip(&quot;directionManip&quot;, &quot;direction&quot;)\n        directionManipFn &#x3D; OpenMayaUI.MFnDirectionManip(self.fDirectionManip)\n        directionManipFn.setNormalizeDirection(False)\n\n    def addPlug(self, node):\n        u&quot;&quot;&quot;添加记录属性保存操作历史&quot;&quot;&quot;\n        dagNodeFn &#x3D; OpenMaya.MFnDagNode(node)\n        dagNodeFn.getPath(self.fNodePath)\n        nodeFn &#x3D; OpenMaya.MFnDependencyNode()\n        nodeFn.setObject(node)\n        # 获取选中节点的朝向\n        _Matrix &#x3D; OpenMaya.MTransformationMatrix(self.fNodePath.inclusiveMatrix()).asMatrix()  # .asRotateMatrix()\n        self.initiDirection &#x3D; OpenMaya.MVector(_Matrix(2, 0), _Matrix(2, 1), _Matrix(2, 2))\n        if not nodeFn.hasAttribute(&quot;arrowDirection&quot;):\n            numericFn &#x3D; OpenMaya.MFnNumericAttribute()\n            aArrow2DirectionX &#x3D; numericFn.create(&quot;arrowDirectionX&quot;, &quot;ax&quot;, OpenMaya.MFnNumericData.kDouble,\n                                                 self.initiDirection(0) * -5)\n            aArrow2DirectionY &#x3D; numericFn.create(&quot;arrowDirectionY&quot;, &quot;ay&quot;, OpenMaya.MFnNumericData.kDouble,\n                                                 self.initiDirection(1) * -5)\n            aArrow2DirectionZ &#x3D; numericFn.create(&quot;arrowDirectionZ&quot;, &quot;az&quot;, OpenMaya.MFnNumericData.kDouble,\n                                                 self.initiDirection(2) * -5)\n            aArrow2Direction &#x3D; numericFn.create(&quot;arrowDirection&quot;, &quot;dir&quot;, aArrow2DirectionX, aArrow2DirectionY,\n                                                aArrow2DirectionZ)\n            nodeFn.addAttribute(aArrow2Direction)\n        else:\n            directionX &#x3D; nodeFn.findPlug(&quot;arrowDirectionX&quot;).asFloat()\n            directionY &#x3D; nodeFn.findPlug(&quot;arrowDirectionY&quot;).asFloat()\n            directionZ &#x3D; nodeFn.findPlug(&quot;arrowDirectionZ&quot;).asFloat()\n            length &#x3D; (directionX ** 2 + directionY ** 2 + directionZ ** 2) ** 0.5\n            self.initiDirection &#x3D; self.initiDirection * (-length)\n\n            nodeFn.findPlug(&quot;arrowDirectionX&quot;).setFloat(self.initiDirection(0))\n            nodeFn.findPlug(&quot;arrowDirectionY&quot;).setFloat(self.initiDirection(1))\n            nodeFn.findPlug(&quot;arrowDirectionZ&quot;).setFloat(self.initiDirection(2))\n\n    def connectToDependNode(self, node):\n        u&quot;&quot;&quot;链接操纵器到选中的节点的属性接口&quot;&quot;&quot;\n        # 获取 DAG path\n        dagNodeFn &#x3D; OpenMaya.MFnDagNode(node)\n        dagNodeFn.getPath(self.fNodePath)\n        parentNode &#x3D; dagNodeFn.parent(0)\n        parentNodeFn &#x3D; OpenMaya.MFnDagNode(parentNode)\n\n        nodeFn &#x3D; OpenMaya.MFnDependencyNode()\n        nodeFn.setObject(node)\n        # 链接操纵器到对应的接口\n        # FreePointTriadManip\n        freePointManipFn &#x3D; OpenMayaUI.MFnFreePointTriadManip(self.fFreePointManip)\n        try:\n            tPlug &#x3D; nodeFn.findPlug(&quot;translate&quot;)\n            freePointManipFn.connectToPointPlug(tPlug)\n        except:\n            sys.stdout.write(u&quot;移动操纵器链接 translate 属性失败\\n&quot;)\n\n        # # ScaleManip\n        # scaleManipFn &#x3D; OpenMayaUI.MFnScaleManip(self.fScaleManip)\n        # try:\n        #     scalePlug &#x3D; nodeFn.findPlug(&quot;scale&quot;)\n        #     scaleManipFn.connectToScalePlug(scalePlug)\n        #     scaleManipFn.displayWithNode(node)\n        # except:\n        #     sys.stdout.write(u&quot;缩放操纵器链接 scale 属性失败\\n&quot;)\n\n        # 以下有自定义接口\n        # DirectionManip\n        directionManipFn &#x3D; OpenMayaUI.MFnDirectionManip()\n        directionManipFn.setObject(self.fDirectionManip)\n        self.addPlug(node)\n        self.startLocate &#x3D; self.nodeTranslation()  # 获取位置初值\n        try:\n            sys.stdout.write(u&quot;生成方向操纵器\\n&quot;)\n            directionPlug &#x3D; nodeFn.findPlug(&quot;arrowDirection&quot;)\n            directionManipFn.connectToDirectionPlug(directionPlug)\n            startPointIndex &#x3D; directionManipFn.startPointIndex()\n            self.addPlugToManipConversion(startPointIndex)\n        except:\n            sys.stdout.write(u&quot;方向操作器链接 arrowDirection 属性失败\\n&quot;)\n\n        try:\n            rPlugin &#x3D; nodeFn.findPlug(&quot;rotate&quot;)\n            self.initiDirection &#x3D; OpenMaya.MVector(0, 0, -6)\n            directionManipFn.setDirection(self.initiDirection)  # 每次生成操纵器都需要设置初始方向\n            self.addManipToPlugConversion(rPlugin)\n        except:\n            sys.stdout.write(u&quot;物体旋转方向链接方向操作器 direction 属性失败\\n&quot;)\n\n        OpenMayaMPx.MPxManipContainer.finishAddingManips(self)\n        OpenMayaMPx.MPxManipContainer.connectToDependNode(self, node)\n\n    def draw(self, view, path, style, status):\n        u&quot;&quot;&quot;绘制提示语&quot;&quot;&quot;\n        # todo VP2.0\n        OpenMayaMPx.MPxManipContainer.draw(self, view, path, style, status)\n        view.beginGL()\n        textPos &#x3D; OpenMaya.MPoint(self.nodeTranslation())\n        sys.stdout.write(&quot;draw,1111111111111111111111111111111&quot;)\n        view.drawText(&quot;Swiss Army Manipulator&quot;, textPos, OpenMayaUI.M3dView.kLeft)\n        view.endGL()\n\n    def manipToPlugConversion(self, index):\n        u&quot;&quot;&quot;链接选中容器指定属性到物体接口&quot;&quot;&quot;\n        numData &#x3D; OpenMaya.MFnNumericData()\n        numDataObj &#x3D; numData.create(OpenMaya.MFnNumericData.k3Float)\n        directionManipFn &#x3D; OpenMayaUI.MFnDirectionManip(self.fDirectionManip)\n\n        direction &#x3D; OpenMaya.MVector()\n        self.getConverterManipValue(directionManipFn.directionIndex(), direction)  # 获取容器方向\n        quaternion &#x3D; self.initiDirection.rotateTo(direction)\n        euler &#x3D; OpenMaya.MTransformationMatrix(quaternion.asMatrix()).eulerRotation()  # 通过四元数转旋转角度\n        numData.setData3Float(euler.x, euler.y, euler.z)\n        return OpenMayaUI.MManipData(numDataObj)\n\n    def plugToManipConversion(self, theIndex):\n        u&quot;&quot;&quot;链接选定物体的中心点到操纵器起始点接口&quot;&quot;&quot;\n        if theIndex &#x3D;&#x3D; 8:\n            numData &#x3D; OpenMaya.MFnNumericData()\n            numDataObj &#x3D; numData.create(OpenMaya.MFnNumericData.k3Float)\n            vec &#x3D; self.nodeTranslation()\n            numData.setData3Float(vec.x, vec.y, vec.z)\n            manipData &#x3D; OpenMayaUI.MManipData(numDataObj)\n\n            self.updateArrowDirectionValue(vec)\n            return manipData\n        else:\n            sys.stdout.write(theIndex)\n            sys.stdout.write(&quot;\\n^index error\\n&quot;)\n\n    def nodeTranslation(self):\n        u&quot;&quot;&quot;获取选中对象的中心点&quot;&quot;&quot;\n        dagFn &#x3D; OpenMaya.MFnDagNode(self.fNodePath)\n        path &#x3D; OpenMaya.MDagPath()\n        dagFn.getPath(path)\n        # path.pop()  # pop from the shape to the transform 禁用，报错对象和方法不兼容\n        transformFn &#x3D; OpenMaya.MFnTransform(path)\n        return transformFn.getTranslation(OpenMaya.MSpace.kWorld)\n\n    def updateArrowDirectionValue(self, endLocate):\n        u&quot;&quot;&quot;更新接口值，移动物体位置时更新物体朝向的向量&quot;&quot;&quot;\n        self.endLocate &#x3D; endLocate\n        relativeLocate &#x3D; self.endLocate - self.startLocate\n        self.startLocate &#x3D; self.endLocate\n\n        dagFn &#x3D; OpenMaya.MFnDagNode(self.fNodePath)\n        directionPlugX &#x3D; dagFn.findPlug(&quot;arrowDirectionX&quot;).asFloat()\n        directionPlugY &#x3D; dagFn.findPlug(&quot;arrowDirectionY&quot;).asFloat()\n        directionPlugZ &#x3D; dagFn.findPlug(&quot;arrowDirectionZ&quot;).asFloat()\n        directLocate &#x3D; OpenMaya.MVector(directionPlugX, directionPlugY, directionPlugZ)\n        newLacate &#x3D; directLocate - relativeLocate\n\n        dagFn.findPlug(&quot;arrowDirectionX&quot;).setFloat(newLacate(0))\n        dagFn.findPlug(&quot;arrowDirectionY&quot;).setFloat(newLacate(1))\n        dagFn.findPlug(&quot;arrowDirectionZ&quot;).setFloat(newLacate(2))\n        # sys.stdout.write(&quot;change arrorDirectionZ \\n&quot;)\n        directionManipFn &#x3D; OpenMayaUI.MFnDirectionManip()\n        directionManipFn.setObject(self.fDirectionManip)\n        directionManipFn.setDirection(newLacate)  # 更新方向操纵器的方向，以同步数据\n\n\ndef aimManipCreator():\n    return OpenMayaMPx.asMPxPtr(AimManip())\n\n\ndef aimManipInitialize():\n    OpenMayaMPx.MPxManipContainer.initialize()\n\n\nclass aimManipContext(OpenMayaMPx.MPxSelectionContext):\n    def __init__(self):\n        OpenMayaMPx.MPxSelectionContext.__init__(self)\n        self.updateManipulatorsCallbackID &#x3D; None\n\n    def toolOnSetup(self, event):\n        updateManipulators(self)\n        self.updateManipulatorsCallbackID &#x3D; OpenMaya.MModelMessage.addCallback(\n            OpenMaya.MModelMessage.kActiveListModified, updateManipulators, self)\n\n    def toolOffCleanup(self):\n        self.deleteManipulators()\n        try:\n            if self.updateManipulatorsCallbackID !&#x3D; None:\n                OpenMaya.MModelMessage.removeCallback(self.updateManipulatorsCallbackID)\n        except:\n            sys.stderr.write(u&quot;安装前调用清理失败.\\n&quot;)\n        super(aimManipContext, self).toolOffCleanup()\n\n\ndef updateManipulators(clientData):\n    clientData.deleteManipulators()\n    selectionList &#x3D; OpenMaya.MSelectionList()\n\n    OpenMaya.MGlobal.getActiveSelectionList(selectionList)\n    selectionIter &#x3D; OpenMaya.MItSelectionList(selectionList, OpenMaya.MFn.kInvalid)\n    while not selectionIter.isDone():\n        dependNode &#x3D; OpenMaya.MObject()\n        selectionIter.getDependNode(dependNode)\n        if dependNode.isNull() or not dependNode.hasFn(OpenMaya.MFn.kDependencyNode):\n            print(u&quot;depend node is null&quot;)\n            continue\n\n        dependNodeFn &#x3D; OpenMaya.MFnDependencyNode(dependNode)\n        tPlug &#x3D; dependNodeFn.findPlug(&quot;translate&quot;, False)\n        rPlug &#x3D; dependNodeFn.findPlug(&quot;rotate&quot;, False)\n        sPlug &#x3D; dependNodeFn.findPlug(&quot;scale&quot;, False)\n        if tPlug.isNull() or rPlug.isNull()or sPlug.isNull():\n            print(u&quot;translate and&#x2F;or rotate and&#x2F;or scale plugs are null&quot;)\n            selectionIter.next()\n            continue\n\n        manipObject &#x3D; OpenMaya.MObject()\n        manipulator &#x3D; OpenMayaMPx.MPxManipContainer.newManipulator(nodeName, manipObject)\n        if manipulator is not None:\n            clientData.addManipulator(manipObject)\n            manipulator.connectToDependNode(dependNode)\n        selectionIter.next()\n\n\nclass aimManipCtxCmd(OpenMayaMPx.MPxContextCommand):\n    def __init__(self):\n        OpenMayaMPx.MPxContextCommand.__init__(self)\n\n    def makeObj(self):\n        return OpenMayaMPx.asMPxPtr(aimManipContext())\n\n\ndef contextCmdCreator():\n    return OpenMayaMPx.asMPxPtr(aimManipCtxCmd())\n\n\n# 注册插件\ndef initializePlugin(mobject):\n    mplugin &#x3D; OpenMayaMPx.MFnPlugin(mobject, &quot;www.mirrorcg.com&quot;, &quot;1.0.0&quot;, &quot;Any&quot;)\n    try:\n        mplugin.registerContextCommand(contextCmdName, contextCmdCreator)\n    except:\n        print(u&quot;该上下文命令注册失败: %s&quot; % contextCmdName)\n        raise\n    try:\n        mplugin.registerNode(nodeName, aimManipId, aimManipCreator, aimManipInitialize,\n                             OpenMayaMPx.MPxNode.kManipContainer)\n    except:\n        print(u&quot;该节点注册失败: %s&quot; % nodeName)\n        raise\n\n\n# 取消注册插件\ndef uninitializePlugin(mobject):\n    mplugin &#x3D; OpenMayaMPx.MFnPlugin(mobject)\n    try:\n        mplugin.deregisterContextCommand(contextCmdName)\n    except:\n        print(u&quot;该上下文命令取消注册失败: %s&quot; % contextCmdName)\n        raise\n    try:\n        mplugin.deregisterNode(aimManipId)\n    except:\n        print(u&quot;该节点取消注册失败: %s&quot; % nodeName)\n        raise\n","categories":["Maya","小工具"],"tags":["MayaAPI","MayaPlugin","向量计算"]},{"title":"QT-ListViewLayout","url":"/posts/20221211a1.html","content":"本文为记录摘抄自 ZooTool 工具集中的 ListViewLayout ,该布局可以根据父 UI 组件窗口的宽度，调整每一行所能容纳的最大的元素个数。类似flowLayout,但比flowLayout省资源。\n\n示例代码如下：\n# -*- coding:utf-8 -*-\n# !&#x2F;usr&#x2F;bin&#x2F;env python3\n# Author: Mirror\n# File: flowLayout\n# Time: 2022-12-10 21:43\n# Update： 2022-12-12 22:43\n# Environment:PyCharm\n# Blog: www.mirrorcg.com\n# Description: listViewLayout布局示例\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport os\nimport glob\nimport tempfile\nimport copy\nimport json\nimport zipfile\nimport imghdr\nimport sys\nfrom functools import partial\nfrom PySide2.QtGui import *\nfrom PySide2.QtCore import *\nfrom PySide2.QtWidgets import *\n\nif sys.version_info[0] &#x3D;&#x3D; 3:\n    string_types &#x3D; str\nelse:\n    string_types &#x3D; bytes\n\n\nINFOASSET &#x3D; &quot;assetType&quot;  # key for the .zooinfo dict and file (as json)\nINFOCREATORS &#x3D; &quot;creators&quot;  # key for the .zooinfo dict and file (as json)\nINFOWEBSITES &#x3D; &quot;websites&quot;  # key for the .zooinfo dict and file (as json)\nINFOTAGS &#x3D; &quot;tags&quot;  # key for the .zooinfo dict and file (as json)\nINFODESCRIPTION &#x3D; &quot;description&quot;  # key for the .zooinfo dict and file (as json)\nINFOSAVE &#x3D; &quot;saved&quot;  # key for the .zooinfo dict and file (as json)\nINFOANIM &#x3D; &quot;animation&quot;  # key for the .zooinfo dict and file (as json)\nVERSIONKEY &#x3D; &quot;version&quot;\nGENERICVERSIONNO &#x3D; &quot;1.0.0&quot;  # the version number of the generic file format\nASSETTYPES &#x3D; [&quot;Not Specified&quot;, &quot;Hero Model&quot;, &quot;Prop Model&quot;, &quot;Background&quot;, &quot;Background Lights&quot;, &quot;Scene&quot;, &quot;IBL&quot;, &quot;Lights&quot;,\n              &quot;Shaders&quot;, &quot;Animation&quot;, &quot;Camera&quot;]\nZOOINFOSUFFIX &#x3D; &quot;zooInfo&quot;  # TODO use new constant in zoosceneconstants\nQTSUPPORTEDIMAGES &#x3D; (&#39;bmp&#39;, &#39;gif&#39;, &#39;jpg&#39;, &#39;jpeg&#39;, &#39;mng&#39;, &#39;png&#39;, &#39;pbm&#39;, &#39;pgm&#39;, &#39;ppm&#39;, &#39;tiff&#39;, &#39;xbm&#39;, &#39;xpm&#39;, &#39;svg&#39;, &#39;tga&#39;)\nDEPENDENCY_FOLDER &#x3D; &quot;fileDependencies&quot;  # the prefix of the dependency folder for file dependencies.\nZOO_THUMBNAIL &#x3D; &quot;thumbnail&quot;  # the name of thumbnail images minus the file extension which can be png or jpg etc\nZOOSCENE_EXT &#x3D; &quot;zooScene&quot;  # main suffix for zooScene files\nPREFERENCE_FOLDER &#x3D; &quot;preferences&quot;\nINTERFACE_FOLDER &#x3D; &quot;interface&quot;\npreference &#x3D; None\nDIRECTORYNAMEDEPENDENCIES &#x3D; &quot;fileDependencies&quot;\n\n\ndef dpiScale(value):\n    &quot;&quot;&quot;根据当前 DPI 按值调整大小\n    :param value: 默认2K int型\n    :return value: 当前显示器的的大小 int型\n    &quot;&quot;&quot;\n    DEFAULT_DPI &#x3D; 96\n    mult &#x3D; max(1, float(QApplication.desktop().logicalDpiY()) &#x2F; float(DEFAULT_DPI))\n    return value * mult\n\n\ndef getTempDir():\n    &quot;&quot;&quot;返回所有操作系统上的临时目录路径&quot;&quot;&quot;\n    return os.environ.get(&#39;TEMP&#39;, os.environ.get(&#39;TMP&#39;, os.environ.get(&#39;TMPDIR&#39;, &#39;&#x2F;tmp&#39;)))\n\n\ndef getFilesNoExt(directory, fileNoExtension):\n    &quot;&quot;&quot;给定一个没有扩展名的文件，找到文件名，对于查找扩展名未知的缩略图很有用，即可能是.jpg或.png\n    :param directory: 用于搜索和返回文件名的目录 str\n    :param fileNoExtension: 要查找的文件的名称 str\n    :return fileList: 与名称匹配的文件列表，可以是空的或多个 list(str)\n    &quot;&quot;&quot;\n    fileList &#x3D; list()\n    os.chdir(directory)\n    for fileName in glob.glob(&quot;&#123;&#125;.*&quot;.format(fileNoExtension)):\n        fileList.append(fileName)\n    # TODO: Probably shouldn&#39;t be using glob, return the current path to the directory\n    tempDir &#x3D; getTempDir()\n    os.chdir(tempDir)\n    return fileList\n\n\ndef getImageNoExtension(directory, nameNoExtension):\n    &quot;&quot;&quot;返回目录中具有名称（不带文件扩展名）的图像列表，有助于查找“缩略图.png或缩略图.jpg”，返回找到的文件的列表\n    :param directory: 用于搜索和返回文件名的目录 str\n    :param nameNoExtension: 没有扩展名的文件名 str\n    :return imagePathList: 与名称NoExtension匹配的图像列表 list\n    &quot;&quot;&quot;\n    imagePathList &#x3D; list()\n    fileList &#x3D; getFilesNoExt(directory, nameNoExtension)\n    if not fileList:\n        return\n    for file in fileList:\n        filename, file_extension &#x3D; os.path.splitext(file)\n        file_extension &#x3D; file_extension.replace(&quot;.&quot;, &quot;&quot;)\n        if file_extension in QTSUPPORTEDIMAGES:\n            imagePathList.append(file)\n    return imagePathList\n\n\ndef thumbnails(directory, fileListNoExt):\n    &quot;&quot;&quot;从不带扩展名的 zooScene 列表中返回缩略图路径的列表\n    :return thumbPathList: 每个 zooScene 文件一个缩略图路径列表（无扩展名）\n    :rtype thumbFullPathList: 基础字符串列表\n    &quot;&quot;&quot;\n    thumbFullPathList &#x3D; list()\n    for i, zooSceneName in enumerate(fileListNoExt):\n        dependFolder &#x3D; &quot;_&quot;.join([zooSceneName, DEPENDENCY_FOLDER])\n        dependFolderPath &#x3D; os.path.join(directory, dependFolder)\n        if not os.path.isdir(dependFolderPath):\n            thumbFullPathList.append(None)\n            continue\n        imageList &#x3D; getImageNoExtension(dependFolderPath, ZOO_THUMBNAIL)\n        if imageList:  # image list is only thumbnail, take the first image, could be jpg or png\n            thumbFullPathList.append(os.path.join(dependFolderPath, imageList[0]))\n            continue\n        thumbFullPathList.append(None)\n    return thumbFullPathList\n\n\ndef filesByExtension(directory, extensionList):\n    &quot;&quot;&quot;列出给定文件扩展名列表的给定目录中的所有文件，扩展名应该没有句号，即 [“zooScene”， “json”， “jpg”]\n    Return Example:\n        [&quot;soft_sunsetSides.zooScene&quot;, &quot;sun_redHarsh.zooScene&quot;, &quot;sun_warmGlow.zooScene&quot;]\n    :param directory: 用于搜索和返回文件名的目录 str\n    :param extensionList: A list of extensions to search [&quot;zooScene&quot;, &quot;json&quot;, &quot;jpg&quot;]\n    :type extensionList: list of basestring\n    :return fileList: A list of files returned that are in the directory and match the extension list\n    :rtype fileList: list()str\n    &quot;&quot;&quot;\n    fileList &#x3D; list()\n    if not os.path.isdir(directory):  # check if directory actually exists\n        return fileList  # emptyList and directory\n\n    for ext in extensionList:\n        for filePath in glob.glob(os.path.join(directory, &quot;*.&#123;&#125;&quot;.format(ext))):\n            fileList.append(os.path.basename(filePath))\n    # TODO: Probably shouldn&#39;t be using glob, return the current path to the directory\n    tempDir &#x3D; getTempDir()\n    os.chdir(tempDir)\n    return fileList\n\n\ndef saveJson(data, filepath, **kws):\n    &quot;&quot;&quot;此过程将给定数据保存到 json 文件\n    :param kws: Json Dumps arguments , see standard python docs\n    &quot;&quot;&quot;\n    try:\n        with open(filepath, &#39;w&#39;) as f:\n            json.dump(data, f, **kws)\n    except IOError:\n        print(&quot;Data not saved to file &#123;&#125;&quot;.format(filepath))\n        return False\n\n    print(&quot;-------&gt;&gt; file correctly saved to : &#123;0&#125;&quot;.format(filepath))\n    return True\n\n\ndef ensureFolderExists(path, permissions&#x3D;0o775, placeHolder&#x3D;False):\n    &quot;&quot;&quot;如果该文件夹不存在，则将创建一个。由于版本控制错误而构建的函数与未提交的空文件夹，此文件夹可以生成占位符文件。\n    :param path: the folderpath to check or create\n    :type path: str\n    :param permissions: folder permissions mode\n    :type permissions: int\n    :param placeHolder: if True create a placeholder text file\n    :type placeHolder: bool\n    :raise OSError: raise OSError if the creation of the folder fails\n    &quot;&quot;&quot;\n    if not os.path.exists(path):\n        try:\n            print(&quot;Creating folder &#123;&#125; [&#123;&#125;]&quot;.format(path, permissions))\n            os.makedirs(path, permissions)\n            if placeHolder:\n                placePath &#x3D; os.path.join(path, &quot;placeholder&quot;)\n                if not os.path.exists(placePath):\n                    with open(placePath, &quot;wt&quot;) as fh:\n                        fh.write(&quot;Automatically Generated placeHolder file.&quot;)\n                        fh.write(&quot;The reason why this file exists is due to source control system&#39;s which do not &quot;\n                                 &quot;handle empty folders.&quot;)\n        except OSError as e:\n            # more less work if network race conditions(joy!)\n            raise\n\n\ndef loadJson(filePath):\n    &quot;&quot;&quot;\n    此过程加载并返回 json 文件的数据\n    :return type&#123;dict&#125;: the content of the file\n    &quot;&quot;&quot;\n    # load our file\n    try:\n        with loadFile(filePath) as f:\n            data &#x3D; json.load(f)\n    except Exception as er:\n        print(&quot;file (&#123;&#125;) not loaded&quot;.format(filePath))\n        raise er\n    # return the files data\n    return data\n\n\ndef getFileDependenciesList(zooSceneFullPath, ignoreThumbnail&#x3D;False):\n    &quot;&quot;&quot;检索依赖目录 目录名依赖项中所有文件的列表,文件没有完整路径，因此也会返回目录路径，文件是 [“文件名.abc”， “文件名.zooInfo”] 等\n    :param zooSceneFullPath: the full path to the file usually .zooscene but can be any extension\n    :type zooSceneFullPath: str\n    :param ignoreThumbnail: ignores the files called thumbnail.* useful for renaming\n    :type ignoreThumbnail: str\n    :return fileDependencyList: list of short name files found in the subdirectory DIRECTORYNAMEDEPENDENCIES\n    :rtype fileDependencyList: list\n    :return fullDirPath: the full path of the sub directory DIRECTORYNAMEDEPENDENCIES\n    :rtype fullDirPath: str\n    &quot;&quot;&quot;\n    fileDependencyList &#x3D; list()\n    zooSceneFileName &#x3D; os.path.basename(zooSceneFullPath)\n    directoryPath &#x3D; os.path.dirname(zooSceneFullPath)\n    fileNameNoExt &#x3D; os.path.splitext(zooSceneFileName)[0]\n    newDirectoryName &#x3D; &quot;_&quot;.join([fileNameNoExt, DIRECTORYNAMEDEPENDENCIES])\n    fullDirPath &#x3D; os.path.join(directoryPath, newDirectoryName)\n    if not os.path.exists(fullDirPath):  # doesn&#39;t already exist\n        return fileDependencyList, &quot;&quot;  # return empty as directory doesn&#39;t exist\n    os.chdir(fullDirPath)\n    for fileName in glob.glob(&quot;&#123;&#125;.*&quot;.format(fileNameNoExt)):\n        fileDependencyList.append(fileName)\n    if not ignoreThumbnail:\n        for fileName in glob.glob(&quot;thumbnail.*&quot;.format(fileNameNoExt)):\n            fileDependencyList.append(fileName)\n    #  return os.chdir to the temp dir as it gets in the way with file permissions for later renames!\n    os.chdir(tempfile.gettempdir())\n    return fileDependencyList, fullDirPath\n\n\ndef getSingleFileFromZooScene(zooSceneFullPath, fileExtension):\n    &quot;&quot;&quot;返回文件的名称（如果存在），扩展名为 zooSceneFullPath 中的 .abc\n    获取与 .zooScene 文件关联的子目录中的所有文件，并筛选文件类型,支持返回一个文件，第一个文件它发现不适合纹理\n    :param zooSceneFullPath:  the full path of the .zooScene file to be saved\n    :type zooSceneFullPath: str\n    :param fileExtension:  the file extension to find no &quot;.&quot;, so alembic is &quot;abc&quot;\n    :type fileExtension: str\n    :return extFileName: the filename (no directory) of the extension given &gt; for example &quot;myFileName.abc&quot;\n    :rtype extFileName: str\n    &quot;&quot;&quot;\n    extFileName &#x3D; &quot;&quot;\n    fileList, directory &#x3D; getFileDependenciesList(zooSceneFullPath)\n    if not directory:\n        return extFileName\n    for fileName in fileList:  # cycle through the files and find if a match with the extension\n        if fileName.endswith(fileExtension):\n            return os.path.join(directory, fileName)\n    return extFileName\n\n\ndef loadFile(filepath):\n    if filepath.endswith(&quot;.zip&quot;):\n        with zipfile.ZipFile(filepath, &#39;r&#39;) as f:\n            yield f\n        return\n    elif &quot;.zip&quot; in filepath:\n        # load from zipfile\n        zippath, relativefilePath &#x3D; filepath.split(&quot;.zip&quot;)\n        zipPath &#x3D; zippath + &quot;.zip&quot;\n\n        with zipfile.ZipFile(zipPath, &#39;r&#39;) as zip:\n            path &#x3D; relativefilePath.replace(&quot;\\\\&quot;, &quot;&#x2F;&quot;).lstrip(&quot;&#x2F;&quot;)\n            for i in iter(zip.namelist()):\n                if path &#x3D;&#x3D; i:\n                    yield zip.open(i)\n                    break\n\n        return\n    with open(filepath) as f:\n        yield f\n\n\ndef createTagInfoDict(assetType, creator, website, tags, description, saveInfo, animInfo):\n    &quot;&quot;&quot;为zooInfo 文件创建一个字典\n    :param assetType: the information about asset type, model, scene, lights, shaders, etc\n    :type assetType: str\n    :param creator: the information about creator&#x2F;s\n    :type creator: str\n    :param website: the information about the creators website links\n    :type website: str\n    :param tags: the tag information\n    :type tags: str\n    :param description: the full description\n    :type description: str\n    :param saveInfo: the file information saved as a list [&quot;alembic&quot;, &quot;generic lights&quot;] etc\n    :type saveInfo: list\n    :param animInfo: the animation information of the file &quot;0 100&quot; or &quot;&quot; or None if none\n    :type animInfo: str\n    :return zooInfoDict: the dict containing all information including the file version number\n    :rtype zooInfoDict: str\n    &quot;&quot;&quot;\n    zooInfoDict &#x3D; &#123;INFOASSET: assetType,\n                   INFOCREATORS: creator,\n                   INFOWEBSITES: website,\n                   INFOTAGS: tags,\n                   INFODESCRIPTION: description,\n                   INFOSAVE: saveInfo,\n                   INFOANIM: animInfo,\n                   VERSIONKEY: GENERICVERSIONNO&#125;\n    return zooInfoDict\n\n\ndef getZooInfoFromFile(zooSceneFullPath, message&#x3D;True):\n    &quot;&quot;&quot;从 .zooScene 获取其他文件，例如从磁盘上的文件中获取 .zooInfo\n    :param zooSceneFullPath: the full path of the zooScene file, this will save out as another file zooInfo\n    :type zooSceneFullPath: str\n    :return zooInfoDict: the dictionary with all info information, if None the file wasn&#39;t found\n    :rtype zooInfoDict: dict\n    :return fileFound: was the zooInfo file found?\n    :rtype fileFound: bool\n    &quot;&quot;&quot;\n    zooInfoFileFullPath &#x3D; getSingleFileFromZooScene(zooSceneFullPath, ZOOINFOSUFFIX)\n    if not os.path.exists(zooInfoFileFullPath):  # doesn&#39;t exist\n        if message:\n            om2.MGlobal.displayWarning(&quot;ZooInfo File Not Found&quot;)\n        fileFound &#x3D; False\n        return createTagInfoDict(ASSETTYPES[0], &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;), fileFound  # return the empty dict as no file found\n    fileFound &#x3D; True\n    return loadJson(zooInfoFileFullPath), fileFound  # returns zooInfoDict\n\n\ndef createEmptyInfoDict():\n    &quot;&quot;&quot;创建一个空的 .zooInfo 字典&quot;&quot;&quot;\n    infoDict &#x3D; &#123;u&quot;assetType&quot;: u&quot;&quot;,\n                u&quot;animation&quot;: None,\n                u&quot;description&quot;: u&quot;&quot;,\n                u&quot;version&quot;: u&quot;1.0.0&quot;,\n                u&quot;tags&quot;: u&quot;&quot;,\n                u&quot;creators&quot;: u&quot;&quot;,\n                u&quot;saved&quot;: str(list()),\n                u&quot;websites&quot;: u&quot;&quot;\n                &#125;\n    return infoDict\n\n\ndef infoDictionaries(zooSceneNameList, directory):\n    &quot;&quot;&quot; 返回每个 .zooScene 文件的信息字典列表。这些词典包含作者、标签、描述等信息\n    :return infoDictList: 每个 .zooScene 文件的信息字典列表\n    :rtype infoDictList: list of dict\n    &quot;&quot;&quot;\n    infoDictList &#x3D; list()\n    if not zooSceneNameList:\n        return dict()\n    for zooSceneFile in zooSceneNameList:\n        lightPresetFullPath &#x3D; os.path.join(directory, zooSceneFile)\n        zooInfoDict, fileFound &#x3D; getZooInfoFromFile(lightPresetFullPath, message&#x3D;False)\n        if fileFound:\n            infoDictList.append(zooInfoDict)\n        else:\n            infoDictList.append(createEmptyInfoDict())\n    return infoDictList\n\n\ndef isImage(path):\n    try:\n        return imghdr.what(path) is not None or path.split(os.extsep)[-1] in QTSUPPORTEDIMAGES\n    except IOError:\n        return False\n\n\nclass ThumbnailDelegate(QStyledItemDelegate):\n    def __init__(self, parent):\n        super(ThumbnailDelegate, self).__init__(parent)\n\n    def sizeHint(self, option, index):\n        return index.model().itemFromIndex(index).sizeHint()\n\n    def paint(self, painter, options, index):\n        index.model().itemFromIndex(index).paint(painter, options, index)\n\n\nclass ThumbListView(QListView):\n    contextMenuRequested &#x3D; Signal(list, object)\n    requestZoom &#x3D; Signal(object, float)\n    # QModelIndex, Treeitem\n    requestDoubleClick &#x3D; Signal(object, object)\n    zoomAmount &#x3D; 1\n    defaultMinIconSize &#x3D; 20\n    defaultMaxIconSize &#x3D; 512\n    defaultIconSize &#x3D; QSize(256, 256)\n    stateChanged &#x3D; Signal()\n\n    WheelEvent &#x3D; 1\n    EnterEvent &#x3D; 2\n    CalcInitialEvent &#x3D; 3\n    CalcEvent &#x3D; 4\n    VerticalSliderReleasedEvent &#x3D; 5\n\n    def __init__(self, parent&#x3D;None, delegate&#x3D;None, iconSize&#x3D;defaultIconSize, uniformItems&#x3D;False):\n\n        super(ThumbListView, self).__init__(parent&#x3D;parent)\n        self.setContextMenuPolicy(Qt.CustomContextMenu)\n        self.customContextMenuRequested.connect(self._contextMenu)\n        self.autoScale &#x3D; True\n        self.defaultSize &#x3D; None\n        self.initialIconSize &#x3D; None\n        self.columnQueue &#x3D; 0\n        self.columnOffset &#x3D; 1\n\n        self.zoomable &#x3D; True\n        self._iconSize &#x3D; QSize()\n        self.setIconSize(iconSize or self.defaultIconSize)\n        self.initUi()\n\n        self.maxColumns &#x3D; 8\n        self.setVerticalScrollBar(QScrollBar(self))\n        self.connections()\n\n        self._delegate &#x3D; delegate(self) if delegate is not None else ThumbnailDelegate(self)\n        self.setItemDelegate(self._delegate)\n        self.setUpdatesEnabled(True)\n        self._uniformItemSizes &#x3D; uniformItems\n        self.setUniformItemSizes(uniformItems)\n\n    def initUi(self):\n        self.setMouseTracking(True)\n        self.setSelectionRectVisible(True)\n        self.setViewMode(QListView.IconMode)\n        self.setResizeMode(QListView.Adjust)\n        self.setSelectionMode(QListView.SingleSelection)\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n\n        self.setDragEnabled(False)\n        self.setAcceptDrops(False)\n\n    def _contextMenu(self, position):\n        model &#x3D; self.model()\n        if model is None:\n            return\n        menu &#x3D; QMenu(self)\n        selectionModel &#x3D; self.selectionModel()\n        selection &#x3D; [model.itemFromIndex(index) for index in selectionModel.selectedIndexes()]\n        self.contextMenuRequested.emit(selection, menu)\n        menu.exec_(self.viewport().mapToGlobal(position))\n\n    def setUniformItemSizes(self, enable):\n        self._uniformItemSizes &#x3D; enable\n        if self.model():\n            self.model().setUniformItemSizes(enable)\n\n    def setIconSize(self, size):\n        self._iconSize &#x3D; size\n        super(ThumbListView, self).setIconSize(size)\n\n    def connections(self):\n        self.verticalScrollBar().sliderMoved.connect(self.verticalSliderMoved)\n        self.verticalScrollBar().sliderReleased.connect(self.verticalSliderReleased)\n        self.clicked.connect(lambda: self.stateChanged.emit())\n        self.activated.connect(lambda: self.stateChanged.emit())\n        # self.entered.connect(lambda: self.stateChanged.emit())\n\n    def wheelEvent(self, event):\n        &quot;&quot;&quot; 重写以处理缩放 listview.\n        :type event: :class:&#96;QEvent&#96;\n        &quot;&quot;&quot;\n        modifiers &#x3D; event.modifiers()\n        if self.zoomable and modifiers &#x3D;&#x3D; Qt.ControlModifier:\n            if event.delta() &gt; 0:\n                self.columnOffset -&#x3D; 1\n            else:\n                self.columnOffset +&#x3D; 1\n                self.columnOffset &#x3D; min(self.columnOffset, self.maxColumns)\n\n            size &#x3D; self.widgetSize()\n            index &#x3D; self.indexAt(event.pos())\n\n            # if its an invalid index, find closest instead\n            if not index.isValid():\n                index &#x3D; self.closestIndex(event.pos())\n\n            self.calcResize(size)\n            QTimer.singleShot(0, lambda: self.scrollTo(index))\n            event.accept()\n            self.stateChanged.emit()\n            return\n        super(ThumbListView, self).wheelEvent(event)\n        self.loadVisibleIcons()\n        self.stateChanged.emit()\n\n    def state(self):\n        &quot;&quot;&quot; Returns useful settings to copy from one list view behaviour to another\n\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        selectedIndex &#x3D; self.selectionModel().currentIndex().row()\n        ret &#x3D; &#123;&quot;sliderPos&quot;: self.verticalScrollBar().value(),\n               &quot;sliderMin&quot;: self.verticalScrollBar().minimum(),\n               &quot;sliderMax&quot;: self.verticalScrollBar().maximum(),\n               &quot;selected&quot;: selectedIndex,\n               &quot;columns&quot;: self.columnOffset,\n               &quot;zoomAmount&quot;: self.zoomAmount,\n               &quot;iconSize&quot;: self._iconSize,\n               &quot;initialIconSize&quot;: self.initialIconSize,\n               &quot;defaultSize&quot;: self.defaultSize,\n               &quot;fixedSize&quot;: self.parentWidget().minimumSize()\n               &#125;\n\n        return ret\n\n    def setState(self, state):\n        &quot;&quot;&quot; Set the state of the listview with the new settings provided from ThumbListView.state()\n\n        :param state:\n        :type state:\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        self.columnOffset &#x3D; state[&#39;columns&#39;]\n        self._iconSize &#x3D; state[&#39;iconSize&#39;]\n        self.zoomAmount &#x3D; state[&#39;zoomAmount&#39;]\n        self.defaultSize &#x3D; state[&#39;defaultSize&#39;]\n        self.initialIconSize &#x3D; state[&#39;initialIconSize&#39;]\n\n        fixedSize &#x3D; state[&#39;fixedSize&#39;]\n\n        if fixedSize.width() !&#x3D; 0:\n            self.parentWidget().setFixedWidth(fixedSize.width())\n        if fixedSize.height() !&#x3D; 0:\n            self.parentWidget().setFixedHeight(fixedSize.height())\n\n        self.calcResize(self.widgetSize())\n        self.verticalScrollBar().setMinimum(state[&#39;sliderMin&#39;])\n        self.verticalScrollBar().setMaximum(state[&#39;sliderMax&#39;])\n        self.verticalScrollBar().setValue(state[&#39;sliderPos&#39;])\n\n        self.loadVisibleIcons()\n\n        if state[&#39;selected&#39;] !&#x3D; -1:\n            QTimer.singleShot(0, lambda: self.delaySelect(state[&#39;selected&#39;]))\n\n    def delaySelect(self, sel):\n        &quot;&quot;&quot; Select index\n        :param sel:\n        :type sel:\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        autoScroll &#x3D; self.hasAutoScroll()\n        self.setAutoScroll(False)\n        self.selectionModel().setCurrentIndex(self.model().index(sel, 0),\n                                              QItemSelectionModel.ClearAndSelect)\n        self.setAutoScroll(autoScroll)\n\n    def closestIndex(self, pos):\n        &quot;&quot;&quot; Get closest index based on pos\n        :param pos:\n        :type pos:\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        maxDist &#x3D; -1\n        closest &#x3D; None\n        for index in self.visibleItems():\n            c &#x3D; self.visualRect(index)\n            if c.top() &lt;&#x3D; pos.y() &lt;&#x3D; c.bottom():  # Only choose the ones from the same row\n                dist &#x3D; pos.x() - c.center().x()\n                if maxDist &#x3D;&#x3D; -1 or dist &lt; maxDist:\n                    closest &#x3D; index\n                    maxDist &#x3D; dist\n        return closest\n\n    def loadVisibleIcons(self):\n        &quot;&quot;&quot; Loads visible icons in the view if they have not been loaded yet\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n\n        for index in self.visibleItems(pre&#x3D;5, post&#x3D;5):\n            try:\n                treeItem &#x3D; self.model().items[index.row()]\n                item &#x3D; treeItem.item()\n                if not item.iconLoaded():\n                    self.model().threadPool.start(item.iconThread)\n\n            except IndexError:\n                pass  # this should possibly be handled\n\n    def filter(self, text, tag&#x3D;None):\n        filterList &#x3D; self.model().filterList(text, tag)\n        self.loadVisibleIcons()\n\n    def verticalSliderReleased(self):\n        self.stateChanged.emit()\n\n    def verticalSliderMoved(self, pos):\n        &quot;&quot;&quot; On vertical slider moved, reload the visible icons\n\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        self.loadVisibleIcons()\n\n    def model(self):\n        &quot;&quot;&quot; 获取 ListView model\n        :return:\n        :rtype: FileViewModel\n        &quot;&quot;&quot;\n        return super(ThumbListView, self).model()\n\n    def visibleItems(self, pre&#x3D;0, post&#x3D;0):\n        &quot;&quot;&quot; 获取可见项。如果要在开头和结尾添加额外的索引，请将 extra 设置为 1 或更多。它只会返回有效索引。\n        :param pre: Add extra items behind the currently visible items\n        :type pre: int\n        :param post: Add extra items after the currently visible items\n        :type post: int\n        :return: List of indices that are visible plus the pre and post. It only returns valid indices\n        :rtype: list of QModelIndex\n        &quot;&quot;&quot;\n        firstIndex &#x3D; self.indexAt(QPoint(0, 0))\n        viewportRect &#x3D; self.viewport().rect()\n        items &#x3D; list()\n        after &#x3D; post\n\n        i &#x3D; -pre  # We want to check indices behind the firstIndex\n        while True:\n            sibling &#x3D; firstIndex.sibling(firstIndex.row() + i, 0)\n            # The index is visually shown in the viewport?\n            if sibling.isValid() and viewportRect.intersects(self.visualRect(sibling)):\n                items.append(sibling)\n            elif sibling.isValid() and i &lt; 0:  # If it&#39;s indices behind the firstIndex\n                items.append(sibling)\n            elif sibling.isValid() and after &gt; 0:  # We want some extra indices at the end so keep going\n                after -&#x3D; 1\n                items.append(sibling)\n            elif i &lt; 0 or self.isIndexHidden(sibling):  # We want to keep going even if the behind siblings are invalid,\n                # Or hidden by search\n                i +&#x3D; 1\n                continue\n\n            else:\n                break  # Either it is invalid (reached the end) or we&#39;ve gone outside the screen\n            i +&#x3D; 1\n\n        return items\n\n    def scrollTo(self, index, hint&#x3D;None):\n        &quot;&quot;&quot; 覆盖默认的scrollTo并使用我们自己的\n        :param index:\n        :type index:\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        if hint is None:\n            itemRect &#x3D; self.rectForIndex(index)\n            vbar &#x3D; self.verticalScrollBar()\n            mPos &#x3D; self.mapFromGlobal(QCursor().pos())  # Pos of mouse in listview widget\n            newPos &#x3D; (float(itemRect.y()) &#x2F; float(self.contentsSize().height())) * \\\n                     (float(self.contentsSize().height())) - \\\n                     mPos.y() + \\\n                     (itemRect.height() * 0.5)  # maybe better if this is the mousePosition relative to the item instead\n            vbar.setValue(newPos)\n        else:\n            super(ThumbListView, self).scrollTo(index, hint)\n\n        self.loadVisibleIcons()\n\n    def widgetSize(self):\n        &quot;&quot;&quot; 不带垂直滚动条的大小\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        size &#x3D; QSize(self.size())\n        size -&#x3D; QSize(self.verticalScrollBar().size().width(), 0)\n        return size\n\n    def _calculateZoom(self, delta):\n        &quot;&quot;&quot; 在通过 &#39;setZoomAmount&#39; 将其应用于图标之前计算缩放系数\n        :param delta: the delta value\n        :type delta: float\n        :return: the converted delta to zoom factor\n        :rtype: float\n        &quot;&quot;&quot;\n        inFactor &#x3D; 1.15\n        outFactor &#x3D; 1 &#x2F; inFactor\n\n        if delta &gt; 0:\n            zoomFactor &#x3D; inFactor\n        else:\n            zoomFactor &#x3D; outFactor\n        self.zoomAmount &#x3D; zoomFactor\n        return zoomFactor\n\n    def setZoomAmount(self, value):\n        &quot;&quot;&quot; 通过采用视图图标大小（）*值来设置此视图的缩放量\n        :param value:\n        :type value:\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        currentSize &#x3D; QSize(self.initialIconSize)\n        newSize &#x3D; currentSize.width() * value\n        if newSize &lt; self.defaultMinIconSize:\n            return\n        currentSize.setWidth(newSize)\n        currentSize.setHeight(newSize)\n        self.requestZoom.emit(newSize, self.zoomAmount)\n        self.setIconSize(currentSize)\n\n    def mouseDoubleClickEvent(self, event):\n        if event.button() &#x3D;&#x3D; Qt.LeftButton:\n            index &#x3D; self.currentIndex()\n            model &#x3D; self.model()\n            if model is not None:\n                item &#x3D; model.itemFromIndex(index)\n                model.doubleClickEvent(index, item)\n                self.requestDoubleClick.emit(index, item)\n\n    def resizeEvent(self, event):\n        self.calcResize(event.size())\n        super(ThumbListView, self).resizeEvent(event)\n        self.loadVisibleIcons()\n\n    def setColumns(self, col):\n        &quot;&quot;&quot; 根据小组件的当前大小设置列数\n        :param col:\n        :type col:\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n\n        self.setIconSize(self.defaultIconSize)\n\n        # Sets columns on next calcResize\n        self.columnQueue &#x3D; col\n\n        # Change the default size, but only if it has been already set\n        if self.defaultSize is not None:\n            self.defaultSize &#x3D; self.widgetSize()\n            self.calcResize(self.defaultSize)\n\n    def calcResize(self, size):\n        &quot;&quot;&quot; 计算项目的大小调整\n        :param size:\n        :type size:\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        if self.defaultSize is None:\n            # Initialize values\n            self.defaultSize &#x3D; size\n            self.initialIconSize &#x3D; QSize(self._iconSize)\n            self.stateChanged.emit()\n            QTimer.singleShot(0, self.refresh)\n            return\n\n        # Exclude the verticalScrollbar space\n        if not self.verticalScrollBar().isVisible():\n            size -&#x3D; QSize(self.verticalScrollBar().size().width(), 0)\n\n        size -&#x3D; QSize(dpiScale(2), 0)\n\n        # Calculate the number of columns\n        iconWidth &#x3D; (self.initialIconSize * self.zoomAmount).width() + self.spacing()\n        calcColumns &#x3D; int(size.width() &#x2F; iconWidth)  # calculate number of columns and round it down\n        columns &#x3D; calcColumns + self.columnOffset\n\n        # setColumn() was run so set the columns by changing the columnOffset\n        if self.columnQueue !&#x3D; 0:\n            diff &#x3D; self.columnQueue - calcColumns\n            columns &#x3D; self.columnQueue\n            self.columnOffset &#x3D; diff\n            self.columnQueue &#x3D; 0\n\n        columns &#x3D; max(columns, 1)  # atleast 1 column\n\n        # Set columnOffset maximum and minimum\n\n        # Calculate the new ratio to resize the icons to\n        ratio &#x3D; float(iconWidth * columns) &#x2F; float(size.width())\n        self.setZoomAmount(1 &#x2F; ratio)\n        self.stateChanged.emit()\n\n    def refresh(self):\n        &quot;&quot;&quot; 刷新，以便图标正确显示\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        QCoreApplication.processEvents()\n        size &#x3D; self.size() - QSize(self.verticalScrollBar().size().width(), 0)\n        self.resizeEvent(QResizeEvent(size, size))\n        self.model().layoutChanged.emit()\n        if not self.updatesEnabled():\n            self.setUpdatesEnabled(True)\n\n    def setModel(self, model):\n        model.setUniformItemSizes(self._uniformItemSizes)\n        return super(ThumbListView, self).setModel(model)\n\n\nclass ThumbnailViewWidget(QWidget):\n    &quot;&quot;&quot;用于查看缩略图的主要小部件，它运行在自定义QStandardItemModel上&quot;&quot;&quot;\n    requestSelectionChanged &#x3D; Signal(object, object)\n    def __init__(self, parent&#x3D;None, listDelegate&#x3D;None, listView&#x3D;ThumbListView, columns&#x3D;None, iconSize&#x3D;None,\n                 fixedWidth&#x3D;None, fixedHeight&#x3D;None, uniformIcons&#x3D;False):\n        &quot;&quot;&quot;\n        :param parent: the parent widget\n        :type parent: QWidget\n        :param listDelegate:\n        :type listDelegate:\n        :param listView:\n        :type listView:\n        :param columns: The number of square image columns, will vary for non-square images, overrides iconSize\n        :type columns: int\n        :param iconSize: Set the icon size in pixels, will be overridden by columns\n        :type iconSize: QSize\n        :param fixedWidth: The fixed width of the widget in pixels, dpi handled\n        :type fixedWidth: int\n        :param fixedHeight: the fixed height of the widget in pixels, dpi handled\n        :type fixedHeight: int\n        :param uniformIcons: Will keep the icons square, images will be clipped if True, non square if False\n        :type uniformIcons: bool\n        &quot;&quot;&quot;\n        super(ThumbnailViewWidget, self).__init__(parent&#x3D;parent)\n        self.qModel &#x3D; None\n        self.listDelegate &#x3D; listDelegate\n        self.listViewClass &#x3D; listView  # type: type(ThumbListView)\n        self.uniformIcons &#x3D; uniformIcons\n\n        self.initUi()\n        self.autoResizeItems &#x3D; True\n        self.pagination &#x3D; True\n\n        if iconSize is not None:\n            self.setIconSize(iconSize)\n        if columns:\n            self.setColumns(columns)\n        if fixedHeight:\n            self.setFixedHeight(dpiScale(fixedHeight))\n        if fixedWidth:\n            self.setFixedWidth(dpiScale(fixedWidth))\n\n    def initUi(self):\n        layout &#x3D; QVBoxLayout(self)\n        self.setLayout(layout)\n        self.listView &#x3D; self.listViewClass(parent&#x3D;self, delegate&#x3D;self.listDelegate, uniformItems&#x3D;self.uniformIcons)\n        layout.addWidget(self.listView)\n        self.listView.verticalScrollBar().valueChanged.connect(self.paginationLoadNextItems)\n        self.listView.contextMenuRequested.connect(self.contextMenu)\n\n        layout.setContentsMargins(0, 0, 0, 0)\n        self.listView.setSpacing(dpiScale(0))\n\n    def setModel(self, model):\n        self.listView.setModel(model)\n        model.refreshRequested.connect(self.listView.loadVisibleIcons)\n        model.view &#x3D; self\n\n        self.qModel &#x3D; model\n        if self.listView.selectionModel():\n            self.listView.selectionModel().selectionChanged.connect(self.onSelectionChanged)\n\n    def refreshListView(self):\n        &quot;&quot;&quot; 刷新列表视图，确保图标正确调整大小&quot;&quot;&quot;\n        self.listView.refresh()\n\n    def invisibleRootItem(self):\n        if self.qModel:\n            return self.qModel.invisibleRootItem()\n\n    def iconSize(self):\n        return self.listView.iconSize()\n\n    def setIconSize(self, size):\n        if size &#x3D;&#x3D; self.listView.iconSize():\n            return\n        maxSize &#x3D; self.listView.defaultMaxIconSize\n        minSize &#x3D; self.listView.defaultMinIconSize\n        width &#x3D; size.width()\n        height &#x3D; size.height()\n        if width &gt; maxSize or height &gt; maxSize:\n            size &#x3D; QSize(maxSize, maxSize)\n        elif width &lt; minSize or height &lt; minSize:\n            size &#x3D; QSize(minSize, minSize)\n        self.listView.setIconSize(size)\n\n    def filter(self, text, tag&#x3D;None):\n        self.listView.filter(text, tag)\n\n    def setColumns(self, col):\n        &quot;&quot;&quot; 将列重置为默认值&quot;&quot;&quot;\n        self.listView.setColumns(col)\n\n    def setIconMinMax(self, size):\n        &quot;&quot;&quot; 设置最小和最大图标大小\n        :param size: 图标大小的最小值和最大值\n        :type size: tuple(int, int)\n        &quot;&quot;&quot;\n        minSize &#x3D; size[0]\n        maxSize &#x3D; size[1]\n        self.listView.defaultMinIconSize &#x3D; minSize\n        self.listView.defaultMaxIconSize &#x3D; maxSize\n        currentSize &#x3D; self.listView.iconSize()\n        width &#x3D; currentSize.width()\n        height &#x3D; currentSize.height()\n        if width &gt; maxSize or height &gt; maxSize:\n            size &#x3D; QSize(maxSize, maxSize)\n            self.listView.setIconSize(size)\n        elif width &lt; minSize or height &gt; minSize:\n            size &#x3D; QSize(minSize, minSize)\n            self.listView.setIconSize(size)\n\n    def paginationLoadNextItems(self):\n        &quot;&quot;&quot;当垂直滑块达到最大值时调用模型 loadData 方法的简单方法，对加载模型的下一页数据很有用。&quot;&quot;&quot;\n        if not self.pagination:\n            return\n        model &#x3D; self.listView.model()\n        if model is None:\n            return\n\n        vbar &#x3D; self.listView.verticalScrollBar()\n        sliderMax &#x3D; vbar.maximum()\n        sliderPos &#x3D; vbar.sliderPosition()\n\n        if sliderPos &#x3D;&#x3D; sliderMax:\n            indexes &#x3D; self.listView.selectionModel().selection().indexes()\n            model.loadData()\n            # Reselect selection\n            self.listView.setAutoScroll(False)\n            [self.listView.selectionModel().setCurrentIndex(index, QItemSelectionModel.SelectCurrent) for index\n             in indexes]\n            self.listView.setAutoScroll(True)\n\n    def contextMenu(self, items, menu):\n        pass\n\n    def onSelectionChanged(self):\n        index &#x3D; self.listView.currentIndex()\n        model &#x3D; self.listView.model()\n        if model is not None:\n            item &#x3D; model.itemFromIndex(index)\n            model.onSelectionChanged(index, item)\n            self.requestSelectionChanged.emit(index, item)\n\n\nclass SettingObject(dict):\n    &quot;&quot;&quot;设置类，用于封装给定设置的 json 数据&quot;&quot;&quot;\n    def __init__(self, root, relativePath&#x3D;None, **kwargs):\n\n        relativePath &#x3D; relativePath\n        if not relativePath.suffix:\n            relativePath &#x3D; relativePath.with_suffix(&quot;.json&quot;)\n        kwargs[&quot;relativePath&quot;] &#x3D; relativePath\n        kwargs[&quot;root&quot;] &#x3D; root\n        super(SettingObject, self).__init__(**kwargs)\n\n    def rootPath(self):\n        if self.root:\n            return self.root\n        return\n\n    def path(self):\n        return self.root &#x2F; self[&quot;relativePath&quot;]\n\n    def isValid(self):\n        if self.root is None:\n            return False\n        elif (self.root &#x2F; self.relativePath).exists():\n            return True\n        return False\n\n    def __repr__(self):\n        return &quot;&lt;&#123;&#125;&gt; root: &#123;&#125;, path: &#123;&#125;&quot;.format(self.__class__.__name__, self.root, self.relativePath)\n\n    def __cmp__(self, other):\n        return self.name &#x3D;&#x3D; other and self.version &#x3D;&#x3D; other.version\n\n    def __getattr__(self, item):\n        try:\n            return self[item]\n        except KeyError:\n            return super(SettingObject, self).__getattribute__(item)\n\n    def __setattr__(self, key, value):\n        self[key] &#x3D; value\n\n    def save(self, indent&#x3D;False, sort&#x3D;False):\n        &quot;&quot;&quot;将文件作为 json 保存到磁盘\n        :param indent: 如果为 True，则很好地格式化 json（缩进 &#x3D; 2）\n        :type indent: bool\n        :return fullPath: 保存的 .json 文件的完整路径\n        :rtype fullPath: str\n        &quot;&quot;&quot;\n        root &#x3D; self.root\n\n        if not root:\n            return\n\n        fullPath &#x3D; root &#x2F; self.relativePath\n        ensureFolderExists(str(fullPath.parent))\n        output &#x3D; copy.deepcopy(self)\n        del output[&quot;root&quot;]\n        del output[&quot;relativePath&quot;]\n        exts &#x3D; fullPath.suffix\n        if not exts:\n            fullPath &#x3D; fullPath.with_suffix(&quot;json&quot;)\n        if not indent:\n            saveJson(output, str(fullPath), sort_keys&#x3D;sort)\n        else:\n            saveJson(output, str(fullPath), indent&#x3D;2, sort_keys&#x3D;sort)\n\n        return self.path()\n\n\nclass ItemSignals(QObject):\n    &quot;&quot;&quot;\n    定义正在运行的工作线程中可用的信号。\n    支持的信号包括：\n    完成：无数据\n    错误：&#96;tuple&#96; (exctype, value, traceback.format_exc() )\n    处理结果：&#96;object&#96; 从处理中返回的数据，任何东西\n    处理进度：&#96;int&#96; 指示进度百分比\n    &quot;&quot;&quot;\n    updated &#x3D; Signal(object)\n    finished &#x3D; Signal()\n    error &#x3D; Signal(tuple)\n    result &#x3D; Signal(object)\n    progress &#x3D; Signal(int)\n\n\nclass TreeItem(QStandardItem):\n    backgroundColor &#x3D; QColor(70, 70, 80)\n    backgroundColorSelected &#x3D; QColor(50, 180, 240)\n    backgroundColorHover &#x3D; QColor(50, 180, 150)\n    textColorSelected &#x3D; QColor(255, 255, 255)\n    textColor &#x3D; QColor(255, 255, 255)\n    textBGColor &#x3D; QColor(0, 0, 0)\n    backgroundBrush &#x3D; QBrush(backgroundColor)\n    backgroundColorSelectedBrush &#x3D; QBrush(backgroundColorSelected)\n    backgroundColorHoverBrush &#x3D; QBrush(backgroundColorHover)\n    borderColorSelected &#x3D; QColor(0, 0, 0)\n    borderColorHover &#x3D; QColor(0, 0, 0)\n    borderColor &#x3D; QColor(0, 0, 0)\n    backgroundColorIcon &#x3D; QColor(50, 50, 50)\n\n    def __init__(self, item, parent&#x3D;None, themePref&#x3D;None, squareIcon&#x3D;False):\n        super(TreeItem, self).__init__(parent&#x3D;parent)\n        self.currentTheme &#x3D; &quot;&quot;\n        self.padding &#x3D; 0\n        self.textHeight &#x3D; 11\n        self.borderWidth &#x3D; 1\n        self.textPaddingH &#x3D; 7\n        self.textPaddingV &#x3D; 2\n\n        self.showText &#x3D; True\n        self._item &#x3D; item\n        self._pixmap &#x3D; None\n        self.iconSize &#x3D; QSize(256, 256)\n        self.loaderThread &#x3D; ThreadedIcon(item.iconPath)\n        self.setEditable(False)\n        self.aspectRatio &#x3D; Qt.KeepAspectRatioByExpanding\n\n        self.themePref &#x3D; themePref\n        self.squareIcon &#x3D; squareIcon\n\n        self.setBorderWidth(1)\n\n        if themePref is not None:\n            self.updateTheme()\n\n    def updateTheme(self):\n        self.currentTheme &#x3D; self.themePref.currentTheme()\n        self.textHeight &#x3D; self.themePref.DEFAULT_FONTSIZE\n        self.borderWidth &#x3D; self.themePref.ONE_PIXEL\n        self.textPaddingH &#x3D; dpiScale(7)\n        self.textPaddingV &#x3D; dpiScale(3)\n        self.backgroundColorSelected &#x3D; QColor(*self.themePref.BROWSER_SELECTED_COLOR)\n        self.backgroundColor &#x3D; QColor(*self.themePref.BROWSER_BG_COLOR)\n        self.backgroundBrush &#x3D; QBrush(self.backgroundColor)\n        self.backgroundColorHover &#x3D; self.backgroundColor\n        self.backgroundColorHoverBrush &#x3D; QBrush(self.backgroundColorHover)\n        self.backgroundColorSelectedBrush &#x3D; QBrush(self.backgroundColorSelected)\n        self.backgroundColorIcon &#x3D; QColor(*self.themePref.BROWSER_ICON_BG_COLOR)\n        self.borderColor &#x3D; QColor(self.backgroundColor)\n\n        self.textColorSelected &#x3D; QColor(*self.themePref.TBL_TREE_ACT_TEXT_COLOR)\n        self.borderColorSelected &#x3D; QColor(*self.themePref.BROWSER_SELECTED_COLOR)\n        self.borderColorHover &#x3D; QColor(*self.themePref.BROWSER_BORDER_HOVER_COLOR)\n        self.textColor &#x3D; QColor(*self.themePref.BROWSER_TEXT_COLOR)\n\n        self.textBGColor &#x3D; QColor(*self.themePref.BROWSER_TEXT_BG_COLOR)\n\n    def item(self):\n        return self._item\n\n    def applyFromImage(self, image):\n        pixmap &#x3D; QPixmap()\n        pixmap &#x3D; pixmap.fromImage(image)\n        self._pixmap &#x3D; pixmap\n        self.model().dataChanged.emit(self.index(), self.index())\n\n    def setIconPath(self, iconPath):\n        self._item.iconPath &#x3D; iconPath\n        self._pixmap &#x3D; QPixmap(iconPath)\n\n    def pixmap(self):\n        &quot;&quot;&quot;\n        :return:\n        :rtype: QPixmap\n        &quot;&quot;&quot;\n        if not self._pixmap.isNull():\n            return self._pixmap\n        elif not os.path.exists(self._item.iconPath):\n            return QPixmap()\n        return self._pixmap\n\n    def toolTip(self):\n        return self._item.description()\n\n    def isEditable(self, *args, **kwargs):\n        return False\n\n    def sizeHint(self):\n        # todo: could be done better\n        sizeHint &#x3D; self.model().view.iconSize()\n        if self._pixmap:\n            pxSize &#x3D; self._pixmap.rect().size()\n        else:\n            pxSize &#x3D; QSize(1, 1)\n\n        size &#x3D; min(sizeHint.height(), sizeHint.width())\n        pxSize &#x3D; QSize(128, 128) if pxSize &#x3D;&#x3D; QSize(0, 0) else pxSize\n        if self.squareIcon:\n            aspectRatio &#x3D; 1\n        else:\n            aspectRatio &#x3D; float(pxSize.width()) &#x2F; float(pxSize.height())\n            if aspectRatio &lt;&#x3D; 1:\n                sizeHint.setWidth(size * aspectRatio)\n            else:\n                sizeHint.setWidth(size * aspectRatio)\n\n        sizeHint.setHeight(size + 1)\n\n        if self.showText:\n            sizeHint.setHeight(sizeHint.height() + self.textHeight + self.textPaddingV * 2)\n\n        return sizeHint\n\n    def font(self, index):\n        return QFont(&quot;Roboto&quot;)\n\n    def textAlignment(self, index):\n        return Qt.AlignLeft | Qt.AlignBottom\n\n    def iconAlignment(self, index):\n        return Qt.AlignLeft | Qt.AlignVCenter\n\n    def removeRow(self, item):\n        if item.loaderThread.isRunning:\n            item.loaderThread.wait()\n        return super(TreeItem, self).removeRow(item)\n\n    def removeRows(self, items):\n        for item in items:\n            if item.loaderThread.isRunning:\n                item.loaderThread.wait()\n        return super(TreeItem, self).removeRows(items)\n\n    def isSelected(self, option):\n        return option.state &amp; QStyle.State_Selected\n\n    def isMouseOver(self, option):\n        return option.state &amp; QStyle.State_MouseOver\n\n    def setBorderWidth(self, width):\n        self.borderWidth &#x3D; dpiScale(width)\n\n    def paint(self, painter, option, index):\n        painter.save()\n        self._paintBackground(painter, option, index)\n        if self.showText:\n            self._paintText(painter, option, index)\n        if self._pixmap is not None:\n            self._paintIcon(painter, option, index)\n        painter.restore()\n\n    def _paintIcon(self, painter, option, index):\n        &quot;&quot;&quot;\n        :param painter:\n        :type painter:  QPainter\n        :param option:\n        :type option:\n        :param index:\n        :type index:\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        rect &#x3D; self.iconRect(option)\n        pixmap &#x3D; self.pixmap()  # type: QPixmap\n        if pixmap.isNull():\n            return\n        pixmap &#x3D; pixmap.scaled(\n            rect.width() - self.borderWidth * 2,\n            rect.height() - self.borderWidth * 2,\n            self.aspectRatio,\n            Qt.SmoothTransformation,\n        )\n\n        pixmapRect &#x3D; QRect(rect)\n        pixmapRect.setWidth(pixmap.width())\n        pixmapRect.setHeight(pixmap.height())\n        aspectRatio &#x3D; float(pixmap.width()) &#x2F; float(pixmap.height())\n\n        iconAlign &#x3D; self.iconAlignment(None)\n\n        if iconAlign &amp; Qt.AlignHCenter &#x3D;&#x3D; Qt.AlignHCenter:\n            x &#x3D; float(rect.width() - pixmap.width()) * 0.5\n        elif iconAlign &amp; Qt.AlignLeft &#x3D;&#x3D; Qt.AlignLeft:\n            x &#x3D; 0\n        else:  # todo: set the rest of the flags\n            x &#x3D; float(rect.width() - pixmap.width()) * 0.5\n            print(&quot;Flags not set for TreeItem._paintIcon()! x-Value&quot;)\n\n        if iconAlign &amp; Qt.AlignVCenter &#x3D;&#x3D; Qt.AlignVCenter:\n            y &#x3D; float(rect.height() - pixmap.height()) * 0.5\n        else:  # todo: set the rest of the flags\n            y &#x3D; float(rect.height() - pixmap.height()) * 0.5\n            print(&quot;Flags not set for TreeItem._paintIcon() y-Value!  &quot;)\n\n        x +&#x3D; self.borderWidth\n        pixmapRect.translate(x, y)\n\n        # Hacky fixes to visuals &#x3D;[\n        if self.squareIcon:\n            clippedRect &#x3D; QRect(pixmapRect)\n            clippedRect.setWidth(clippedRect.width() - 1)\n            if clippedRect.height() &lt;&#x3D; clippedRect.width():  # Wide icons\n                translate &#x3D; (clippedRect.width() - clippedRect.height()) &#x2F; 2\n                clippedRect.setWidth(clippedRect.height() - 1)\n                pixmapRect.translate(-translate, 0)\n            else:  # Tall Icons\n                translate &#x3D; (clippedRect.height() - clippedRect.width()) &#x2F; 2\n                clippedRect.setHeight(clippedRect.width() + 2)\n                clippedRect.setWidth(clippedRect.width())\n                clippedRect.translate(0, translate)\n            painter.setClipRect(clippedRect)\n        else:\n            if aspectRatio &gt; 1:\n                pixmapRect.setWidth(pixmapRect.width())\n            elif aspectRatio &gt;&#x3D; 1:\n                pixmapRect.setWidth(pixmapRect.width() - 1)\n        painter.drawPixmap(pixmapRect, pixmap)\n\n    def _paintText(self, painter, option, index):\n        isSelected &#x3D; self.isSelected(option)\n        isMouseOver &#x3D; self.isMouseOver(option)\n        text &#x3D; self._item.name\n        color &#x3D; self.textColorSelected if isSelected else self.textColor\n        rect &#x3D; QRect(option.rect)\n        width &#x3D; rect.width() - self.textPaddingH * 2\n        height &#x3D; rect.height()\n        padding &#x3D; self.padding\n        x, y &#x3D; padding, padding\n        rect.translate(x + self.textPaddingH, y + self.textPaddingV)\n        rect.setWidth(width - padding)\n        rect.setHeight(height - padding - self.textPaddingV)\n        font &#x3D; self.font(index)\n        font.setPixelSize(self.textHeight)\n\n        align &#x3D; self.textAlignment(index)\n        metrics &#x3D; QFontMetricsF(font)\n        textWidth &#x3D; metrics.width(text)\n        # does the text fit? if not cut off the text\n        if textWidth &gt; rect.width() - padding:\n            text &#x3D; metrics.elidedText(text, Qt.ElideRight, rect.width())\n\n        if isSelected:\n            textBgColor &#x3D; self.borderColorSelected\n        else:\n            textBgColor &#x3D; self.textBGColor\n\n        textBg &#x3D; QRect(option.rect)\n        textBg.setTop(textBg.top() + textBg.height() - (self.textHeight + self.textPaddingV * 2))\n        textBg.translate(max(1, self.borderWidth * 0.5), max(1, self.borderWidth * 0.5) - 2)\n        textBg.setWidth(textBg.width() - self.borderWidth * 2 - 1)\n        textBg.setHeight(self.textHeight + self.textPaddingV)\n        painter.setBrush(textBgColor)\n        painter.setPen(textBgColor)\n        painter.drawRect(textBg)\n\n        pen &#x3D; QPen(color)\n        painter.setPen(pen)\n        painter.setFont(font)\n        painter.drawText(rect, align, text)\n\n    def _paintBackground(self, painter, option, index):\n\n        isSelected &#x3D; self.isSelected(option)\n        isMouseOver &#x3D; self.isMouseOver(option)\n\n        if isSelected:\n            brush &#x3D; self.backgroundColorSelectedBrush\n\n            if isMouseOver:\n                borderColor &#x3D; self.borderColorHover\n            else:\n                borderColor &#x3D; self.borderColorSelected\n\n        elif isMouseOver:\n            brush &#x3D; self.backgroundColorHoverBrush\n            borderColor &#x3D; self.borderColorHover\n        else:\n            brush &#x3D; self.backgroundBrush\n            borderColor &#x3D; self.borderColor\n        pen &#x3D; QPen(borderColor)\n        pen.setJoinStyle(Qt.MiterJoin)\n        pen.setWidth(self.borderWidth)\n        painter.setPen(pen)\n\n        rect &#x3D; QRect(option.rect)\n        rect.setWidth(rect.width() - self.borderWidth)\n        rect.setHeight(rect.height() - self.borderWidth)\n        rect.translate(self.borderWidth * 0.5, self.borderWidth * 0.5)\n\n        painter.setBrush(brush)\n        painter.drawRect(rect)\n\n        # Icon background\n        iconPen &#x3D; QPen(self.backgroundColorIcon)\n        iconPen.setWidth(0)\n        iconRect &#x3D; QRect(rect)\n        painter.setBrush(QBrush(self.backgroundColorIcon))\n        iconRect.setHeight(iconRect.height() - (self.textHeight + self.textPaddingV * 2))\n        iconRect.translate(max(1, self.borderWidth * 0.5), max(1, self.borderWidth * 0.5))\n        iconRect.setWidth(iconRect.width() - self.borderWidth * 2)\n        painter.setPen(iconPen)\n        painter.drawRect(iconRect)\n\n    def iconRect(self, option):\n        padding &#x3D; self.padding\n        rect &#x3D; option.rect\n        width &#x3D; rect.width() - padding\n        height &#x3D; rect.height() - padding\n        # deal with the text #\n        if self.showText:\n            height -&#x3D; self.textHeight + self.textPaddingV * 2\n        rect.setWidth(width)\n        rect.setHeight(height)\n\n        x &#x3D; padding + (float(width - rect.width()) * 0.5)\n        y &#x3D; padding + (float(height - rect.height()) * 0.5)\n        rect.translate(x, y)\n        return rect\n\n\nclass ThreadedIcon(QRunnable):\n\n    def __init__(self, iconPath, width&#x3D;None, height&#x3D;None, *args, **kwargs):\n        super(ThreadedIcon, self).__init__(*args, **kwargs)\n        self.signals &#x3D; ItemSignals()\n        # Add the callback to our kwargs\n        kwargs[&#39;progress_callback&#39;] &#x3D; self.signals.progress\n\n        self._path &#x3D; iconPath\n        self.width &#x3D; width\n        self.height &#x3D; height\n        self.placeHolderImage &#x3D; QImage(50, 50, QImage.Format_ARGB32)\n        self.placeHolderImage.fill(qRgb(96, 96, 96))\n        self._finished &#x3D; False\n\n    def finished(self, state):\n        self._finished &#x3D; state\n        self.signals.finished.emit()\n\n    def isFinished(self):\n        return self._finished\n\n    @Slot()\n    def run(self):\n        if not self._path or self._finished:\n            return\n        self.signals.updated.emit(self.placeHolderImage)\n        try:\n            image &#x3D; QImage(self._path)\n        except Exception as er:\n            self.signals.error.emit((er,))\n            self.finished(True)\n            return\n        self.signals.updated.emit(image)\n        self.finished(True)\n\n\nclass BaseItem(object):\n    def __init__(self, name&#x3D;None, description&#x3D;None, iconPath&#x3D;None):\n        self.name &#x3D; name or &quot;&quot;\n        self.iconPath &#x3D; iconPath or &quot;&quot;\n        self._description &#x3D; description or &quot;&quot;\n        self.metadata &#x3D; &#123;&#125;\n        self.user &#x3D; &quot;&quot;\n        self.iconThread &#x3D; None  # type: ThreadedIcon\n\n    def description(self):\n        return self._description\n\n    def iconLoaded(self):\n        if self.iconThread is not None and self.iconThread.isFinished():\n            return True\n        return False\n\n    def tags(self):\n        return self.metadata.get(&quot;metadata&quot;, &#123;&#125;).get(&quot;tags&quot;, [])\n\n    def hasTag(self, tag):\n        for i in self.tags:\n            if tag in i:\n                return True\n        return False\n\n    def hasAnyTags(self, tags):\n        for i in tags:\n            if self.hasTag(i):\n                return True\n        return False\n\n    def serialize(self):\n        return &#123;&quot;metadata&quot;: &#123;&quot;time&quot;: &quot;&quot;,\n                             &quot;version&quot;: &quot;&quot;,\n                             &quot;user&quot;: &quot;&quot;,\n                             &quot;name&quot;: self.name,\n                             &quot;application&quot;: &#123;&quot;name&quot;: &quot;&quot;,\n                                             &quot;version&quot;: &quot;&quot;&#125;,\n                             &quot;description&quot;: &quot;&quot;,\n                             &quot;tags&quot;: []&#125;,\n                &#125;\n\n\nclass FileViewModel(QStandardItemModel):\n    parentClosed &#x3D; Signal(bool)\n    doubleClicked &#x3D; Signal(str)\n    selectionChanged &#x3D; Signal(str)\n    refreshRequested &#x3D; Signal()\n\n    def __init__(self, view, directory&#x3D;None, extensions&#x3D;None, chunkCount&#x3D;20, uniformIcons&#x3D;False):\n        &quot;&quot;&quot; 覆盖基本模型以处理缩略图视图小部件数据的加载，例如。特定文件&#x2F;图像\n        此类是附加到缩略图视图的缩略图模型的最基本形式,给定并填充有“png”、“jpg”或“jpeg”图像的目录。\n        工具提示也是从文件名生成的,可以进一步覆盖此类，以便在子目录（如 .zooScene 文件）中加载自定义图像。\n        :param view: The viewer to assign this model data?\n        :type view: thumbwidget.ThumbListView\n        :param directory: The directory full path where the .zooScenes live\n        :type directory: str\n        :param chunkCount: The number of images to load at a time into the ThumbnailView widget\n        :type chunkCount: int\n        :param extensions: The image file extensions to override, otherwise will be [&quot;png&quot;, &quot;jpg&quot;, &quot;jpeg&quot;]\n        :type extensions: list of basestring\n        :param uniformIcons: False keeps the images non-square.  True the icons will be square, clipped on longest axis\n        :type uniformIcons: bool\n        &quot;&quot;&quot;\n        super(FileViewModel, self).__init__(parent&#x3D;view)\n        self.view &#x3D; view\n        self.extensions &#x3D; extensions\n        self.chunkCount &#x3D; chunkCount\n        self.currentFilesList &#x3D; []  # the files loaded in the viewer, empty while initializing\n        self.infoDictList &#x3D; None  # usually used for generating tooltips\n        self.toolTipList &#x3D; None  # list of tooltips to match each images\n        self.currentImage &#x3D; None  # the current image name selected (no image highlighted on creation)\n        self.fileNameList &#x3D; None  # each file&#39;s name with an extension\n        self.fileNameListNoExt &#x3D; None  # each file&#39;s name without an extension, for display\n        self.directory &#x3D; None\n        self.themePref &#x3D; None\n        self.threadPool &#x3D; QThreadPool.globalInstance()\n        self.lastFilter &#x3D; &quot;&quot;\n        self.uniformIcons &#x3D; uniformIcons\n        self.dynamicLoading &#x3D; True  # Dynamic icon loading\n\n        # load the images\n        if directory is not None:\n            self.setDirectory(directory, True)\n\n    def setDirectory(self, directory, refresh&#x3D;True):\n        &quot;&quot;&quot;用于设置或更改目录&quot;&quot;&quot;\n        self.directory &#x3D; directory\n        if refresh:\n            self.refreshList()\n\n    def refreshList(self):\n        &quot;&quot;&quot; 如果内容已修改，则刷新图标列表，不更改根目录 &quot;&quot;&quot;\n        self.view.setUpdatesEnabled(False)\n        self.clear()\n        self.refreshModelData()\n        self.loadData()\n        self.view.setUpdatesEnabled(True)\n\n    def _thumbnails(self, extensions&#x3D;None):\n        &quot;&quot;&quot; 获取文件缩略图的完整路径名\n        在这种情况下，缩略图是文件（图像）本身\n            [&quot;C:&#x2F;aPath&#x2F;image01.jpg&quot;, &quot;C:&#x2F;aPath&#x2F;image02.jpg&quot;]\n        如果您需要从其他位置获取缩略图，即 .zooScene 或 .hdr 文件的缩略图，请覆盖此设置\n        :type extensions: 文件扩展名列表或设置为“None”以使用所有图像\n        :return: List of paths to image files\n        :rtype: list of basestring\n        &quot;&quot;&quot;\n        results &#x3D; []\n        for i in self.fileNameList:\n            fullPath &#x3D; os.path.join(self.directory, i)\n            if extensions is None and isImage(fullPath):\n                results.append(fullPath)\n            else:\n                # todo: do extensions\n                pass\n\n        return results\n\n    def _infoDictionaries(self):\n        &quot;&quot;&quot;重写基类,返回每个 .zooScene 文件的信息字典列表。这些词典包含作者、标签、描述等信息\n        :return infoDictList: A list of info dictionaries for each .zooScene file\n        :rtype infoDictList: list(dict)\n        &quot;&quot;&quot;\n        return infoDictionaries(self.fileNameList, self.directory)\n\n    def _toolTips(self):\n        &quot;&quot;&quot;重写基类将_toolTips生成为列表，由 self.infoDictList 构造而成&quot;&quot;&quot;\n        self.toolTipList &#x3D; list()\n        for i, thumb in enumerate(self.currentFilesList):\n            self.toolTipList.append(self._createToolTip(self.infoDictList[i], self.fileNameList[i]))\n\n    def _createToolTip(self, infoDictSingle, fileName):\n        &quot;&quot;&quot;重写基类,从单个 zooScene 文件创建单个工具提示\n        :param zooScenePath: The full path to the zooScene image\n        :type zooScenePath: str\n        :param infoDictSingle: The information dictionary with tag author and description information\n        :type infoDictSingle: str\n        :return toolTip: The tooltip description\n        :rtype toolTip: str\n        &quot;&quot;&quot;\n        if not infoDictSingle:  # dict is none so return file path as tooltip\n            return os.path.join(self.directory, fileName)\n        # breaks on some unicode so convert to plain text\n        filepath &#x3D; &quot;&#123;&#125; &quot;.format(os.path.join(self.directory, fileName))\n        info &#x3D; &quot;&quot;\n        website &#x3D; &quot;&quot;\n        toolTip &#x3D; (&quot;&#123;&#125;&#123;&#125;&#123;&#125; &quot;.format(info, filepath, website))\n        return toolTip\n\n    def clear(self):\n        &quot;&quot;&quot;清除模型中的图像和数据，通常在刷新时使用&quot;&quot;&quot;\n        # remove any threads that haven&#39;t started yet\n        self.threadPool.clear()\n\n        while not self.threadPool.waitForDone():\n            continue\n        # clear any items, this is necessary to get python to GC alloc memory\n        self.items &#x3D; []\n        self.loadedCount &#x3D; 0\n        self.currentFilesList &#x3D; []\n        super(FileViewModel, self).clear()\n\n    def fileList(self):\n        &quot;&quot;&quot;更新self.fileNameList ,可以覆盖\n        &quot;&quot;&quot;\n        if not self.extensions:\n            self.extensions &#x3D; [&quot;png&quot;, &quot;jpg&quot;, &quot;jpeg&quot;]\n        if not isinstance(self.extensions, list):\n            raise ValueError(&quot;Extensions must be list, \\&quot;&#123;&#125;\\&quot; type given \\&quot;&#123;&#125;\\&quot; &quot;.format(type(self.extensions),\n                                                                                         self.extensions))\n        self.fileNameList &#x3D; filesByExtension(self.directory, self.extensions)\n\n    def filterList(self, text, tag&#x3D;None):\n        &quot;&quot;&quot; 返回在搜索中显示或隐藏的行的整数列表\n        :param text:\n        :type text:\n        :param tag:\n        :type tag: 字符串或列表\n        :return:\n        :rtype:\n        &quot;&quot;&quot;\n        filterList &#x3D; list()\n        if isinstance(tag, string_types):\n            tag &#x3D; [tag]\n\n        for i in range(len(self.infoDictList)):\n            for t in tag:\n                if t is None or t &#x3D;&#x3D; &quot;filename&quot;:\n                    for j, fileName in enumerate(self.fileNameListNoExt):\n                        if text.lower() in fileName.lower():\n                            filterList.append(j)\n                else:\n                    if text.lower() in self.infoDictList[i][t.lower()].lower():\n                        filterList.append(i)\n\n        for i in range(len(self.fileNameListNoExt)):\n            self.view.listView.setRowHidden(i, i not in filterList)  # Show row if not in filterList\n\n        self.lastFilter &#x3D; text\n\n        return filterList\n\n    def refreshModelData(self):\n        &quot;&quot;&quot;Needs to create&#x2F;recreate the thumbnail lists, tooltips and infoDict data\n        &quot;&quot;&quot;\n        self.fileList()  # updates self.fileNameList\n        self.fileNameListNoExt &#x3D; [os.path.splitext(preset)[0] for preset in self.fileNameList]\n        self.currentFilesList &#x3D; self._thumbnails()\n        self.infoDictList &#x3D; self._infoDictionaries()\n        self._toolTips()  # generates self.toolTipList\n        self.refreshRequested.emit()\n\n    def lazyLoadFilter(self):\n        &quot;&quot;&quot;Breaks up the lists self.currentFilesList, self.fileNameList, self.toolTipList for lazy loading.\n        Can be overridden, usually to choose if the display names should have extensions or not\n        Default is no extensions on display names\n\n        :return filesToLoad: The file name fullpath list (with extensions)\n        :rtype filesToLoad: list of basestring\n        :return namesToLoad: The name of the item, will be the label under the image, usually extension removed\n        :rtype namesToLoad: list of basestring\n        :return tooltipToLoad: The toolTip list to load\n        :rtype tooltipToLoad: list of basestring\n        &quot;&quot;&quot;\n        if len(self.currentFilesList) &lt; self.loadedCount:\n            filesToLoad &#x3D; self.currentFilesList\n            namesToLoad &#x3D; self.fileNameListNoExt\n            tooltipToLoad &#x3D; self.toolTipList\n        else:\n            filesToLoad &#x3D; self.currentFilesList[self.loadedCount: self.loadedCount + self.chunkCount]\n            namesToLoad &#x3D; self.fileNameListNoExt[self.loadedCount: self.loadedCount + self.chunkCount]\n            tooltipToLoad &#x3D; self.toolTipList[self.loadedCount: self.loadedCount + self.chunkCount]\n        return filesToLoad, namesToLoad, tooltipToLoad\n\n    def loadData(self):\n        &quot;&quot;&quot; Overridden method that prepares the images for loading and viewing.\n        Is filtered first via self.lazyLoadFilter()\n        From base class documentation:\n            Lazy loading happens either on first class initialization and any time the vertical bar hits the max value,\n            we then grab the current the new file chunk by files[self.loadedCount: loadedCount + self.chunkCount] that\n            way we are only loading a small amount at a time.\n            Since this is an example of how to use the method , you can approach it in any way you wish but for each item you\n            add you must initialize a item.BaseItem() or custom subclass and a item.treeItem or subclass which handles the\n            qt side of the data per item\n        &quot;&quot;&quot;\n\n        if self.lastFilter !&#x3D; &quot;&quot;:  # Don&#39;t load any new data if theres a search going on\n            return\n\n        filesToLoad, namesToLoad, tooltipToLoad &#x3D; self.lazyLoadFilter()\n        # Load the files\n        for i, f in enumerate(filesToLoad):\n\n            if f is None:\n                f &#x3D; r&quot;C:\\Users\\mirror\\Documents\\zoo_preferences\\assets\\model_assets\\scene_lightSetup_empty_fileDependencies\\thumbnail.jpg&quot;\n\n            workerThread &#x3D; ThreadedIcon(iconPath&#x3D;f)\n            # create an item for the image type\n            it &#x3D; BaseItem(name&#x3D;namesToLoad[i], iconPath&#x3D;f, description&#x3D;tooltipToLoad[i])\n            qitem &#x3D; self.createItem(item&#x3D;it)\n            workerThread.signals.updated.connect(partial(self.setItemIconFromImage, qitem))\n            self.parentClosed.connect(workerThread.finished)\n\n            it.iconThread &#x3D; workerThread\n\n            if self.dynamicLoading is False:\n                self.threadPool.start(workerThread)\n            self.loadedCount +&#x3D; 1\n\n        if len(filesToLoad) &gt; 0:\n            pass\n\n    def createItem(self, item):\n        &quot;&quot;&quot;自定义包装器 创建 ：：类项的方法。TreeItem&#39;，将其添加到模型项和类 appendRow（）\n        :param item:\n        :type item: ::class:&#96;baseItem&#96;\n        :return:\n        :rtype: ::class:&#96;items.TreeItem&#96;\n        &quot;&quot;&quot;\n        tItem &#x3D; TreeItem(item&#x3D;item, themePref&#x3D;self.themePref, squareIcon&#x3D;self.uniformIcons)\n        self.items.append(tItem)\n        self.appendRow(tItem)\n        return tItem\n\n    def setUniformItemSizes(self, enabled):\n        self.uniformIcons &#x3D; enabled\n        for it in self.items:\n            it.squareIcon &#x3D; enabled\n\n    def setItemIconFromImage(self, item, image):\n        &quot;&quot;&quot;由线程调用的自定义方法\n        :param item:\n        :type item: :class:&#96;TreeItem&#96;\n        :param image: The Loaded QImage\n        :type image: QImage\n        &quot;&quot;&quot;\n        item.applyFromImage(image)\n\n    def doubleClickEvent(self, modelIndex, item):\n        &quot;&quot;&quot;双击项时由列表视图调用\n        :param modelIndex:\n        :type modelIndex: QModelIndex\n        :param item:\n        :type item: TreeItem\n        :return self.currentImage:  The current image with it&#39;s name and file extension\n        :rtype self.currentImage:  str\n        &quot;&quot;&quot;\n        self.currentImage &#x3D; item._item.name\n        self.doubleClicked.emit(self.currentImage)\n        return self.currentImage\n\n    def onSelectionChanged(self, modelIndex, item):\n        &quot;&quot;&quot;在更改项目时由列表视图调用，例如左键单击或右键单击\n        :param modelIndex:\n        :type modelIndex: QModelIndex\n        :param item:\n        :type item: TreeItem\n        &quot;&quot;&quot;\n        try:  # can error while renaming files and the change no longer exists so ignore if so\n            self.currentImage &#x3D; item._item.name\n            self.selectionChanged.emit(self.currentImage)\n            return self.currentImage\n        except AttributeError:\n            pass\n\n    def closeEvent(self, event):\n        &quot;&quot;&quot;关闭模型\n        :param event:\n        :type event:\n        &quot;&quot;&quot;\n        if self.qModel is not None:\n            self.qModel.clear()\n            self.qModel.parentClosed.emit(True)\n        super(FileViewModel, self).closeEvent(event)\n\n\nclass ZooSceneViewerModel(FileViewModel):\n    # Emit signals\n    parentClosed &#x3D; Signal(bool)\n    doubleClicked &#x3D; Signal(str)\n    selectionChanged &#x3D; Signal(str)\n\n    def __init__(self, view, directory&#x3D;&quot;&quot;, chunkCount&#x3D;20, uniformIcons&#x3D;False):\n        &quot;&quot;&quot;从缩略图视图小组件的目录中加载 .zooscene 模型数据，拉取依赖目录中的缩略图，并从 file.zooInfo 文件生成工具提示。\n        另请参阅类 FileViewModel（） 以获取更多功能和文档。其可以进一步覆盖此类以在子目录中加载自定义图像，例如Skydomes或控件\n        使用 .zooScene 标签和缩略图信息。\n\n        :param view: 查看器分配此模型数据\n        :type view: qtWidget?\n        :param directory: The directory full path where the .zooScenes live\n        :type directory: str\n        :param chunkCount: The number of images to load at a time into the ThumbnailView widget\n        :type chunkCount: int\n        &quot;&quot;&quot;\n        super(ZooSceneViewerModel, self).__init__(view, directory&#x3D;directory, chunkCount&#x3D;chunkCount,\n                                                  uniformIcons&#x3D;uniformIcons)\n\n    def _thumbnails(self):\n        &quot;&quot;&quot;重写基类，从每个文件的子目录“fileName_fileDependencies”返回缩略图路径的列表：\n            [&quot;C:&#x2F;aPath&#x2F;scene01_fileDependencies&#x2F;thumbnail.jpg&quot;, &quot;C:&#x2F;aPath&#x2F;scene02_fileDependencies&#x2F;thumbnail.jpg&quot;]\n        :return 当前文件列表 list(str):\n        :return 缩略图列表 list(str):\n        &quot;&quot;&quot;\n        return [&quot;C:&#x2F;aPath&#x2F;scene01_fileDependencies&#x2F;thumbnail.jpg&quot;,\n                &quot;C:&#x2F;aPath&#x2F;scene02_fileDependencies&#x2F;thumbnail.jpg&quot;]  # thumbnails(self.directory, self.fileNameListNoExt)\n\n    def fileList(self):\n        &quot;&quot;&quot;\n        重写基类 生成文件列表：\n        [“scene01.zooScene”， “scene02.zooScene”]\n        &quot;&quot;&quot;\n        self.fileNameList &#x3D; [&quot;scene01.zooScene&quot;, &quot;scene02.zooScene&quot;]  # filesByExtension(self.directory, [ZOOSCENE_EXT])\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    app &#x3D; QApplication(sys.argv)\n    thumbViewer &#x3D; ThumbnailViewWidget(parent&#x3D;None, columns&#x3D;3, fixedHeight&#x3D;382, uniformIcons&#x3D;True)\n    thumbModel &#x3D; ZooSceneViewerModel(thumbViewer, directory&#x3D;r&quot;C:\\Users\\mirror\\Documents\\zoo_preferences\\assets\\model_assets&quot;,\n                                                   chunkCount&#x3D;200,\n                                                   uniformIcons&#x3D;True)\n    thumbViewer.setModel(thumbModel)\n    thumbViewer.show()\n    sys.exit(app.exec_())\n\n\n\n\n示例结果：\n \n","categories":["Qt","学习笔记"],"tags":["学习笔记","QT布局"]},{"title":"QT-FlowLayout","url":"/posts/20221115a1.html","content":"记录一下流动布局 QT 中的 flowLayout ,该布局可以根据父 UI 组件窗口的宽度，调整每一行所能容纳的最大的元素个数。\n\n示例代码如下：\n# -*- coding:utf-8 -*-\n# !&#x2F;usr&#x2F;bin&#x2F;env python3\n# Author: Mirror\n# File: flowLayout\n# Time: 2022-12-10 21:43\n# Update： 2022-12-12 22:43\n# Environment:PyCharm\n# Blog: www.mirrorcg.com\n# Description: flowLayout布局示例\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport sys\nfrom PySide2.QtWidgets import QApplication, QLayout, QSizePolicy, QWidget, QPushButton\nfrom PySide2.QtCore import QPoint, QRect, QSize, Qt\n\n\nclass FlowLayout(QLayout):\n    &quot;&quot;&quot;流动布局&quot;&quot;&quot;\n    def __init__(self, parent&#x3D;None, margin&#x3D;0, spacing&#x3D;-1):\n        super(FlowLayout, self).__init__(parent)\n\n        if parent is not None:\n            self.setContentsMargins(margin, margin, margin, margin)\n\n        self.setSpacing(spacing)\n\n        self.itemList &#x3D; []\n\n    def __del__(self):\n        item &#x3D; self.takeAt(0)\n        while item:\n            item &#x3D; self.takeAt(0)\n\n    def addItem(self, item):\n        self.itemList.append(item)\n\n    def count(self):\n        return len(self.itemList)\n\n    def itemAt(self, index):\n        if index &gt;&#x3D; 0 and index &lt; len(self.itemList):\n            return self.itemList[index]\n\n        return None\n\n    def takeAt(self, index):\n        if index &gt;&#x3D; 0 and index &lt; len(self.itemList):\n            return self.itemList.pop(index)\n\n        return None\n\n    def expandingDirections(self):\n        return Qt.Orientations(Qt.Orientation(0))\n\n    def hasHeightForWidth(self):\n        return True\n\n    def heightForWidth(self, width):\n        height &#x3D; self.doLayout(QRect(0, 0, width, 0), True)\n        return height\n\n    def setGeometry(self, rect):\n        super(FlowLayout, self).setGeometry(rect)\n        self.doLayout(rect, False)\n\n    def sizeHint(self):\n        return self.minimumSize()\n\n    def minimumSize(self):\n        size &#x3D; QSize()\n\n        for item in self.itemList:\n            size &#x3D; size.expandedTo(item.minimumSize())\n\n        margin, _a, _b, _c &#x3D; self.getContentsMargins()\n        size +&#x3D; QSize(2 * margin, 2 * margin)\n        return size\n\n    def doLayout(self, rect, testOnly):\n        x &#x3D; rect.x()\n        y &#x3D; rect.y()\n        lineHeight &#x3D; 0\n\n        for item in self.itemList:\n            wid &#x3D; item.widget()\n            spaceX &#x3D; self.spacing() + wid.style().layoutSpacing(QSizePolicy.PushButton,\n                                                                QSizePolicy.PushButton, Qt.Horizontal)\n            spaceY &#x3D; self.spacing() + wid.style().layoutSpacing(QSizePolicy.PushButton,\n                                                                QSizePolicy.PushButton, Qt.Vertical)\n            nextX &#x3D; x + item.sizeHint().width() + spaceX\n            if nextX - spaceX &gt; rect.right() and lineHeight &gt; 0:\n                x &#x3D; rect.x()\n                y &#x3D; y + lineHeight + spaceY\n                nextX &#x3D; x + item.sizeHint().width() + spaceX\n                lineHeight &#x3D; 0\n\n            if not testOnly:\n                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))\n\n            x &#x3D; nextX\n            lineHeight &#x3D; max(lineHeight, item.sizeHint().height())\n\n        return y + lineHeight - rect.y()\n\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    app &#x3D; QApplication(sys.argv)\n    win &#x3D; QWidget()\n    _layout &#x3D; FlowLayout()\n    win.setLayout(_layout)\n    for i in range(10):\n        item1 &#x3D; QPushButton(&quot;%s&quot; % i)\n        win.layout().addWidget(item1)\n    win.show()\n    sys.exit(app.exec_())\n\n\n示例结果：\n \n","categories":["Qt","学习笔记"],"tags":["学习笔记","QT布局"]},{"title":"Maya_C++开发环境搭建","url":"/posts/20221031a1.html","content":"记录一下 Maya 的C++开发环境搭建\n软件准备\n安装Visual Studio 2017 作为IDE，这里需要注意一下，不同的VS版本对应不同的默认平台工具集，如果需要VS使用别的的平台工具集，需要修改安装指定的平台工具集.\n\n安装 Maya2020.\n\n获取软件版本对应的开发包（从Maya2016开始，maya软件安装包中不再携带开发包，而开发包作为一个单独的下载包存在）,也可以不下载开发包，C++ 环境搭建需要的 Lib 链接库和 include 头文件在软件安装目录中已经存在，但我们可以获取开发包里 devkit 文件夹中的代码示例和插件向导(MayaPluginWizard2.0.zip)用于学习.\n\nmaya 开发包下载地址 ：从这里下载\n\n\n\n配置环境手动配置  在 Visual Studio 2017 IDE 中新建一个”空项目”，然后点击项目,右键设置项目属性，将下列配置一一修改。\n\n配置：debug  平台：x64\n配置属性 》 常规 》 项目默认配置 》 配置类型 :动态库.dll\n配置属性 》 常规》 常规 》 目标文件拓展名 :.mll\nC&#x2F;C++ 》 常规 》 附加包含目录 :C:\\Program Files\\Autodesk\\Maya2020\\include;%(AdditionalLibraryDirectories)\nC&#x2F;C++ 》 预处理器 》 加入预处理器指令:WIN32;NDEBUG;_DEBUG;_WINDOWS;NT_PLUGIN;REQUIRE_IOSTREAM;_USRDLL;MAYAPLUGIN1_EXPORTS; \n链接器 》 常规 》 输出文件：C:\\Users\\mirror\\Documents\\maya\\2020\\plug-ins$(ProjectName)$(TargetExt)(自定义，这是你的插件生成的位置)\n链接器 》 常规 》 附加库目录：C:\\Program Files\\Autodesk\\Maya2020\\lib;%(AdditionalLibraryDirectories)\n链接器 》 输入 》 附加依赖项：Foundation.lib;OpenMaya.lib;OpenMayaUI.lib;OpenMayaAnim.lib;OpenMayaFX.lib;OpenMayaRender.lib;Image.lib;opengl32.lib;glu32.lib;\n\n  若为配置方案指定名称，如”maya2020”，将上列的 maya2020 替换成maya${Configuration},其中 ${Configuration} 是配置方案的名称，可快捷切换开发环境，而不用重新配置。  $(TargetDir)是在目标文件后自动赋予值为文件所在位置  $(TargetExt)目标文件拓展名  $(ProjectName)项目名\n通过插件向导配置  \n  在下载好的开发包中找到插件向导文件夹–pluginwizard，其中有两个文件：\n\nMayaPluginWizard2.0.zip\nMayaWizardReadme.txt  其中 MayaWizardReadme.txt 会告诉你官方推荐使用什么版本的 Visual Studio IDE 以及插件MayaPluginWizard2.0.zip中的内容的使用方法，例如，开发maya2020，应使用 Visual Studio 14.0 即 Visual Studio 2015(可以使用2017及其以上版本，然后配置2015的环境)默认的平台工具集；并且需要将对应的文件拷贝到指定的文件路径中。\n\n  由于我使用的是 Visual Studio 2019 需要将文件拷贝到不同的路径：\n\n将下列文件拷贝到路径(若没有，则新建):C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\IDE\\VC\\VCWizards\n\n\nMayaPluginWizard.ico\nMayaPluginWizard.vsdir\nMayaPluginWizard.vsz\n\n\n\n将下列文件夹拷贝到路径(若没有，则新建):C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\IDE\\VC\\vcprojects\n\n\nMayaPluginWizard\n\n\n\n\n  若在创建新项目的时候，创建项目失败，则需要将 MayaPluginWizard.vsz 文件内容中的 VS版本 改为 Visual Studio IDE 对应的版本  \n配置好后，编译的插件会出现在 “输出文件” 的路径中。\n软件安装踩坑  不同 Visual Studio 版本默认的平台工具集不同，需要视情况配置不同的工具集，Maya2020 C++ API 需要使用 Visual Studio 2017（前面的插件向导要求使用，Visual Studio 2015，这并不冲突）,因此会使用V140平台工具集，若使用高版本 Visual Studio ,需要切换平台工具集版本：\n\nVisual Studio 2019: V142\nVisual Studio 2017: V141\nVisual Studio 2015: V140\nVisual Studio 2013: V120\nVisual Studio 2012: V110\nVisual Studio 2010: V100\nVisual Studio 2008: V90\nVisual Studio 2005: V80\nVisual Studio 2003: V71\nVisual Studio 2002: V70\nVisual Studio 6: V60  若低版本软件安装不上，在卸载和清理了软件之后，可以尝试先安装高版本软件，再安装低版本软件，具体原因不清楚（可能是高版本软件在安装过程中将低版本报错的组件安装了），但是真的行得通。安装 Visual Studio IDE 软件需要给注册表开权限哦！！！\n\n安装平台工具集  升级打开低版本VS工程，需要切换工具集版本 和 windowos SDK版本\n\n修改&#x2F;添加 Visual Studio_IDE :\n\n  \n\n选择单个组件,并找到 MSVC v140-VS 2015 C++ 生成工具（v14.00）:  \n\n在项目属性中选取指定的工具集.png :  \n\n(略)若使用高版本打开低版本的项目，还需要重复以上步骤，安装&#x2F;切换对应低版本的 Windows SDK 版本 :  \n\n\n插件踩坑由于一开始不知道需要指定的工具集版本，导致编译的插件不能被加载，前前后后排查花费了大量时间，最后总结一下：\n\n编译好的文件如果从插件编辑器中无法显示：\n\n\n可能是开软件前，该插件的路径还没有生成,需要重启may.\n可能是插件不在Maya的插件搜索路径中,需要添加环境变量.\n插件本身有问题，需检查插件。\n\n\n\n如果无法加载插件，在保证插件代码正确的情况下，可能是没有使用正确的VC编译器，详细参照前文.\n\n\n\n\n\n","categories":["Maya","学习笔记"],"tags":["学习笔记","OpenMaya","C++"]},{"title":"Arnold开发环境搭建","url":"/posts/20221027a1.html","content":"1,下载安装vs2015\n下载地址：http://download.microsoft.com/download/B/8/9/B898E46E-CBAE-4045-A8E2-2D33DD36F3C4/vs2015.pro_chs.iso密钥：HM6NR-QXX7C-DFW2Y-8B82K-WTYJV2.下载安装Cmake &gt;&#x3D;2.8下载地址:https://cmake.org/download/3.配置cmake环境\nOSL材质\n简单的示例\n\nosl代码块shader gamma(  color Cin &#x3D; color(0, 0, 0),  float exponent &#x3D; 1,  output color Cout &#x3D; color(0, 0, 0)){  Cout &#x3D; pow(Cin, 1&#x2F;exponent);}\nosl代码块\n\n图形渲染大体原理观\n场景构成： 几何体基本体 光源 相机\n每一个几何体基本体 都携带一组几何体变量，也称为内插值或用户数据，有不同的方式添加该数据到几何体：单个几何体，单个面，多个面；如果着色器输入参数的名称和类型与对象上基元变量的名称和类型匹配（并且该输入参数尚未显式连接到另一个图层的输出），内插的原始变量将覆盖实例值或默认值\n每个几何图元都有一组属性（有时称为图形状态），包括其变换矩阵、照亮它的灯光列表（无论是单面还是双面）、着色器指定等。还可能有一长串与每个对象关联的渲染器特定属性或用户指定属性。特定属性状态可以在许多几何图元之间共享。\n曲面和体积着色器的闭包计算\n\n评估：给定输入和输出光方向，计算光从输入传播到输出的比例。\n采样：仅给定一个输入（或输出）方向，选择一个散射方向，其概率分布与最终将沿各个方向传播的光量成正比\n积分：给定所有灯光和视图方向，计算在视图方向上离开表面的光总量\n\n 集成器：渲染器包含许多集成器（可通过渲染器的 API 进行选择），这些积分器将表面和体积计算的颜色闭合与光源和视图相关信息相结合，以产生相机可见的光量。\n单位： 您可以告诉渲染器（通过全局选项）场景使用的距离和时间单位。然后着色器有一个名为 transformu（）的内置函数，它的工作方式很像 transform（），但它不是在坐标系之间进行转换，而是在单位之间进行转换。\n因此，您可以编写一个着色器以在真实世界单位中实现某种效果，并且该着色器在另一个使用不同建模单位的节目中完全可以重复使用。它知道所有的标准名称，如“cm”、“in”、“km”等，并且可以在任何这些名称之间以及命名的坐标系之间进行转换。\n词汇结构\n字符Open Shading Language的源代码由ASCII或UTF-8字符组成。\n空格、制表符、回车符和换行符统称为空白。空白字符分隔标识符、关键字或其他符号，但除此之外没有语法意义。一行中的多个空白字符等同于一个空白字符\n源代码可以分成多行，由行尾标记（回车符和&#x2F;或换行符）分隔。行可以是任何长度，行尾标记与其他空白没有明显区别，除非它们终止于 &#x2F;&#x2F; 的注释和分隔预处理器指令\n标识符\n标识符是变量、参数、函数和着色器的名称。在OSL中，标识符由一个或多个字符组成。第一个字符可以是字母（a-Z或a-Z）或下划线（_），随后的字符可以是字符、下划线或数字（0-9）\n注释\n和C++ 一样， OSL 也有两种注释方式 \n\n&#x2F;* 多行注释 *&#x2F; \n&#x2F;&#x2F; 单行注释\n\n关键字和保留字\n关键字和保留字不能作为标识符以下是在Open Shading Language中具有特殊含义的关键字：\n\nand break closure color continue do else emit float for if illuminance\nilluminate int matrix normal not or output point public return string\nstruct vector void while\n\n以下是目前在OSL中没有特殊含义的保留词，但我们保留它们以备将来使用，或者因为它们与相关编程语言中的关键字非常相似\n\nbool case catch char class const delete default double enum extern\nfalse friend goto inline long new operator private protected short\nsigned sizeof static switch template this throw true try typedef uniform\nunion unsigned varying virtual volatile\n\n预处理器\n着色器源代码通过标准C预处理器作为解析的第一步预处理器指令由哈希标记（#）指定为行上的第一个字符，后跟预处理器指令名称。哈希和指令名称之间可能会出现空白开放着色语言编译器支持C&#x2F;C++预处理指令的完整补充，包括：#define#undef#if#ifdef#ifndef#elif#else#endif#include#pragma error “message”#pragma once#pragma osl …#pragma warning “message”\n此外，编译器已经定义了以下预处理器符号：\nOSL VERSION MAJOR Major version (e.g., 1)OSL VERSION MINOR Minor version (e.g., 9)OSL VERSION PATCH Patch version (e.g., 3)OSL VERSION Combined version number &#x3D; 10000major + 100minor +patch (e.g., 10903 for version 1.9.3)\n粗略语法、着色器类型、参数\n着色器的总体结构如下：\n可选函数或结构声明着色器类型着色器名称（可选参数）代码块{声明}代码块\n请注意，语句可能包括函数或结构定义、局部变量声明或公共方法，以及普通执行指令（如赋值等）\n着色器类型\n着色器类型包括：曲面、置换、灯光、体积和常规着色器。某些操作只能在某些类型的着色器内执行（例如，在置换着色器中只能调用置换（）或更改P），而某些全局变量只能从某些类型的着色器内访问（例如，dPdu未在体积着色器内定义）以下是着色器的基本类型的简要描述\n曲面着色器\n曲面着色器确定曲面的基本材质特性及其对灯光的反应。他们负责计算描述材质的闭包颜色，并可选地设置其他用户定义的输出变量。它们可能不会改变曲面的位置。表面着色器的编写方式就好像它们描述了基元上单个点的行为，渲染器将选择必须评估着色器的位置表面。表面着色器还用于描述自发光对象，即光源。OSL 不需要单独的着色器类型来描述光源（光源即是着色器）\n置换着色器\n置换着色器更改位置和着色法线（或者，也可以选择仅更改着色法线），使几何体看起来变形、起皱或凹凸不平。它们是唯一允许更改基元位置的着色器。\n体积着色器\n体积着色器描述了参与介质（空气、烟雾、玻璃等）如何对光线做出反应并影响介质另一侧对象的外观。它们类似于表面着色器，不同之处在于可以从不位于任何特定基元（也不一定与任何特定基元相关联）的位置调用它们。\n着色器通用着色器\n通用着色器用于实用程序代码，通用例程可以作为着色器组中的各个层调用。常规着色器不需要指定着色器类型，因此可以从内部曲面、置换或体积着色器组中重复使用。但因此，它们可能不包含任何无法从所有着色器类型内部执行的功能（例如，它们可能无法更改P，这只能从置换着色器内部执行）\n着色器参数\n单个着色器具有（可选）许多参数，这些参数的值可以以多种方式设置，以便单个着色器在用于不同对象时具有不同的行为或外观。\n着色器参数语法\n着色器参数在着色器声明中指定，位于着色器名称后的括号中。这很像OSL函数（或C或类似语言中的函数）的参数，不同之处在于着色器参数必须具有初始值设定项，为参数提供默认值。Shader 参数默认初始值设定项可以是表达式（即，可以计算而不是限制为数字常量），并且按声明参数的顺序进行计算，并且可以包括对先前声明的参数的引用。形式上，简单参数声明的语法如下所示：\n\ntype parametername &#x3D; default-expression其中 type 是第 5 章中描述的数据类型之一，参数名称是参数的名称，默认表达式是有效的表达式（参见第 6.2 节）。多个参数仅用逗号分隔：\ntype parametername [ array-length ] &#x3D; { expr0 , expr1 … }其中数组长度是给出数组长度的正整数常数，初始值设定项是在大括号之间列出的一系列初始化表达式。第一个初始化表达式为数组的第一个元素提供初始化器，第二个表达式为数组第二个元素提供初始值设定器，依此类推。如果初始化表达式的数量小于数组的长度，则任何其他数组元素都将具有未定义的值。数组也可以在没有设置长度的情况下声明：\ntype parametername [ ] &#x3D; { expr0 , expr1 … }其中在方括号之间找不到数组长度。这表示数组的长度将基于从组中着色器的输出（采用该输出的长度）、实例值（采用实例值声明指定的长度）或基元变量（由其在基元上的声明确定的长度）在连接中传递的内容来确定。如果未提供实例值、原语值或连接，则初始化表达式的数量将决定数组的长度和默认值.结构参数也很容易声明：\nstructure-type parametername &#x3D; { expr0 , expr1 … }其中structure type是先前声明的结构类型的名称，expr初始值设定项对应于结构中的每个相应字段。结构的每个字段都需要适当类型的初始值设定项。\n\n着色器输出参数\n默认情况下，着色器参数在着色器主体中是只读的。然而，特殊的输出参数可能会因着色器的执行而改变。参数可以在参数的类型声明之前使用output关键字指定为输出：\n\noutput type parametername &#x3D; expr（输出参数可以是数组和结构，但我们将省略此处的明显语法。）\n\n输出参数可以连接到着色器组中稍后运行的着色器层的输入，可以由组中稍后的着色器通过消息传递（即getmessage（）调用）查询，或者由渲染器用作输出图像通道（以通过渲染器API描述的方式）。\n着色器参数示例\n下面是一个着色器声明的示例，包含几个参数：surface wood (    &#x2F;* Simple params with constant initializers &#x2F;        float Kd &#x3D; 0.5,        color woodcolor &#x3D; color (.7, .5, .3),        string texturename &#x3D; “wood.tx”,    &#x2F; Computed from an earlier parameter &#x2F;        color ringcolor &#x3D; 0.25 * woodcolor,    &#x2F; Fixed-length array &#x2F;        color paintcolors[3] &#x3D; { color(0,.25,0.7), color(1,1,1),        color(0.75,0.5,0.2) },    &#x2F; variable-length array &#x2F;        int pattern[] &#x3D; { 2, 4, 2, 1 },    &#x2F; output parameter *&#x2F;        output color Cunlit &#x3D; 0    ){…}\n着色器参数如何获取其值\n&#x2F;&#x2F;page 18\n","categories":[],"tags":[]},{"title":"自定义cryptomatteAov","url":"/posts/20221005a1.html","content":"通过 Arnold 渲染器的 crypmatte 节点和 Maya 的额外属性，在 Maya 中创建自定义 ID 通道。第一步：在物体的 mesh或aiStandIn等可着色对象上创建 maya 额外属性，此属性可被 Arnold 识别，命名方式为：mtoa_constant_”属性名”，其中mtoa_constant_为固定前缀，”属性名”为自定义名称，例如，mtoa_constant_testcrptomt。\n  \n \n第二步：创建自定义 aov, aov 命名的方式为可任意命名，也可按照crypto_”aov 名称”的规范命名，其中“aov 名称”为自定义的名称，例如，crypto_test。\n\n第三步：创建 cryptomatte 节点，并在节点的 UserCryptoAov* 中填入第二步中aov的全名，在UserCryptoSrc* 中填入第一步中创建的属性名。\n\n第四步：将第三步创建的 cryptomatte 节点填入第二步创建的 aov 节点的 Shader 属性中。\n\n以上即可获取场景中的单个shape 模型的 cryptomatte 的 id aov 通道。\n\n","categories":["Maya","arnold"],"tags":["灯光合成","灯光","Aov","cryptomatte"]},{"title":"QT-QPainter","url":"/posts/20220914a1.html","content":"QPainter一般用于在绘制事件paintEvent()中执行低级绘制。常用功能：    QPainter().setRenderHint(QPainter.Antialiasing)     图像边缘抗锯齿    QPainter().setRenderHint(QPainter.TextAntialiasing) 文本边缘抗锯齿    QPainter().setRenderHint(SmoothPixmapTransform)     指示引擎应使用平滑pixmap变换算法绘制图片    QPainter().drawArc()    在起始角和最终角度之间画圆弧    QPainter().drawEllipse()    在指定矩形内画圆弧    QPainter().drawLine(intX1,intY1,intX2,intY2)    画直线    QPainter().drawPixmap()    绘制图像文件    QPainter().drawPolygon()    画绘制多边形    QPainter().setBrush()   设置画笔风格    QPainter().setPen()    设置笔的颜色大小和样式    QPainter().save()　保存 QPainter 的绘制状态    QPainter().restore()　恢复 QPainter 的绘制状态save() 用于保存 QPainter 的状态，restore() 用于恢复 QPainter 的状态，save() 和 restore() 一般都是成对使用的，如果只调用了 save() 而不调用 restore()，那么保存就没有意义了，保存是为了能恢复被保存的状态而使用的    QPainter().rotate(角度)　QPainter根据坐标轴旋转角度。默认左上角    QPainter().translate(x，y)　QPainter根据坐标轴旋转角度。默认从左上角移动多少位置，向下向右为正方向\nmaya中的示例：    # -*- coding: utf-8 -*-\n# !&#x2F;usr&#x2F;bin&#x2F;env python27\n# @Author: Mirror\n# @Time: 2022&#x2F;09&#x2F;08\n# description: 弹出工具小球\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport math\nimport time\nfrom pymel.core import *\nfrom maya import OpenMayaUI as omui\n\ntry:\n    from PySide2.QtGui import *\n    from PySide2.QtCore import *\n    from PySide2.QtWidgets import *\n    from shiboken2 import wrapInstance\n\n    mayaMainWindowPtr &#x3D; omui.MQtUtil.mainWindow()\n    mayaMainWindow &#x3D; wrapInstance(long(mayaMainWindowPtr), QWidget)\nexcept:\n    from PySide.QtGui import *\n    from PySide.QtCore import *\n    from shiboken import wrapInstance\n\n    mayaMainWindowPtr &#x3D; omui.MQtUtil.mainWindow()\n    mayaMainWindow &#x3D; wrapInstance(long(mayaMainWindowPtr), QWidget)\n\nclass lighting_Tool_TopWindow(QWidget):\n    def __init__(self):\n        super(lighting_Tool_TopWindow, self).__init__(mayaMainWindow, Qt.Window | Qt.FramelessWindowHint)\n        self.flag &#x3D; 0\n        self.threadExits &#x3D; 0\n        self.setObjectName(&quot;lighting_Tool_TopWindow&quot;)\n        self.setAttribute(Qt.WA_TranslucentBackground)\n        self.setAttribute(Qt.WA_NoSystemBackground, False)\n        self.setStyleSheet(&quot;QWidget&#123;background:rgba(50,50,50,0)&#125;&quot;)\n\n        self.mytimer &#x3D; QTimer()\n        self.mytimer.timeout.connect(self.updateIcon)  \n        self.mytimer.start(1)\n\n        self.setGeometry(mayaMainWindow.x() + 400, mayaMainWindow.y() + 200, 60, 60)\n        self.show()\n\n    def updateIcon(self):  # 图标动态刷新\n        self.flag &#x3D; self.flag + 0.1\n        self.update()\n\n    def mouseMoveEvent(self, event):  \n        if event.buttons() &#x3D;&#x3D; Qt.LeftButton:\n            self.move(event.globalX() - self.piancha.x(), event.globalY() - self.piancha.y())\n\n    def mousePressEvent(self, event): \n        self.piancha &#x3D; event.pos()\n\n    def paintEvent(self, event):  \n        po &#x3D; QPainter(self)\n        po.setRenderHint(QPainter.Antialiasing)\n        po.setBrush(QBrush(QColor(200, 193, 170)))  # 背景颜色\n        toppen &#x3D; QPen()\n        toppen.setWidth(3)\n        toppen.setColor(QColor(250, 250, 250))  # 圆圈颜色\n        po.setPen(toppen)\n        po.drawEllipse(QRect(2, 2, 56, 56))  # 绘制圆圈大小\n        po.save()\n        po.restore()\n        rect &#x3D; QRect(-18, -18, 36, 36)\n        width &#x3D; 6\n        po.translate(30, 30)\n        po.rotate(self.flag)\n        for _num in range(4):\n            inside_pen &#x3D; QPen()\n            inside_pen.setWidth(width)\n            if _num &#x3D;&#x3D; 0:\n                inside_pen.setColor(QColor(180, 180, 180))  # 内圆圈颜色\n            elif _num &#x3D;&#x3D; 1:\n                inside_pen.setColor(QColor(120, 200, 100))\n            elif _num &#x3D;&#x3D; 2:\n                inside_pen.setColor(QColor(120, 100, 150))\n            elif _num &#x3D;&#x3D; 3:\n                inside_pen.setColor(QColor(120, 200, 200))\n            po.setPen(inside_pen)\n            po.drawArc(rect, 90 * 16 * _num, 60 * 16)  # 绘制圆圈大小\n        po.save()\n        po.restore()\n        po.rotate(self.flag)\n        po.drawImage(QRect(-18, -18, 36, 36), QImage(r&quot;S:\\rez\\packages\\tools\\Maya\\Tool_set\\otherstyle\\Wedges-7.7s-64px.0001.png&quot;))\n\n\n    def keyPressEvent(self, event):\n        if event.key() &#x3D;&#x3D; Qt.Key_Escape:\n            self.close()\n\ndef main():\n    for o in QApplication.topLevelWidgets():\n        if o.objectName() &#x3D;&#x3D; &quot;lighting_Tool_TopWindow&quot;:\n            o.deleteLater()\n    lightingTopBall &#x3D; lighting_Tool_TopWindow()\n\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    main()\n示例结果：\n \n","categories":["Qt","学习笔记"],"tags":["学习笔记","QT布局"]},{"title":"rez的PythonAPI使用","url":"/posts/20220901a1.html","content":"\n获取操作系统可用Shell类型from rez.shells import get_shell_typesget_shell_types()\n\n获取包请求命令import osos.environ[“REZ_USED_REQUEST”]\n\n\n","categories":["Rez"],"tags":["Pipeline","学习笔记","API"]},{"title":"Maya中创建UI","url":"/posts/20220823a1.html","content":"在maya中创建各种UI\n创建主菜单和菜单项：menuItem() 若不指定父级,都默认将菜单项添加到上一个创建的菜单中。\n\n示例代码：\n  import maya.cmds as cmds \ncmds.menu( &quot;test&quot;,label&#x3D;&#39;流程框架&#39;, tearOff&#x3D;True,parent&#x3D;&quot;MayaWindow&quot; )\ncmds.menuItem( label&#x3D;&#39;New&#39; )\ncmds.menuItem( label&#x3D;&#39;Open&#39; )\ncmds.menuItem( label&#x3D;&#39;Save&#39; )\ncmds.menuItem( divider&#x3D;True )  # 分隔线\ncmds.menuItem( label&#x3D;&#39;print&#39;,c&#x3D;&quot;print(11111)&quot; )\n\n创建菜单集菜单集中的菜单项来自于上面创建的主菜单，因此需要有菜单项才能添加和显示菜单集。空的菜单集不在菜单集的下拉框中显示，因此菜单集下至少应该拥有一项菜单项。\n\n示例代码：\n  import maya.cmds as cmds \ncmds.menuSet( &#39;testSet&#39;, label&#x3D;&#39;testSetLabel&#39; )  # 创建菜单集,不指定标签，显示为空行\ncmds.menuSet(am&#x3D;&quot;mainKeysMenu&quot;)  # 从当前菜单添加\ncmds.menuSet(cms&#x3D;1,q&#x3D;1 ) #  设置当前激活的菜单，只是激活，不刷新显示\ncmds.menuSet (ams&#x3D;True,q&#x3D;True)  # 所有的菜单集\ncmds.menuSet(rm&#x3D;&quot;mainKeysMenu&quot;)  # 从当前菜单移除\ncurrentmenus &#x3D; cmds.menuSet(query&#x3D;True, menuArray&#x3D;True)  # 查询当前流单集中所有的菜单项\n\n创建状态栏菜单状态行只需要为控件指定父级窗口为”statusFieldButton”即可。\n  \n示例代码：\n  import maya.cmds as cmds \ncmds.iconTextButton(&quot;状态行名称1&quot;,l&#x3D;&quot;标签1&quot;,style&#x3D;&quot;textOnly&quot;,al&#x3D;&#39;center&#39;,p&#x3D;cmds.iconTextButton(&quot;statusFieldButton&quot;,q&#x3D;1,p&#x3D;1))\ncmds.button(&quot;状态行名称2&quot;,l&#x3D;&quot;标签2&quot;,al&#x3D;&#39;center&#39;,p&#x3D;cmds.iconTextButton(&quot;statusFieldButton&quot;,q&#x3D;1,p&#x3D;1))\ncmds.nodeIconButton(&quot;状态行名称3&quot;, label&#x3D;&quot;标签3&quot; , style&#x3D;&#39;iconAndTextHorizontal&#39;, command&#x3D;&#39;cmds.spotLight()&#39;, image1&#x3D;&#39;spotlight.png&#39;,p&#x3D;cmds.iconTextButton(&quot;statusFieldButton&quot;,q&#x3D;1,p&#x3D;1))\n\n创建侧栏工具页侧栏工具页通过 toolBar 控件生成，创建后可指定吸附到边界上。\n  \n示例代码：  import maya.cmds as cmds \nmyWindow&#x3D;cmds.window()\nbuttonForm &#x3D; cmds.formLayout( parent &#x3D; myWindow)\ncmds.button( parent &#x3D; buttonForm,l&#x3D;&quot;testSide&quot;)\ncmds.toolBar( area&#x3D;&#39;top&#39;, content&#x3D;myWindow, allowedArea&#x3D;[&#39;top&#39;, &#39;bottom&#39;, &quot;left&quot;, &quot;right&quot;])\n创建工具架分页：工具架分页由cmds.shelfLayout()创建，将创建的工具架分页的父级指向shelf主窗口，然后在shelfLayout下创建工具按钮即可：\n  \n示例代码：  import maya.mel as mm\nimport maya.cmds as cmds\n\nmainTopShelfTab &#x3D; mm.eval(&#39;global string $gShelfTopLevel;string $a&#x3D;$gShelfTopLevel;&#39;)# 获取工具架顶级布局\nnewShelfLayout &#x3D; cmds.shelfLayout(&quot;NewLayout&quot;,p&#x3D;mainTopShelfTab)  # 创建工具架分页\nnewToolButton &#x3D; cmds.shelfButton(&quot;testShelf&quot;,docTag&#x3D;u&quot;测试工具&quot;,rpt&#x3D;1,l&#x3D;&quot;工具&quot;,i1 &#x3D; r&quot;S:&#x2F;icon&#x2F;TDtool.ico&quot;,iol&#x3D;&quot;工具&quot;,c&#x3D;&#39;print(u&quot;测试&quot;)&#39;,p&#x3D;newShelfLayout)  # 添加工具按钮\n一些常用代码：  mainTopShelfTab &#x3D; mm.eval(&#39;global string $gShelfTopLevel;string $a&#x3D;$gShelfTopLevel;&#39;)  # 获取工具架顶级布局\nshelfnum &#x3D; cmds.shelfTabLayout(mainTopShelfTab,q&#x3D;1,numberOfChildren&#x3D;1)  # 获取指定工具架窗口的工具数量\nshelfTools &#x3D; cmds.shelfTabLayout(mainTopShelfTab,q&#x3D;1,ca&#x3D;1) # 获取工具架上所有工具栏\nshelf_fullname &#x3D; cmds.shelfLayout(shelfTool[2],q &#x3D; 1,fpn &#x3D; 1)  # 获取指定名称的工具架全路径\nshelfVisible &#x3D; cmds.shelfButton(&quot;testShelf&quot;,e&#x3D;1,visible&#x3D;0) # 设置工具按钮可见性\nmaya.mel.eval(&#39;addNewShelfTab &quot;test&quot;&#39;)  # 添加指定名称工具架页\nmaya.mel.eval(&#39;deleteShelfTab &quot;test&quot;&#39;)  #删除指定个名称工具架\n从maya文档中加载默认工具架及其按钮：  #注意此脚本会将一部分默认不加载的工具架也加载到maya工具架下 \ndef get_shelf():\n  &quot;&quot;&quot;获取maya安装目录下shelf&quot;&quot;&quot;\n  shelf_files &#x3D; []\n  maya_shelf_path &#x3D; &#39;&#123;&#125;&#x2F;scripts&#x2F;shelves&#39;.format(os.getenv(&#39;MAYA_LOCATION&#39;))\n  files &#x3D; os.listdir( maya_shelf_path)\n  if files:\n      for _file in files:\n          if &quot;_&quot; in _file and &quot;.&quot; in _file and &quot;.res.&quot; not in _file:\n              shelf_files.append(_file.split(&#39;.&#39;)[0].split(&#39;_&#39;)[-1])\n  return shelf_files\n\ndef load_shelf():\n  &quot;&quot;&quot;加载maya默认shelf&quot;&quot;&quot;\n\n  allShelfs &#x3D; mel.eval(&#39;shelfTabLayout -q -childArray $gShelfTopLevel&#39;) # 获取maya默认shelfs\n  maya_files &#x3D; get_shelf()\n  if maya_files:\n      for _shelf in maya_files:\n          if _shelf not in allShelfs:\n              mel.eval(&#39;loadNewShelf &quot;shelf_&#123;&#125;.mel&quot;;&#39;.format(_shelf))\n循环删除指定工具架下的按钮：  def remove button (self,shelf):\n    &quot;&quot;&quot;批量删除指定工具架下的工具&quot;&quot;&quot;&quot;\n    shelf_fullname &#x3D; cmds.shelfLayout (&quot;shelfname&quot;,q&#x3D;1,fpn&#x3D;1)\n   buttons &#x3D; cmds.shelfLayout(shelf_fullname,q &#x3D; 1,ca &#x3D; 1)\n    for _button in buttons:\n        button_fullname &#x3D; cmds.shelfButton(_button,q &#x3D;1,fpn &#x3D;1)\n        cmds.deleteUI( button_fullname)\n删除指定的工具架，方法改自deleteShelfTab，会删除一些首选项中存储的变量：\nimport os\nimport maya.cmds as cmds\nimport maya.mel as mm \n\n\ndef remove_shelf(_shelfname):\n    mainTopShelfTab &#x3D; mm.eval(&#39;global string $gShelfTopLevel;string $a&#x3D;$gShelfTopLevel;&#39;)\n    shelf_info &#x3D; &#123;i: _shelf for i, _shelf in enumerate(cmds.shelfTabLayout(mainTopShelfTab, q&#x3D;1, ca&#x3D;1)) \n                  if _shelf.split(&quot;|&quot;)[-1].startswith(_shelfname[:2])&#125;\n    shelfnum&#x3D; cmds.shelfTabLayout(mainTopShelfTab, q&#x3D;1, numberofChildren&#x3D;1)\n    if shelf_info:\n        for _k,_v in shelf_info.items():\n            if _v &#x3D;&#x3D; _shelfname:\n                shelf_fullname &#x3D; cmds.shelfLayout(_v, q&#x3D;1, fpn&#x3D;1)\n                for _i in range(shelfnum):\n                    _align_c &#x3D; &quot;left&quot;\n                    if cmds.optionVar(ex&#x3D;&quot;shelfAlign&#123;&#125;&quot;.format(_i+1)):\n                        _align_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfAlign&#123;&#125;&quot;.format(_i+1))\n                    _shelfload_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfLoad&#123;&#125;&quot;.format(_i+1))\n                    _shelfname_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfName&#123;&#125;&quot;.format(_i+1))\n                    _shelffile_c &#x3D; cmds.optionVar(q&#x3D;&quot;shelfFile&#123;&#125;&quot;.format(_i+1))\n                    cmds.optionVar(\n                        iv&#x3D;(&quot;shelfLoad&#123;&#125;&quot;.format(_i+1), _shelfload_c),\n                        sv&#x3D;[(&quot;shelfAlign&#123;&#125;&quot;.format(_i+1), _align_c),\n                            (&quot;shelfName&#123;&#125;&quot;.format(_i+1), _shelfname_c),\n                            (&quot;shelfFile&#123;&#125;&quot;.format(_i+1), _shelffile_c)\n                            ])\n                cmds.optionVar(remove &#x3D;[&quot;shelfLoad&#123;&#125;&quot;.format(_k),\n                                        &quot;shelfAlign&#123;&#125;&quot;.format(_k),\n                                        &quot;shelfName&#123;&#125;&quot;.format(_k),\n                                        &quot;shelfFile&#123;&#125;&quot;.format(_k)\n                                        ])\n                cmds.deleteUI(shelf_fullname, layout&#x3D;1)\n                shelfDir &#x3D; cmds.internalVar(ush&#x3D;1)\n                shelfFile &#x3D; os.path.join(shelfDir, &quot;shelf_&#123;&#125;.mel&quot;.format(_v))\n                if os.path.exists(shelfFile):\n                    os.remove(shelfFile)\n  \n\n\n删除UI删除UI需要知道窗口的窗口名称：\nimport maya.cmds as cmds \ncmds.deleteUI(&quot;windowName&quot;)\n","categories":["Maya","小工具"],"tags":["学习笔记","QT事件"]},{"title":"Python代码中的字符编码","url":"/posts/20220822a1.html","content":"Python 中的字符编码 \n文本编辑器存储信息的过程\n打开编辑器就在内存中开辟了一个空间，用编辑器编写的内容暂存在内存中，断电会丢失。\n\n保存时，编辑器把内存的Unicode数据通过某种编码格式存到了硬盘上。\n\n编写.py文件（没有执行时）和编写其他文件没有区别，只是在写一堆字符。\n\n\npython解释器解释python代码的流程\npython解释器启动，相当于启动了一个文本编辑器。\n\npython解释器相当于文本编辑器，打开test.py文件，从硬盘将test.py文件通过某种编码格式（gbk,utf8等）解码数据从硬盘读入到内存中（python的解释性决定了解释器只关心文件的内容，不关心文件的后缀）。\n\npython解释器解释执行加载到内存中的test.py代码。在该阶段才会识别python语法，为变量值等开辟存储空间。\n\n\nPython2和Python3的区别\npython2有两种存储形式，第一种：Unicode；第二种：按coding头选择存储格式，假设python2用utf8存储 x&#x3D;’中文’，当你print(x)的时候，终端接收gbk的变量x，但是windows终端编码是utf8，会乱码。Python3 默认存储形式为utf-8。\n\n字符串类型：Python2 unicode 和 str类型（gbk、utf-8、MP4、MP3、JPG）；Python3 str（Unicode字符串）和bytes类型（（gbk、utf-8、MP4、MP3、JPG））。\n\npython3只有Unicode一种存储变量的形式。Python2中默认使用ascii，Python3中默认使用utf-8，部分文本编辑器编写的文件默认为gbk编码格式，需要注意编写代码时文本编辑器的默认编码格式。\n\nPython2 解释器编码默认为ASCII，只能处理 ascii字符，如果代码中有中文会报错，所以需要在代码顶部添加下面一行声明，将代码文件编码声明修改为 utf-8。Python3 解释器默认编码为utf-8;可通过 sys.getdefaultencoding() 查询。\n  # -*- coding:utf-8 -*-\nprint(u&quot;测试中文打印&quot;.encode(&quot;gbk&quot;))\n\n文件编码  当字符串第一次写入文件时，文件创建成功，文件编码和字符串编码保持一致。如果后续写入其他编码的字符串，则文件编码会被修改，原来的数据会出现乱码。\n总结\npython bytes 也称字节序列，并非字符。取值范围 0 &lt;&#x3D; bytes &lt;&#x3D; 255，输出的时候最前面会有字符b修饰；string 是python中字符串类型;\n\nbytes主要是给在计算机看的，string主要是给人看的；string经过编码encode，转化成二进制对象，给计算机识别；bytes经过解码decode，转化成string，让我们看，但是注意反编码的编码规则是有范围,\\xc8就不是utf8识别的范围；\n\n内存中固定使用Unicode编码，我们只能改变存储到硬盘时使用的编码格式。读文件时，读取文件采用的编码格式与文本原来的编码格式不同则会导致出现乱码。需注意文本编辑器的编码格式，这能直接影响编译器是否能正确编译程序文本文件。同时也要注意控制台的编码格式，其中Windows 默认的编码格式为gbk，因此某些字符需要转码后打印在控制台才不会是乱码：\n  # -*- coding:utf-8 -*-\nprint(u&quot;测试中文打印&quot;.encode(&quot;gbk&quot;))\nprint(unicode(&quot;测试中文打印&quot;，&quot;utf-8&quot;).encode(&quot;gbk&quot;))\n\n任何语言、任何操作系统、任何编码，都可以和Unicode编码通过decode()和encode()的方式互相转换。\n\n\n参考1.Python的字符编码问题\n\n2.bytes()内建函数\n\n","categories":["Python"],"tags":["学习笔记","锦囊小妙招"]},{"title":"Lua脚本语言","url":"/posts/20220821a2.html","content":"脚本语言--Lua学习笔记。\n\n\n参考菜鸟教程：https://www.runoob.com/lua/lua-tutorial.html\n","categories":["Doc","学习笔记"],"tags":["学习笔记"]},{"title":"Yeti毛发","url":"/posts/20220821a1.html","content":"本文记录了一些Maya中Yeti毛发的相关的问题：\n安装\n对应的版本: yeti插件版本需要与arnold(或redshift渲染器)版本、maya版本相对应，否则不报错且无法使用\n\n环境变量：需在 pgYetiMaya.mod写入环境变量的文件(一行一句)。C:\\rlm\\yeti.lic 为破解文件。\n\n\npgYetiMaya 3.6.0 C:\\Yeti-v3.6.0_Maya2018-windows\n\n\nPATH +:&#x3D; bin\nMTOA_EXTENSIONS_PATH +:&#x3D; plug-ins\nARNOLD_PLUGIN_PATH +:&#x3D; bin\nYETI_DOCS +:&#x3D; docs\nYETI_TMP &#x3D; C:\\Yeti-v3.6.0_Maya2018-windows\\tmp\nPEREGRINE_LOG_FILE &#x3D; C:\\Yeti-v3.6.0_Maya2018-windows\\Yeti.log\nYETI_GEOCACHE_SIZE &#x3D; 1024\nYETI_TEXTURECACHE_SIZE &#x3D; 1024\nYETI_HOME &#x3D; C:\\Yeti-v3.6.0_Maya2018-windows\nperegrinel_LICENSE &#x3D; C:\\rlm\\yeti.lic\n\n\n破解：yeti破解文件或通过rlm服务器破解\n\n\n可能的问题\nyeti 与Arnold版本不匹配，需要下载相对应的各插件版本，具体参考yeti官网文档\nyeti安装后未破解，打开yeti graph editer时会提示没有许可或工具不显示\nyeti破解后没有成功建立和渲染器的链接，需要在上述对应的.mod文件中写入环境变量,成功写入环境变量后即可渲染\nyeti插件与渲染器成功建立来链接后，开启Maya可能会出现.dll文件的报错没然后Maya卡死，该问题是maya环境中没有找到.dll与对应的渲染器，可能是没有安装，删除yeti安装目录文件夹bin下对应的.dll即可\n渲染没有毛发：渲染器和yeti插件的链接没有接上。没有指定Yeti毛发缓存的存放路径YETI_TMP\n“pgYetiMaya.mod”文件中不能有空行\n\n制作和渲染问题\npgYetiPreRender:此代码用于指定yeti渲染前产生的yeti缓存文件存放位置，渲染时直接调用此路径下的.fur文件，若不在Maya渲染射中的中preRenderMel选项中填入此代码，则渲染器找不到生成的缓存，渲染失败。低版本中，此代码不会自动写入和自动清除，高版本会判定场景中是否存在相关yeti节点，然后自动写入或清除。\n\nyeti毛发取消缓存(将input Mode 设置为None)，需要保存后重开文件，才能正常渲染出毛发。\n\n\n","categories":["Maya","杂项"],"tags":["Yeti"]},{"title":"ShotGrid的API使用示例","url":"/posts/20220814a1.html","content":"本文为 ShotGrid 的 Python API 学习笔记。\n\n注册网站如果已经有了自己可操作的 ShotGrid 网站页面，就直接开始吧。没有的话需要在 Autodesk 官网下找到ShotGrid 注册自己的 ShotGrid 网站页面，设置邮箱和电话号码后，获取登录账户和密码（可以获得30天的试用时间），就可以开始下面的操作了。\n安装最低要求\nPython 2.7 或 Python 3.7\n\n下载并写入Python搜索路径\n手动下载\n下载 PythonAPI 库到本地：从这下载最新版本到本地。\n将下载的 PythonAPI 加入到 PYTHONPATH 环境变量中，用于我们在代码中可搜索到对应的模块。\n\n\npip下载\n安装最新版本pip install git+https:&#x2F;&#x2F;github.com&#x2F;shotgunsoftware&#x2F;python-api.git\n安装特定版本pip install git+https:&#x2F;&#x2F;github.com&#x2F;shotgunsoftware&#x2F;python-api.git@v3.0.26\n\n\n\n登录直接使用用户名和密码，用户身份登录的脚本操作，会生成事件，其中存储了一些额外的元数据，EventLogEntry用于标识事件是由代表用户的脚本创建的。而使用脚本身份验证登录前，必须在Shotgun 中注册 (User&gt;Scripts)并具有有效的 API 密钥 (密钥需要在创建的时候记录下来，创建完后不再显示).\n\n基于用户名登陆验证\nsg &#x3D; shotgun_api3.Shotgun(&quot;https:&#x2F;&#x2F;piedpiper.shotgunstudio.com&quot;,\n                        login&#x3D;&quot;rhendriks&quot;,\n                        password&#x3D;&quot;c0mPre$Hi0n&quot;)\n\n基于脚本登录验证\nsg &#x3D; shotgun_api3.Shotgun(&quot;https:&#x2F;&#x2F;piedpiper.shotgunstudio.com&quot;,\n                        script_name&#x3D;&quot;rhendriks&quot;,\n                        api_key&#x3D;&quot;c0mPre$Hi0n&quot;)\n\n查询内容查询结果默认返回查询对象的id,字段中的实体通过id连接，如果使用实体作为过滤项（过滤条件有大括号），每个filter中的实体都应该包含实体的id，这个实体用于筛选查询的范围，那么必须使用实体的id进行过滤，不能使用名称或其他条件，例如[ “shot”,”is”,{“type”:”Shot”,”id”:1173}]；如果过滤项不是实体，那么可以使用名称或其他字段进行过滤，但必须使用点语法（链式调用），例如[ “shot.Shot.code”,”is”,”seq110”]。点语法用于查询点语法中使用的实体以外的实体，例如，project.Project.name为点语法的项目名，只能通过项目名查场次和镜头等，不能用它查询项目本身。查询本身不用点语法，直接使用shotgun.find(“Project”,[ “name”，”is”，”Test_Fly”],[])；点语法：”fieldname.entityname.fieldname.entityname.fieldname…” 只能单实体关系使用语法，由于性能问题，一个字段链接了多个实体时，不能通过点语法获得结果，需要遍历获取。不显示字段代码名称的字段，可以从filed &gt; 右键菜单 &gt; ConfigField 中获取field code名称\n\n查询所有项目\nsg_project &#x3D; sg.find(&quot;Project&quot;, [], [&quot;id&quot;, &quot;name&quot;])\n\n查询指定名称的项目(默认返回id)\nsg_project &#x3D; sg.find(&quot;Project&quot;, [[&#39;name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])\n\n查询指定项目所有的场次(通过项目id获取，可直接使用查询到的实体获取相关内容)\nsg_project &#x3D; sg.find(&quot;Project&quot;, [[&#39;name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])[0][&quot;id&quot;]\nsg_sequence &#x3D; sg.find(&quot;Sequence&quot;, [[&#39;project&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: sg_project&#125;]])\n\n查询指定项目的场次(通过项目名称获取,使用点语法)\nsg_sequence &#x3D; sg.find(&quot;Sequence&quot;, [[&#39;project.Project.name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])\n\n获取指定项目的所有镜头(通过项目名称获取)\nsg_shot &#x3D; sg.find(&quot;Shot&quot;, [[&#39;project.Project.name&#39;, &#39;is&#39;, &quot;Test_Fly&quot;]])\n\n获取指定场次的所有镜头(通过场次id获取)\nsg_shot1 &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;, &quot;is&quot;, &#123;&quot;type&quot;:&quot;Sequence&quot;, &quot;id&quot;:44&#125;]], [ &quot;code&quot;])\n\n获取指定场次的状态为IP所有镜头(通过场次id获取)\nsg_shot2 &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;,&quot;is&quot;, &#123;&quot;type&quot;:&quot;Sequence&quot;,&quot;id&quot;:44&#125;]，[&quot;sg_status_list&quot;, &quot;is&quot;, &quot;ip&quot;]],[ &quot;code&quot;])\n\n获取指定场次的状态为IP所有镜头(通过场次名称和项目共同筛选获取)\nsg_shot3 &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Sequence&quot;,&quot;Sequence Name&quot;:&quot;seq001&quot;&#125;],[&quot;sg_status_list&quot;, &quot;is&quot;, &quot;ip&quot;], [&#39;project&#39;, &#39;is&#39;,&#123;&#39;type&#39;:&#39;Project&#39;,&#39;id&#39;:122&#125;]])\n\n获取指定场次的状态为IP所有镜头(通过场次名称和项目共同筛选获取)\nsg_shots &#x3D; sg.find(&quot;Shot&quot;, [[&quot;sg_sequence&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Sequence&quot;,&quot;Sequence Name&quot;:&quot;seq001&quot;&#125;],[&quot;sg_status_list&quot;, &quot;is&quot;, &quot;ip&quot;], [&#39;project&#39;, &#39;is&#39;,&#123;&#39;type&#39;:&#39;Project&#39;,&#39;id&#39;:122&#125;]])\n\n获取指定镜头的资产\nproject_id &#x3D; 122\nsequence_id &#x3D; 182\nfilter &#x3D;  [\n  [&#39;project&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: project_id&#125;],\n  [&#39;sg_asset_type&#39;, &#39;is&#39;, &#39;Character&#39;],\n  [&#39;sequences&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Sequence&#39;, &#39;id&#39;: sequence_id&#125;]] \nfields &#x3D; [&#39;id&#39;, &#39;code&#39;, &#39;sg_asset_type&#39;]\nasset &#x3D; sg.find(&quot;Asset&quot;, filter, fields)\n\n获取指定类型的资产\nfields &#x3D; [&#39;id&#39;, &#39;sg_asset_type&#39;, &#39;code&#39;]\nfilters &#x3D; [\n  [&#39;project&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;:122&#125;],\n  [&#39;sequence&#39;, &#39;is&#39;, &#123;&#39;type&#39;: &#39;Sequence&#39;, &#39;id&#39;: 145&#125;],\n  [&#39;sg_asset_type&#39;, &#39;is&#39;, &#39;Character&#39;]]\nCharacter &#x3D; sg.find(&#39;Asset&#39;, filters, fields)\n\n计算指定Sequence里所有的任务数量，并找到其中最近截止日期\nentity_type&#x3D;&#39;Task&#39;\nfilter &#x3D; [[&#39;entity.Shot.sg_sequence&#39;, &#39;is&#39;, &#123;&#39;type&#39;:&#39;Sequence&#39;, &#39;id&#39;:2&#125;],[&#39;sg_status_list&#39;, &#39;is_not&#39;, &#39;na&#39;]]\nsummary_field &#x3D; [&#123;&#39;field&#39;:&#39;id&#39;, &#39;type&#39;:&#39;count&#39;&#125;,&#123;&#39;field&#39;:&#39;due_date&#39;,&#39;type&#39;:&#39;latest&#39;&#125;]\nresult &#x3D; sg.summarize(entity_type,filter,summary_field)\n#最近的截至日期，和当前场次所有任务的总数\n#&#123;&#39;groups&#39;: [], &#39;summaries&#39;: &#123;&#39;due_date&#39;: &#39;2013-07-05&#39;, &#39;id&#39;: 30&#125;&#125;  \n\n获取指定 Version id 的mov\nmov &#x3D; sg.find(&quot;Version&quot;, [&quot;id&quot;, &quot;is&quot;, 12321], [ &quot;sg_uploaded_movie&quot;])\n\n查询所有的工作流环节\npipeline &#x3D; shotgun.find(&quot;Step&quot;,[ ],[ &quot;code&quot;])\n\n查询指定工作流环节\nshotgun.find(&quot;Step&quot;,[ &quot;code&quot;，&quot;is&quot;，&quot;Animation&quot;],[])\n\n查询指定id的镜头\nshotgun.find(&quot;Shot&quot;,[ &quot;id&quot;，&quot;is&quot;，&quot;1207&quot;],[ &quot;code&quot;])\n\n获取指定镜头的指定环节的task信息（task是单独的，筛选它的link字段为entity，因此下面是筛选link字段中id为1207的镜头。注意，过滤器的第三项是要过滤的实体的话，必须使用实体id）\nshotgun.find(&quot;Task&quot;,[[ &quot;entity&quot;，&quot;is&quot;，&#123;&quot;type&quot;:&quot;shot&quot;,&quot;id&quot;:1207&#125;],[ &quot;shot&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Shot&quot;,&quot;id&quot;:1174&#125;],[ &quot;content&quot;,&quot;is&quot;,&quot;anim&quot;]],[])\n\n获取指定镜头、指定环节、指定名称的task信息\nshotgun.find(&quot;Task&quot;,[[ &quot;entity&quot;，&quot;is&quot;，&#123;&quot;type&quot;:&quot;shot&quot;,&quot;id&quot;:1207&#125;],[ &quot;shot&quot;,&quot;is&quot;,&#123;&quot;type&quot;:&quot;Shot&quot;,&quot;id&quot;:1174&#125;],[ &quot;content&quot;,&quot;is&quot;,&quot;anim&quot;]],[])\n\n下载mov下载指定 Version id 的mov  mov &#x3D; sg.find(&quot;Version&quot;, [&quot;id&quot;, &quot;is&quot;, 12321], [&quot;sg_uploaded_movie&quot;])\nlocalpath &#x3D; r&quot;E:\\temp&quot; + mov[&quot;sg_uploaded_movie&quot;][&quot;name&quot;]\nsg.download_attachment(version[&quot;sg_uploaded_movie&quot;], file_path&#x3D;local_file_path)\n创建内容\n创建镜头\nshotname &#x3D; &quot;test001&quot;\ndata &#x3D; &#123;\n  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,\n  &#39;sg_sequence&#39;: &#123;&#39;type&#39;: &#39;Sequence&#39;, &#39;id&#39;: 145&#125;,\n  &#39;code&#39;: shotname,\n  &#39;sg_status_list&#39;: &#39;ip&#39;\n&#125;\nshot &#x3D; sg.create(&#39;Shot&#39;, data)\n\n在镜头的pipeline步环节下创建task(一个流程环节可以有多个任务)\nanimationStepId &#x3D; 106\nshotId &#x3D; 1173 \ndata &#x3D; &#123;\n  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,\n  &#39;content&#39;: &#39;anim&#39;, # 任务名\n  &#39;step&#39;: &#123;&#39;name&#39;: &#39;Animation&#39;, &#39;type&#39;: &#39;Step&#39;, &#39;id&#39;: animationStepId&#125;,\n  &#39;entity&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: shotId&#125;\n&#125;\ntask &#x3D; sg.create(&#39;Task&#39;, data)\n\nTask下创建Version\n taskCode &#x3D; &#39;testVersion_v001&#39;\nshotId &#x3D; 1173 \ntaskId &#x3D; 5964\ndata &#x3D; &#123;\n  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,\n  &#39;code&#39; : taskCode,\n  &#39;sg_status_list&#39; : &#39;rev&#39;,\n  &#39;entity&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: shotId&#125;, \n  &#39;sg_task&#39;: &#123;&#39;type&#39;: &#39;Task&#39;, &#39;id&#39;: taskId&#125;, \n  &#39;user&#39;: &#123;&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 220&#125; # 创建Version的人员\n&#125;\nversion &#x3D; sg.create(&#39;Version&#39;, data)\n\n创建带有镜头和任务链接的版本\n shotID &#x3D; 1173\ntaskID &#x3D; 5964\n data &#x3D; &#123; &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;,&#39;id&#39;: 122&#125;,\n        &#39;code&#39;: &#39;100_010_anim_v1&#39;,\n        &#39;description&#39;: &#39;first pass at opening shot with bunnies&#39;,\n        &#39;sg_path_to_frames&#39;: &#39;&#x2F;v1&#x2F;gun&#x2F;s100&#x2F;010&#x2F;frames&#x2F;anim&#x2F;100_010_animv1_jack.#.jpg&#39;,\n        &#39;sg_status_list&#39;: &#39;rev&#39;,\n        &#39;entity&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;:  shotID&#125;,\n        &#39;sg_task&#39;: &#123;&#39;type&#39;: &#39;Task&#39;, &#39;id&#39;: taskID&#125;,\n        &#39;user&#39;: &#123;&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 165&#125; &#125;\n result &#x3D; sg.create(&#39;Version&#39;, data)\n \n\n使用任务模板创建任务\nfilters &#x3D; [[&#39;code&#39;,&#39;is&#39;, &#39;3D Shot Template&#39; ]]\ntaskTemplate &#x3D; sg.find_one(&#39;TaskTemplate&#39;, filters)  # 查找任务模板\ntaskId &#x3D; 5964\ndata &#x3D; &#123;&#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;,&#39;id&#39;: 122&#125;,\n      &#39;code&#39;: &#39;seq001_sc001&#39;,\n      &#39;description&#39;: &#39;creating a task with taskTemplate&#39;,\n      &#39;task_template&#39;: template &#125;\nresult &#x3D; sg.create(&#39;Shot&#39;, data)\n\n创建自定义实体 Entity(查找方式和查找别的实体一样)\ndata &#x3D; &#123;\n  &#39;project&#39;: &#123;&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 122&#125;,\n  &#39;code&#39;: &#39;test_plate_v001&#39;,\n  &#39;sg_shot&#39;: &#123;&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: 1173&#125;,\n  &#39;updated_by&#39;: &#123;&#39;type&#39;: &#39;Group&#39;, &#39;id&#39;: 3&#125;, # 更新用户为群组\n  &#39;sg_original_resolution&#39;: &#39;1920x1080&#39;,\n  &#39;sg_plate_type&#39;: &#39;BG01&#39;,\n  &#39;sg_frames_scanned&#39;: 150,\n  &#39;sg_scan_start&#39;: 1,\n  &#39;sg_scan_end&#39;: 150\n&#125;\nplate &#x3D; sg.create(&#39;CustomEntity10&#39;, data)\n\n上传缩略图\nversionID &#x3D; 214\npicPath &#x3D; &quot;&#x2F;v1&#x2F;gun&#x2F;s100&#x2F;010&#x2F;beauties&#x2F;anim&#x2F;100_010_animv1.jpg&quot;\nsg.upload_thumbnail(&quot;Version&quot;, versionID, picPath)\n\n更新内容\n更新镜头\nshotId &#x3D; 1173\ndata &#x3D; &#123;\n  &#39;description&#39;: &#39;Open on a beautiful field with fuzzy bunnies&#39;,\n  &#39;sg_status_list&#39;: &#39;ip&#39;\n  &#125;\nresult &#x3D; sg.update(&#39;Shot&#39;, shotId, data)\n\n更新Mov到镜头\nshotId &#x3D; 423\nmov_file &#x3D; &#39;&#x2F;data&#x2F;show&#x2F;ne2&#x2F;100_110&#x2F;anim&#x2F;01.mlk-02b.mov&#39;\nsg.upload(&quot;Shot&quot;, shotId, mov_file, field_name&#x3D;&quot;sg_latest_quicktime&quot;, display_name&#x3D;&quot;Latest QT&quot;)\n\n删除内容\n删除指定id的project实体\nsg_delete &#x3D; sg.delete(&quot;Project&quot;,155)\n\n删除指定镜头\nshotId &#x3D; 1173\nresult &#x3D; sg.delete(&quot;Shot&quot;,shotId)\n\n恢复内容\n恢复删掉的镜头shotId &#x3D; 1173\nsg.revive(&quot;Shot&quot;, shotId)\n\n批量处理（创建，删除，更新）镜头使用batch函数的任务，要么全部完成，要么全都不完成\n  batch_data &#x3D; []\nfor i in range(1,100):\n    data &#x3D; &#123;\n        &quot;code&quot;: &quot;shot_%04d&quot; % i,\n        &quot;project&quot;: project\n    &#125;\n    batch_data.append(&#123;&quot;request_type&quot;: &quot;create&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;data&quot;: data&#125;)\nsg.batch(batch_data)  \nbatch_data &#x3D; [\n  &#123;&quot;request_type&quot;: &quot;create&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;data&quot;: &#123;&quot;code&quot;: &quot;New Shot 1&quot;, &quot;project&quot;: project&#125;&#125;,\n  &#123;&quot;request_type&quot;: &quot;update&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 3624, &quot;data&quot;: &#123;&quot;code&quot;: &quot;Changed 1&quot;&#125;&#125;,\n  &#123;&quot;request_type&quot;: &quot;delete&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 3624&#125;\n]\nsg.batch(batch_data) # 三种不同类型可同时存在\n\n关闭链接  sg.close()\n\n部分可查询实体类型\n\n\n实体类型名称\n实体含义\n\n\n\nActionMenuItem\n动作菜单\n\n\nApiUser\n脚本\n\n\nAsset\n资产\n\n\nAttachment\n附件\n\n\nBooking\n人员规划\n\n\nCamera\n摄像机\n\n\nClientUser\n客户\n\n\nComposition\n合成\n\n\nCut\n剪辑镜头\n\n\nCutItem\n剪辑镜头项\n\n\nDelivery\n分发\n\n\nDepartment\n部门\n\n\nEpisode\n季\n\n\nEventLogEntry\n事件日志\n\n\nFilesystemLocation\n文件系统位置\n\n\nGroup\n组\n\n\nHumanUser\n人员\n\n\nIcon\n图标\n\n\nLevel\n关卡\n\n\nLocalStorage\n本地存储\n\n\nMocapPass\n动作捕捉过程\n\n\nMocapSetup\n动作捕捉设置\n\n\nMocapTake\n动作捕捉条目\n\n\nMocapTakeRange\n动作捕捉条目范围\n\n\nNote\n反馈，记录\n\n\nPage\n页面\n\n\nPageHit\n页面点击\n\n\nPageSetting\n页面设置\n\n\nPerformer\n演员\n\n\nPermissionRuleSet\n权限组设置\n\n\nPhase\n项目时间表\n\n\nPhysicalAsset\n实拍道具\n\n\nPipelineConfiguration\n工作流工序配置\n\n\nPlaylist\n播放表单\n\n\nPlaylistShare\n共享的播放表单\n\n\nProject\n项目\n\n\nPublishedFile\n已发布文件\n\n\nPublishedFileDependency\n已发布文件依存关系\n\n\nPublishedFileType\n已发布文件类型\n\n\nRelease\n软件发布版本\n\n\nReply\n回复\n\n\nRevision\n修正版本\n\n\nRoutine\n运动捕捉例程\n\n\nRvLicense\nRV许可证\n\n\nScene\n场\n\n\nSequence\n本\n\n\nShootDay\n拍摄日期\n\n\nShot\n镜头\n\n\nSoftware\nDCC软件\n\n\nStatus\n状态\n\n\nStep\n工作流工序\n\n\nTag\n标签\n\n\nTask\n任务\n\n\nTaskDependency\n任务依存关系\n\n\nTaskTemplate\n任务模版\n\n\nTicket\n软件开发工单\n\n\nTimeLog\n工时记录\n\n\nVersion\n版本\n\n\n参考文档ShotGrid API文档：https://developer.shotgridsoftware.com/python-api/用户帮助文档：https://shotgunsoftware.zendesk.com/hc/zh-cn站点状态查询网站：https://status.shotgridsoftware.com/shot教学视频：https://space.bilibili.com/399556599\n","categories":["ShotGrid","学习笔记"],"tags":["Pipeline","学习笔记","API"]},{"title":"Nuke学习笔记4_回调函数","url":"/posts/20220807a1.html","content":"Nuke学习笔记 \nNuke API 文档\n本地文档：C:\\Program Files\\Nuke12.2v2\\Documentation\n在线文档：https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html\nNuke Python Developers Guide: 案例教程\nPython Scripting Reference： API 参考文档\nTCL Scripting Reference: TCL 表达式参考文档\n\n\n\n回调函数部分回调函数的使用\n\n添加回调函数\nnuke.toNode(“节点名”)[“knobChanged”].setValue(回调函数) 仅对选择的节点生效，此处回调函数是字符串格式\nnuke.addOnCreate(callable,args&#x3D;(),kwargs&#x3D;{},nodeClass&#x3D;”*”)\ncallable 可调用对象\nargs 不定长位置参数列表\nkwargs 不定长关键字参数字典\nnodeClass 默认值是星号，指无论当前节点是什么，在事件发生时都会执行这个回调函数，需自定义\n\n\n删除回调函数\n事件函数\nknobChanged 用户在打开的面版中改变knob后执行事件，可实现联动事件\n\nnuke.thisNode() 该控件在打开、关闭面板或输入端改变时，分别指向showPanel、hidePanel、inputChange事件，这三个控件使用代码获取不到，但可以在knobChange中使用控件名def testevent():\n    &quot;&quot;&quot;如果打开面板，打印内容&quot;&quot;&quot;\n    k&#x3D;nuke.thisKnob()\n    if k.name() &#x3D;&#x3D; &quot;showPanel&quot;:\n        print(&quot;show&quot;)\nnuke.addKnobChanged(testevent, nodeClass&#x3D;&quot;NoOp&quot;)\n\n\nupdateUI 任意UI发生变化后触发，比knobChange优先级低，不应在其中添加任何和回调结构有关的操作\n\nautolabel 在updateUI之后执行，用于为节点设置在Node Grape中显示的文本 ，按照函数添加的顺序，从后往前执行，只要那个函数的返回值不是None，那么这个返回值就用于该节点的显示文本，若没有返回值或返回值为None,则使用节点名显示，该显示的文本和label标签不同。\n\n\n\n\n回调函数执行顺序：可以通过控件设置的回调函数 &gt; 使用注册回调函数添加的回调函数使用注册回调函数添加的回调函数的优先级依赖注册的先后顺序，并先执行指定了nodeClass参数的回调，再执行满足所有类型的回调。addAutolabel()和addFilenameFilter()是特里，它们恰恰与之相反。onCreate 对于Group节点，会先执行其中的内部节点，然后再在Group节点上执行一遍回调onDestory事件和onCreate事件相反onUserCreate执行优先级 &gt; onCreate执行优先级 \n部分回调函数\n\n\n","categories":["Nuke","学习笔记"],"tags":["学习笔记"]},{"title":"Nuke学习笔记3_菜单的加载和界面","url":"/posts/20220801a1.html","content":"Nuke学习笔记 \nNuke API 文档\n本地文档：C:\\Program Files\\Nuke12.2v2\\Documentation\n在线文档：https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html\nNuke Python Developers Guide: 案例教程\nPython Scripting Reference： API 参考文档\nTCL Scripting Reference: TCL 表达式参考文档\n\n\n\n工具加载开启 nuke 时，系统会加载两个安装目录的Plugins文件夹下的两个文件：\n\ninit.py : 用于Nuke的环境设置、系统选项和默认参数，不能包含任何界面相关操作，命令行模式和GUI模式下均加载。\nmenu.py ：用于跟界面相关的设置、自定义菜单、工具架，仅GUI模式加载。位于用户文件夹下存放用户预设的.nuke文件夹，其下的init.py和menu.py用于存放用户预设。\n\n加载工具方式\n\n加载工具不运行：仅需要在init.py导入模块的主函数即可，再通过工具界面去调用主函数\n\n加载工具相关函数\n获取插件和图标的搜索路径 nuke.pluginPath()\n向系统搜索路径添加路径到开头,并加载路径下的init.py nuke.pluginAddPath(“pathstr or pathList”)\n向系统搜索路径添加路径到结尾,但不加载路径下的init.py nuke.pluginAppendPath(“pathstr or pathList”)\n检测指定的函数或插件是否存在 nuke.pluginExists(“pluginName or path or fileName”)\n返回所有已经加载的插件的文件路径列表 nuke.pligins(num,”re表达式过滤”，”re表达式过滤”，…)  num为 0，1，2，3\n\nNuke环境变量NUKE_PATH、OFX_PLUGIN_PATH都是列表后面的路径先加载，以反向解析加载路径的方式进行的，因此涉及继承和覆盖的通用配置需要放在列表后面，特殊和本地的配置放在列表开头。nuke.pluginPath是正向解析加载方式。\n\nNUKE_PATH 搜索 Nuke 的init.py 和menu.py文件的路径，可以将插件放在不同的位置，并且每一个插件都有各自的init.py和menu.py文件，就不用将所有插件都写入 .nuke 文件夹下的文件中，实现分布式管理\nOFX_PLUGIN_PATH 用来设置和加载ofx插件的位置，指向ofx的安装路径\n\n自定义菜单常用类型Nuke的菜单界面和Qt是两套体系,Nuke 界面不属于Qt范畴\n\n菜单栏工具\nnuke.menu(“Nuke”)\n\n\n工具栏工具\nnuke.menu(“Nodes”)\n\n\nNodeGraph中右键工具\nnuke.menu(“Node Graph”)\n\n\n\n自定义菜单函数\nnuke.Menu 菜单类型\n\nnuke.menu(“Nuke”).findItem(“菜单项名称”) 查找指定菜单项 \n菜单项名称可以是相对于顶级菜单项的名称 nuke.menu(“Nuke”).findItem(“菜单项1&#x2F;菜单项2&#x2F;菜单项3”)\n\n\nnuke.menu(“Nuke”).menu(“菜单项名称”) 查找指定菜单项\nnuke.Menu.items() 返回查询到的菜单项\nnuke.menu(“Nuke”).addMenu(“新加项”，icon&#x3D;””,tooltip&#x3D;””,index&#x3D;””) 创建新菜单，其中新加项也是相对路径，index添加位置，默认为-1，只对要添加的最后一级菜单项有效  \nnuke.menu(“Nuke”).addcommand(“新加项”,”脚本字符串”，“快捷键”，”icon”,”tooltip”，”index”) 添加菜单项命令，其中 “脚本字符串”可以为可执行的Python语句，或lambda函数，若没有指定命令，则会默认为创建一个名为新加项的节点。\nnuke.menu(“Nuke”).removeItem(“删除项”) 删除指定的菜单，其中删除项不为相对路径，要删除指定项，需要从指定级的上一级删除，空菜单会自动删除\nnuke.menu(“Nuke”).clearMenu() 删除菜单下的所有菜单项，也不支持相对路径，不会删除当前空菜单\n\n\nnuke.MenuItem 创建菜单项类\n\nnuke.menu(“Nuke”).findItem(“菜单项”).action() 获取QAction对象,其父对象是QMainWindow\nnuke.menu(“Nuke”).findItem(“菜单项”).invoke() 直接执行menuItem，等同于nuke.menu(“Nuke”).findItem(“菜单项”).action().trigger()\nnuke.menu(“Nuke”).findItem(“菜单项”).script() 返回对应的字符串，如果是lambda函数，其返回值是空\nnuke.menu(“Nuke”).findItem(“菜单项”).setScript() 重新设置字符串\n\n\nnuke.menu(“菜单名”) 获取指定的根菜单，以下列出部分菜单名\n\nNuke 菜单栏\nNodes 工具栏\nNode Graph NodeGraph中的右键菜单\nViewer Viewer菜单\nProperties 节点属性对话框中的右键菜单\nAnimation 动画控件和曲线编辑器右键菜单\nPane 界面中面板布局右键菜单\nAxis 坐标右键菜单\n\n\n\n获取当前软件QT对象from Pyside2 import QtWidgets\nallWin &#x3D; [w for w in QtWidgets.QApplication.instance().topLevelWidgets() if w.windowTitle() &#x3D;&#x3D; &quot;窗口提示&quot;]\nallMenu &#x3D; [w for w in allWin[0]children() if isinstance(w,QtWidgets.QMenuBar)]\nmenubar &#x3D; allMenu[0]\n","categories":["Nuke","学习笔记"],"tags":["学习笔记"]},{"title":"Nuke学习笔记2_节点与Knob","url":"/posts/20220731a1.html","content":"Nuke学习笔记 \nNuke API 文档\n本地文档：C:\\Program Files\\Nuke12.2v2\\Documentation\n在线文档：https://learn.foundry.com/nuke/12.2/content/misc/nuke_devs.html\nNuke Python Developers Guide: 案例教程\nPython Scripting Reference： API 参考文档\nTCL Scripting Reference: TCL 表达式参考文档\n\n\n\n节点创建和删除nuke节点的有可能有不同的版本，比如”Text”和”Text2”、 “Merge”和”Merge2”、”Tracher”和”Tracher3”以及”Tracher4”，默认情况下使用的是新版。右键 &gt; Other &gt; All Plugin &gt; Update，这个操作会扫描并加载所有可用的节点。bezier节点不能被扫描出来，可使用Roto代替,若一定要使用，可使用代码创建或使用 Comp Script Command（TCL） 快捷键（X）创建想要的节点。节点参数的键可以在Nuke中将鼠标悬停在参数选项上，显示的提示框的第一句就是参数的名称，参数的值可复制节点到文本编辑器中查询，有时参数可能设置不上，是Nuke的一些bug,需要寻找别的手段设置。前台模式适合在Gui模式下交互，并且创建的节点会默认连接到当前选择的节点下，若没有选中节点，则创建在鼠标最后一次点击的位置；后台模式更适合后台运行脚本，创建的节点的位置随机。\n\n创建节点：\n前台模式：nuke.createNode(“节点类型”) \n后台模式：nuke.nodes.Read()\n\n\n创建节点时不弹出参数设置对话框：nuke.createNode(“节点类型”，inpanel&#x3D;False)\n创建节点时设置参数：\n前台模式：nuke.createNode(“Text2”,”message ‘test’ yjustify center”)\n后台模式：nuke.nodes.Read(message&#x3D;’test’, yjustify&#x3D;center)\n\n\n获取选中节点类型名：\nnuke.getNodeClassName()(选中状态的节点)\nnode &#x3D; createNode(“Text2”);node.Class()\n\n\n获取节点名：node.name()\n删除节点：\n前台模式：nuke.delete(node)\n后台模式：nuke.nodeDelete()(选中状态的节点)\n\n\n\nRead节点读取文件小技巧通过fromUserText方法读取视频文件，可以直接获取到视频文件的视频的长度。\n  import nuke\nreadNode &#x3D; nuke.nodes.Read()\nmovPath &#x3D; r&quot;D:\\mov\\test.mov&quot;\nreadNode[&#39;file&#39;].fromUserText(movpath)\n\n如果是exr或者别的图片序列呢？通过nuke.getFileNameList(path)方法可以获取到文件夹下的序列，进行自动分类，并返回一个字符串列表：\n[‘N.####.exr 1-15’, ‘Z.####.exr 1-7’, ‘beauty.####.exr 1-160’]\n\n\n创建read节点示例如下：\n  import nuke\nreadNode &#x3D; nuke.nodes.Read()\nexrPath &#x3D; r&quot;D:\\image\\beauty&quot;\nexrlist &#x3D; nuke.getFileNameList(exrPath)\nfor _each in exrlist:\n    readNode &#x3D; nuke.nodes.Read()\n    readNode[&#39;file&#39;].fromUserText(&quot;%s&#x2F;%s&quot; % (exrPath,_each))\n\n\n选择和链接节点\n获取节点：nuke.toNode(“节点名”)\n获取节点输入：\n获取所有输入端：nuke.inputs()\n获取指定输入端：nuke.input(端口数字)\n\n\n链接节点：nuke.setInput(端口数字，nuke.toNode(“节点名”)) \n获取所有节点：nuke.allNodes()\n获取选中节点：\n仅返回最后一个被选中的节点 nuke.selectedNode() \n返回主节点树中所有选中的节点 nuke.selectedNodes()\n\n\n选中以获得的节点\n将节点设置为选中状态 node &#x3D; createNode(“Text2”);node.setSelect(是否选中) 也可以传递参数设置选中状态\n将当前节点设置为整个节点树中唯一被选中的状态 node.selectOnly()\n\n\n选中所有节点 nuke.selectAll()\n选中满足模糊搜索节点名称的节点：nuke.selectPattern() 仅能在GUI模式下使用\n选中与当前选中节点类似的节点：nuke.selectSimilar(“要匹配的类型”)\n选中有相似的类型 nuke.selectSimilar(nuke.MATCH_CLASS)\n选中有相似的label标签 nuke.selectSimilar(nuke.MATCH_LABEL)\n选中有相似的颜色 nuke.selectSimilar(nuke.MATCH_COLOR)\n\n\n将选中节点的上下游都设置为选中状态 nuke.selectConnectedNodes()\n判断是否有被选中的节点 nuke.nodesSelected()\n反向选择 nuke.invertSelection()\n将节点从选中的节点中脱离出来 nuke.extractSelected()\n克隆选中的节点 nuke.cloneSelected()\n以递归形式清除节点的选中状态 nukescript.misc.clear_selection_recursive() 包括Gizmo 和 Group 中选中的节点也会被清除选中。\n\n节点位置和布局 NodeGraph 的坐标轴方向是X轴向右，Y轴向下；节点的位置指的是节点左上角的位置. 位置相关方法,node &#x3D; createNode(“Text2”)：\n\n获取位置\nnode.xpos()、node.ypos()\nnode[“xpos”].value、node[“ypos”].value\n\n\n设置位置\nnode.setXpos(“value”)、node.setYpos(“value”)、node.setXYpos(“value1”,”value2”)\nnode[“xpos”].setValue(“value”)、node[“ypos”].setValue(“value”)\n\n\n获取节点长宽\nnode.screenWidth()、node.screenHeight()\n\n\n自动布局到选中节点的下方 node.autoplace()\nNodeGraph 缩放比 \n查询缩放比 nuke.zoom()\n设置缩放比 nuke.zoom(倍数，[焦距的位置X,焦距的位置Y])\n聚焦到指定节点 nuke.zoom(倍数，[node.xpos(),node.ypos()])\n\n\n\n文件操作\n打开新Nuke工程 nuke.scriptNew() ctrl+N\n打开指定Nuke工程 nuke.scriptOpen(“存在的Nuke工程路径”) \n将已有的Nuke工程导入到当前的Nuke工程中\nnuke.scriptSource()\nnuke.scriptRendFile()\n\n\n清空当前NodeGraph:\n直接放弃修改，无返回值 nuke.scriptClear()\n提示是否保存更改，有返回值 nuke.scriptClose()\n\n\n退出Nuke nuke.scriptExit()\n获取当前文件名称 \nnuke.scriptName()\nnuke.Root().name()\nnuke.Root()[“name”].value()\nnuke.Root().knob(“name”).value()\n\n\n从节点中进入节点树环境.使用上下文管理器with ‘with nuke.Root()’\n返回当前工程所在的文件夹的路径\nnuke.utils.script_directory()\nnukescripts.script_directory()（该方法调用上面的方法）\n\n\n复制和粘贴\n从字符串创建一个节点 nuke.scriptReadText(“表示节点的字符串，超麻烦”)\n将选中的节点暂存到文本名或粘贴板名的文件中 nuke.nodeCopy(“文件路径或临时起名的粘贴板中”)\n将粘贴板中的内容粘贴到nuke中 nuke.nodePaste(“文件路径或临时起名的粘贴板中”)  # %clipboard% 可表示系统粘贴板\n\n\n保存工程 \n直接保存 nuke.scriptSave()\n另存为 nuke.scriptSaveAs(“文件名”)\n另存时不修改Root节点中的路径 nuke.scriptSaveToTemp(“文件名”)\n保存文件后清空nuke工程 nuke.scriptSaveAndClear()\n\n\n\nNuke中的控件（Knob）Nuke中的文本框、下拉菜单、复选框、滑块等基本控件，以及色彩设置图片尺寸、坐标值等 专属控件都称为Knob。node &#x3D; nuke.toNode(“Read”)\n\n获取所有的控件 \nnode.allKnobs() 所有控件列表\nnode.knobs() 所有控件字典\n\n\n获取特定的控件对象 \n根据控件名获取\nnode.knob(“控件名”) 没找到指定对象返回None\nnode[“控件名”] 没找到指定对象会报错\nnode.knobs().get(“控件名”) 根据控件名获取控件对象\n\n\n根据序号获取\nnode.numKnobs() 返回当前节点中所有控件的总数量\nnode.knob(控件序号)\n\n\n\n\n获取当前用户操作的控件 nuke.thisNode() \n控件状态 \nnode.knob(“控件名”).enable() 是否启用\nnode.knob(“控件名”).enable()setEnable() 设置启用状态\nnode.knob(“控件名”).enable()visible() 是否可见\nnode.knob(“控件名”).enable()setVisible() 设置可见状态\n\n\n返回标签名、控件名、提示信息 label()、name()、tooltip()\n设置标签名、控件名、提示信息 setLabel()、setName()、setTooltip()\n获取控件值\nvalue() 控件会根据需要进行继承和修改函数\ngetValue(oc) 获取特定帧或特定视图下的值\ngetValueAt()\ndefaultValue() 获取默认值\n\n\n设置控件的值  \nsetValue(value,view&#x3D;”default”) 控件会根据需要进行继承和修改函数\nsetValueAt()\nsetDafaultValue() 设置控件的默认值\nnuke.knobDefault(“节点名.控件名”，”参数”) 对节点的参数设置全局默认值\n\n\n控件值是否不为默认值 notDefault()\n\nformat_knob 参数默认值来源于Root节点的format值\n\n获取值 node.knob(“format控件名”).value() \n设置值 node.knob(“format控件名”).setValue()\n新建默认format值 nuke.addFormat(“新建format值”) 新建format值为TCL表达式，其至少要包含 宽度，高度，格式名三项，每项用空格分隔，名称不能用数字开头\n\nTCL表达式相关函数：\n\nnode.knob(“format控件名”).fromScript(“tcl表达式”) 接受tcl表达式并赋值给对象\nnode.knob(“format控件名”).toScript(bool,time) 将值输出为TCL表达式 bool为Ture，结果两侧加大括号，反之不加，time为具体帧，则仅设置该帧，若为None，则设置所有帧\nnode.knob(“format控件名”).readKnobs(“tcl表达式”) 使用tcl表达式为一个或多个节点控件赋值\nnode.knob(“format控件名”).writeKnobs(value) 将控件值以tcl表达式方式输出,value需要根据常量获取，详情见文档\n\n自定义控件UI交互式创建\n\n\n\n\n\n代码创建可使用NoOp节点进行自定义node &#x3D; nuke.toNode(“Read”)\n\n添加控件 node.addKnob(控件对象)\n移除控件 node.removeKnob(控件对象)\npythonScript中获取当前节点 nuke.thisNode()\n\nGizmo操作将具有特定功能的节点组打包成一个节点，可用于别的nuke工程\n\n查询节点全路径 nuke.thisNode().fullName()\n查询组内的节点 \nnuke.node(“组名”).node(“内部节点名”)[“knob名”].value()\nnuke.node(“组名.组内节点名”)[“knob名”].value()\n\n\n在组织间进行代码操作\nnode.begin() 代码开始\nnode.end() 代码结束\n\n\n转换正确导入的Gizmo为Group nuke.toNode(“Group”).makeGroup()\n\n导入\\导出gizmo在组节点或者Gizmo节点下面，点击Node &gt; Export gizmo\\Copr as Group不能直接import Gizmo 节点使用，这样导入的节点是不完整的，只能使用nuke标准环境加载的方式进行应用。或将gizmo文件以文本的方式打开，将其中的Gizmo 替换为Group,这样也可以正确导入节点组。\n","categories":["Nuke","学习笔记"],"tags":["学习笔记"]},{"title":"Nuke学习笔记1_环境与命令行","url":"/posts/20220730a1.html","content":"Nuke学习笔记 \nNuke 脚本编辑窗口相关快捷键和操作tab键   自动代码补全    输入部分脚本后，可获取相关的方法\nEdit > Preferences > ScriptEditor > echo python commands to output window 将输出常用操作的 Nuke Python API 代码显示在代码执行结果显示区。\n\n \n搭建 Pycharm IDE 开发环境在 Pycharm 中新建一个项目，用于开发Nuke插件,必须使用Nuke本身的Python编译器 \"C:\\Program Files\\Nuke版本\\python.exe\"，该python编译器拥有完整的Nuke开发环境。\n关于 nukescripts 模块的使用，需要将“C:\\Program Files\\Nuke版本号\\plugins”加入搜索路径\n关于 Pyside2 模块的使用，需要将“C:\\Program Files\\Nuke版本号\\pythonextensions\\site-packages”加入搜索路径\n配置好上面的环境后执行代码会发现报错：缺少一个“_nuke” 模块。这个模块在这里 \"C:\\Program Files\\Nuke12.2v2\\lib\\site-packages\\nuke.pyd\" 中，由于这个文件和上面的 nukescripts 模块同级目录的nuke模块重名，导致不能加载这个nuke.pyd，因此会报这个错，如何解决呢？\n\n\n方法一.从搜索路径中去掉 “C:\\Program Files\\Nuke版本号\\plugins”，但nukescripts模块的会缺少代码补全（加载完nuke.pyd后，会自动加载nuke和nukescripts模块，因此在执行代码时不会报这两个模块的错）.\n方法二.在pycharm中将编辑nuke代码的Python解释器和运行nuke代码的python解释器分开，在编写的nuke代码的时候，将项目中python interpreter中设置的python解释器设置为普通的python解释器，可以在其搜索路径中加入我们想要的搜索路径，然后在运行nuke代码的时候，在Run&#x2F;Debug configuration中设置的python解释器设置为带有nuke环境的python解释器即可。\n\n   \n此环境可能无法正常运行Pyside2相关的代码，需要在nuke中执行(详情见下一节)。\n\n  \nNuke 命令行模式&quot;C:\\Program Files\\Nuke12.2v2\\python.exe&quot; &quot;D:\\test.py&quot;\n\n运行脚本需使用Nuke的Python解释器，若后台调用脚本，可使用subprocess方法切换至Nuke本身的Python解释器。\n若要使用 Pyside2 模块，需要在通过nuke主程序 nuke.exe 使用参数 -t 就可以运行Pyside2模块。\n&quot;C:\\Program Files\\Nuke12.2v2\\nuke.exe&quot; -t &quot;D:\\test.py&quot;\n\n但 -t 参数不能获取到 QApplication 类，只能获取到 QCoreApplication 类（QApplication是QCoreApplication的子类），所以要通过 --tg 参数来获取 Pyside2 模块创建窗口所需要的 QApplication 类。\n&quot;C:\\Program Files\\Nuke12.2v2\\nuke.exe&quot; --tg &quot;D:\\test.py&quot;\nnuke命令行语法：\nnuke.exe  []  []\n使用不同类别的主程序常用参数:\n\n\n--nukex\n--studio\n--nc\n--nukeassist\n\n可以在Windows环境下使用doskey创建快捷键(只在当前窗口有效)，可以使用PATH环境变量，并写在一个bat脚本中：\ndoskey nukex &#x3D; &quot;C:\\Program Files\\Nuke12.2v2\\nuke.exe&quot; --nukex $*\n\n效果等于：“C:\\Program Files\\Nuke12.2v2\\nuke.exe” -- nukex &lt;\\option&gt; [&lt;\\argv&gt;] &lt;\\script&gt; [&lt;\\range&gt;] &#x3D; nukex &lt;\\option&gt; [&lt;\\argv&gt;] &lt;\\script&gt; [&lt;\\range&gt;]\n一些常用的参数：\n\n-t 适用于纯命令行脚本\n–tg 会产生一个 QApplication 实例，用于执行 Pyside2 的Gui相关脚本\n-x &lt;\\scriptname&gt; 渲染名为 \\scriptname 的nuke工程中所有激活的write节点\n-X&lt;\\nodename&gt; 仅渲染指定名的\\nodename的write节点\n-F 指定帧范围\n–cont 出错后继续渲染\n–sro 按顺序依次渲染节点\n-f 以全尺（full resolution）的方式打开nuk工程\n-p 和-f相对，以 proxy 的方式打开nuke工程\n-v 打开指定的图像文件，如果是视频，还需要跟上帧范围（文件路径使用正斜杠，不能使用反斜杠）\n–pause 打开nuke工程时暂停 Viewer 初始化\n-P 显示每个节点的资源占用情况\n-Pf&lt;\\filename&gt; 将每个节点的资源占用情况写入名为 \\filename 的xml文件中\n–multigpu 启用多gpu支持\n–gpulist 列出当前系统可用的GPU及其索引号\n–gpu ARG 使用由索引号ARG指定的GPU,在终端模式下启动GPU加速\n–safe 安全模式，启动nuke不加载 .nuke、NUKE_PATH及OFX插件\n-m # 指定线程数\n-n 关闭节点postage stamps的预览显示\n-q 关闭终端输出\n-i 使用nuke_i授权，可与 -x 和 -t 连用，写成 -ti 或 -xi,默认情况下使用nuke_r授权，但有些操作需要使用nuke_i授权。\n–remap&lt;\\pathPair&gt; 仅能在命令行模式下使用，在当前会话中设置路径映射，要求参数为一对或多对路径拼成的字符串，用逗号分隔\n\n","categories":["Nuke","学习笔记"],"tags":["学习笔记"]},{"title":"Xgen毛发","url":"/posts/20220729a1.html","content":"本文记录了一些Maya中Xgen毛发渲染的相关的问题：\n\nXgen 角色ABC和毛发ABC的运动模糊不匹配的问题（小概率事件）：\n原因是生长面缓存只有整数帧采样并且在渲染运动模糊时，Xgen没有计算生长面的插值,或者由于前后帧的运动差异过大，Xgen计算出错误的生长面插值，导致毛发生长面的缓存和角色缓存的插值不匹配，生长面缓存和角色缓存在小数帧位置不同，就会导致运动模糊不同。也可以通过实际文件观测到，在运动模糊有问题的小数帧，毛发不加载缓存时，其毛发引导线跟随动画缓存，加载了毛发缓存后，毛发缓存曲线和动画缓存的位置一致，而毛发引导线却和缓存曲线不在相同的位置，毛发引导线和动画缓存脱离，但是毛发引导线的形态和毛发缓存一致，说明毛发引导线只是从毛发缓存继承了形态，并不继承其位置。而毛发引导线的位置是从毛发生长面继承的，此时毛发引导线的位置和动画缓存不一致，那么小数帧时生长面的缓存和动画缓存位置不一致，因此，毛发生长面缓存在计算小数帧时有问题。解决此类问题，最好为动画缓存、曲线缓存、生长面缓存都添加缓存的小数帧采样插值。\n\n前台批渲染带渲染运动模糊时，代码批量刷新生长面时报错‘not match object “XGEN_RENDER_:XXXX”’：\nXgen毛发在渲染运动模糊后，会生成可通过xgen.palettes()获取，但是无法使用cmds.sl(\"\")列出，也无法删除的临时生长面，该生长面以“XG_RENDR_:”为前缀，若要在渲染运动模糊后批量处理生长面，需要跳过它，不会有任何影响。该临时生长面不会记录到maya文件中，但是会存在当前软件中，哪怕你清除场景，并重开另一个场景，也可以查询到它，处理时需直接跳过，对渲染无影响。\n\nabc流程中，对角色缓存位置进行修改（场景移回原点）过的灯光文件，其xGen毛发可能会炸毛，可能原因是引用文件记录了一些错误的操作，这部分操作导致xGen文件状态不对，需要删除.Xgen文件，重新引用毛发文件，或者先删除.Xgen文件、卸载引用文件、清除其操作历史，再加载引用文件。\n\n\nXgen 毛发创建笔记一些Xgen文件测试记录\n使用不同名称、完全相同的两个集合体作为Xgen描述的生长面，其基本体随机种子数会有一些差异，随机种子数是根据物体的生长面名称进行hash计算得出的结果，若替换生长面对应的几何体名称，随机种子数会发生细微变化，从而导致效果会有细微差别。\n\nxgen文件中只记录几何体的短名，不记录长名(可以手动修改的方式使用maya规范的长名，)，测试结果是只识别几何体短名称，不区分拓扑结构和形状以及uv，只使用.xgen文件中记录的的faceid面数，但拓扑结构不同结果肯定不一样，几何体名和生长面前缀应保持一致。\n\n绘制的iff贴图在保存文件后才会写入工程目录的文件夹，描述下有几个生长面就保存几张贴图(从新的几何体添加新的生长面，需要重新绘制贴图，保存后也会对应新增一张贴图)，根据绘制贴图时的生长面_集合_描述名称，xgen中指定的贴图名称命名为：polySurfaceShape1_grass_col_grass_decmask_generator_grass)。\n\n生长面跟随几何体放大缩小，但是毛发粗细不变(可写入表达式，待测试)。\n\n确定了几何体、绑定几何体并生成生长面之后，不可以修改几何体的名称，指向文件(ptx，xuv等文件)记录的是以几何体命名的贴图名称，更改几何体命名称后，链接断开，指向文件失效。\n\n使用相同几何体生成的不同描述，其生长面的名称为“几何体名称_描述名称”，不会重名\n\n单个XGen文件的生长面、几何体可以改名;改完命名后直接更改其Xgen文件的几何体名称，另存文件即可;\n\n使用几个几何体生成描述，集合下就拥有几个生长面(不建议使用多个几何体映射一个描述，最好先合并成一个几何体，方便管理)\n\n\n","categories":["Maya","杂项"],"tags":["排错记录","Xgen"]},{"title":"Deadline中调试编写的事件","url":"/posts/20220721a1.html","content":"详情Deadline 事件依赖于其软件框架，不能进行实时调试，但是可以通过 Console 窗口快速获取获取事件反馈信息。\n\n若想快速查看事件处理的过程，获取结果，首先通过Panels > Console 开启 Console 窗口。\n\n\n对于事件编写，除了要先配置正确的事件文件以外，还要在代码中加入打印（可通过 DeadlineEventListener 类的 self.LogInfo 或者 print 等方法将调试信息写入代码中，或通过ClientUtils.LogText(str)方法将信息写入 Deadline 的日志文件中），由于 Deadline 会每隔一段时间才会扫描储存库，扫描的默认值一般为5分钟，当扫描过程中发现事件脚本有新的修改时，才会将修改的事件脚本重新构建到任务中，所以，为了让 Deadline 后台及时更新并构建我们修改的事件脚本，我们需要通过Tools > Synchronize Monitor Script and Plugins 功能手动更新事件脚本。\n\n\n此时，Console 窗口会提示：***事件脚本有修改，将重新构建事件脚本的提示语。如果你的脚本有语法错误，Console 窗口还会给你打印一条简短的报错信息。然后 Requeue 目标任务，再将任务切换到我们所要的任务状态（先更新脚本，再操作任务，不能先操作任务再更新脚本，否则，事件不会被更新到任务状态中），Deadline 便会通过当前执行任务的机器执行事件脚本，并在Console 窗口显示反馈信息。通过此方法，可以快速对我们的事件脚本进行编写和调试。\n\n关于事件脚本中使用中文有时会在日志中打印中文信息，则我们需要将中文字符串编码为\"gbk\"（windows系统）的人类可读懂的代码。需要注意的是：\n\n\n需了解事件脚本在编写时，文本编辑器使用的编码格式是否为utf8，以及操作系统文件在编译中文时，使用的编码格式（Windows下控制台中的编码使用的是gbk）。因此，我们会在 python 脚本文件头部中加入 “# -- coding:utf-8 --” 显式编码注释，文本编辑器在存储脚本时会做相应的修改。\n中文字符很容易出错，导致插件执行被打断却没有任何反馈信息的假成功状态，这是由于当Deadline后台检测脚本有字符转换的错误时，它可不执行事件脚本。\n测试 deadline 10.0.6.3 的 Python2 环境打印中文：中文字符串最后一个字符串不能为中文标点符号，否则会报语法错误（控制台在编码中文时，会将最后一个标点符号编码错误为一个‘？’号）。\n\n  # -*- coding:utf-8 -*-\ndef __main__():\n    print(u&quot;测试中文打印&quot;.encode(&quot;gbk&quot;))\n    print(unicode(&quot;测试中文打印&quot;，&quot;utf-8&quot;).encode(&quot;gbk&quot;))\n\n\n测试在 deadline 10.1 的环境打印中文则很简单，和普通代码一样直接打印,字符串末尾可以有中文标点符号且不用进行字符编码，否则会报错：  # -*- coding:utf-8 -*-\ndef __main__():\n    print(&quot;测试中文打印。&quot;)\n\n相关链接1.官方文档中事件脚本文档\n\n2.往期相关文章：Deadline中的事件示例\n\n3.相关文章：Python代码中的字符编码","categories":["Deadline","插件"],"tags":["插件","API"]},{"title":"CG流程中的ACES概念解释","url":"/posts/20220706a1.html","content":"ACES 一些散记  经过IDT转换的图片只能保证其在AECS色域中渲染的颜色信息和ACES相比较是正确的，不能保证渲染的效果和SRGB的原效果一致。  线性图和非线性图的区别在于是否经过Gamma1.8到gamma2.2的曲线矫正,矫正的目的是为了迎合人眼观察的同时，方便使用8位图存储色彩信息。浮点图没有色彩存储空间不够的情况，因此浮点图一般是线性图。  ACES推荐使用EXR、TIF、HDR等浮点图存储信息，最少使用16位(exr是HDR标准的图片格式，拥有多通道存储的能力，使用1位、5位、10位分段分别存储不同的信息)。  CG流程中ODT用于ACES到SRGB色域的转换，通常是使用‘output_srgb’类型。  Maya中输出的16位ACES图和32位图色彩信息有些许肉眼可见的不同。请自行测试。\n一些文章参考\n国内网页：\nACES编码及色彩原理（CG）\n\nACES通俗讲解\n\n色彩原理\n\nNuke色彩空间（Gamma）的转换和原理\n\n参考文章1\n\n参考文章2\n\n参考文章3\n\n\n\n以下需科学上网：\nACES Workflow in Maya with Redshift and Arnold\n","categories":["Doc","学习笔记"],"tags":["灯光合成","ACES"]},{"title":"Maya中常用的部分环境变量","url":"/posts/20220521a1.html","content":"记录 maya 中常用的部分环境变量。\nMAYA_ENABLE_LEGACY_RENDER_LAYERS      开启旧版灯光渲染分层系统（maya2017以后可使用）\n\n屏蔽 maya 连接网络\nMAYA_DISABLE_CIP &#x3D; 1\nMAYA_DISABLE_CLIC_IPM &#x3D; 1\nMAYA_DISABLE_CER &#x3D; 1\n\n文件路径中使用环境变量maya在的文件路径可以带有环境变量，例如 ${variatName}&#x2F;model&#x2F;leg.abc。其中，${variatName}是环境变量，具体值来自系统中的环境变量和软件的环境变量，在解析文件路径时会替换为变量中保存的值。$variatName、${variatName}、%variatName% 等均代表变量替换。\n参考说明部分环境变量注释：http://paulnendick.github.io/articles/maya-rosetta-stone.htmlmaya官网地址：https://help.autodesk.com/view/MAYAUL/2022/CHS/?guid=GUID-925EB3B5-1839-45ED-AA2E-3184E3A45AC7\n","categories":["Maya","杂项"],"tags":["Pipeline","环境变量"]},{"title":"Windows任务计划","url":"/posts/20220510a1.html","content":"工作中有时需要定时执行一些规律性的脚本操作，比如，清除磁盘垃圾、定时下载任务等。这些任务执行虽然简单，但是需要人力进行日常维护。通常有两种方式可以方便处理这类型任务：\n\n以本机作为脚本任务的执行者，开启电脑后，通过ide运行任务，但是每次开机都需要手动执行，或者将程序打包成exe程序再放入启动文件夹。\n以本机作为服务器，通过任务计划的触发器，自动执行指定任务，不需要每次开机后再手动执行。\n\n下面将介绍第二种方式——任务计划\n\n打开计划任务程序\n\n\n\n\n\n创建一个新的任务计划文件夹（推荐）或在“任务计划程序库”中创建基本任务:提一下”创建基本任务”和”创建任务”的区别是一个有引导界面，一个直接弹出设置界面直接设置。\n\n\n  \n\n输入任务名称和描述。\n\n  \n\n选择触发器，修改触发器触发的时间和间隔，这里暂时只能创建一个触发器，我们可以创建完任务计划后进行添加或修改触发器。\n\n \n\n选择任务操作，并填入相关参数，这里很重要，它可以决定你的任务计划是否正常执行，原则上越简单越好（后面会进行详解）；然后点击完成。\n\n \n\n“创建基本任务”完成后，我们还需要对其进行一些的修改；选择任务点击属性对任务进行修改。\n\n  “操作”项暂不做修改；”条件”项也比较简单，都是字面意思，这里不做讲解；  note：每次手动运行任务后，若任务状态没有更改成预期状态，可通过右键任务选择“刷新”选项进行任务状态的刷新。\n\n关于”操作”项中的设置需要注意：由于我们使用的是.bat脚本中通过python程序调用.py脚本，因此这里的”程序或脚本”填入 XXX\\test.bat(不加引号)，”添加参数（可选）”为空，“起始于（可选）”则是.py文件所在的目录，而不是执行程序或者.bat脚本所在的目录，否则执行的结果会出错；若不填(缺省状态)，那么自动将该处的目录位置定位到”程序或脚本”的目录位置。并且调用的程序需要传入参数，例如”程序或脚本”填入Python编译器路径 C:\\Python27\\python.exe ，而”添加参数（可选）”为.py文件，那么“起始于（可选）”则是.py文件所在的目录。最后说一下，任务计划中所用到的所有的文件最好放置在本地路径。\n\n实践踩坑和解决办法在这次工作中由于需要每天调用pythonAPI对程序的服务端进行调整，因此使用了任务计划调用bat脚本的方式执行任务。该bat脚本中，仅简单的一句'XXX/python.exe XXX/XXX/xxx.py'---使用编译器编译python脚本，该任务在我本机上执行没有任务问题，于是将任务计划部署到农场机器上，此时任务就出现了问题：创建的任务不会成功执行，或者执行结果不为'成功执行（0X0）',或者执行结果为'成功执行（0X1）'（失败状态）或者直接失败，找了很久的原因，排除几乎所有的可能性（计算机休眠、计算机系统配置不对、任务权限不够、bat脚本有问题、.py脚本有问题、任务手动运行后状态没有及时切换导致新实例不能创建、不能访问网络盘资源、脚本“起始于（可选）”参数不对、执行程序带引号等等）。最后本着\"越简单越好\"的原则，直接将bat脚本拆开，将python编译器的位置填入\"程序或脚本\"，\"添加参数（可选）\"填入.py脚本，“起始于（可选）”填入.py脚本路径，问题才得到解决。\n猜测和计算机系统有关，由于我本机使用的是Windows10 的操作系统，而农场机使用的是Windows server2012 的操作系统。\n\n\n\n\n\n参考官方介绍：https://forsenergy.com/zh-cn/gpmc/html/688d2d42-454a-4e2e-90c0-557f959d49b0.htm参考文章：https://www.jianshu.com/p/c627c77f6ea3\n","categories":["Doc"],"tags":["排错记录","windows"]},{"title":"Deadline如何使用PythonAPI","url":"/posts/20220505a1.html","content":"前言本文介绍如何使用 Deadline 的 Python API 操作Deadline。通过 Python API 可在 Python 中与 HTTP API 通信。\n\n拷贝 PythonAPI 模块首先在使用 API 之前，需要配置python环境使我们可以调用到 API。我们需要安装和使用 python2.7.9或 3.7 以上的python版本，然后将 Deadline 储存库路径（//your/repository/api/python）下的整个“Deadline”文件夹复制到Python 安装路径下的的“site-packages”文件夹，API 即可调用。\n\n\n开启 WebService 服务我们还需要通过 WebService 通信以发送和接收请求，因此，还要在 Deadline 管理的局域网中的任何一台可见的设备上运行 WebService服务，该服务为“C:\\Program Files\\Thinkbox\\Deadline10\\bin\\deadlinewebservice.exe”，打开后，我们就可以通过该设备的设备名称或者Ip地址进行通讯，API访问的端口默认情况下为8082。\n\n\n使用 PythonAPI使用时，必须创建一个 DeadlineCon 对象。该对象用于与 WebService 通信以发送和接收请求，该对象需要两个参数：“运行 WebService 服务的设备名或IP地址”、“该设备上允许 WebService 通信的端口号（默认为8082）”，这两个参数可以从已经运行的 WebService 通讯服务上找到。\n\n\n然后我们就可以使用API创建一个连接对象“connectionObject &#x3D; Deadline.DeadlineConnect.DeadlineCon(‘WebServiceName’, WebServicePortNumber)”， 通过该对象，我们可以查询、修改 Deadline 上的大部分信息。\n示例代码1：查询作业组、暂停指定作业\nimport Deadline.DeadlineConnect as Connect  # 导入 Deadline.DeadlineConnect 作为连接\nconnectionObject &#x3D; Connect.DeadlineCon(&#39;DESKTOP-Mirror&#39;, 8082)\nprint(connectionObject.Groups.GetGroupNames())\n#[&quot;group1&quot;,&quot;group2&quot;,&quot;group3&quot;]\njobId &#x3D; &quot;622c38262812473ba4c08eca&quot;  #(有效的job ID号)\nprint(connectionObject.Jobs.SuspendJob(jobId))\n# &#39;Success&#39;\n\n示例代码2：提交作业\nimport Deadline.DeadlineConnect as Connect\n\nDeadline &#x3D; Connect.DeadlineCon(&#39;DESKTOP-Mirror&#39;, 8082)\nJobInfo &#x3D; &#123;\n    &quot;Name&quot;: &quot;Submitted via Python&quot;,\n    &quot;UserName&quot;: &quot;UserName&quot;,\n    &quot;Frames&quot;: &quot;0-1&quot;,\n    &quot;Plugin&quot;: &quot;VraySpawner&quot;\n&#125;\n\nPluginInfo &#x3D; &#123;\n    &quot;Version&quot;: &quot;Max2014&quot;\n&#125;\n\ntry:\n    newJob &#x3D; connectionObject.Jobs.SubmitJob(JobInfo, PluginInfo)\n    print(newJob)\nexcept:\n    print(&quot;Sorry, Web Service is currently down!&quot;)\n\n\n参考\n官方说明：https://docs.thinkboxsoftware.com/products/deadline/10.1/3_Python%20Reference/index.html#intro_sec\n\n","categories":["Deadline","插件"],"tags":["插件","API"]},{"title":"Maya中材质文件和缓存文件相结合进行渲染的几种方式","url":"/posts/20220503a6.html","content":"前言本文记录材质文件和缓存文件相结合，组装渲染镜头文件的几种方式.\n\n缓存驱动材质文件进行渲染使用缓存文件驱动材质文件的方式进行渲染。\n缓存文件直接替换材质文件的几何体进行渲染缓存文件包裹材质文件进行渲染给缓存文件赋予材质进行渲染","categories":["Maya","杂项"],"tags":["Pipeline","灯光"]},{"title":"Maya软件渲染问题集锦","url":"/posts/20220503a5.html","content":"\n渲染崩溃可能的问题：\n\n被赋予Arnold材质3s散射的物体是片，导致散射时不是在物体内部散射，而是在整个场景中散射，计算量特别大从而崩溃。\n文件中毛发的密度太大导致渲染机内存不够用。\n文件本身有问题。\n具体问题，具体分析。\n\n\nRedshift:提示：’Mesh pCubeShape1 is instanced and uses adaptive tessellation, which isn’t supported. Disabling tessellation. If you need tessellation, please use fixed tessellation settings: i.e. disable ‘screen space adaptive’ and set ‘min edge length’ to zero to force a maximum tessellation level’。对象细分后在实例错误提示：对象在实例化后细分，被实例化对象在屏幕自适应时找不到细分对象，就不会进行细分。如果需要细分，就关闭屏幕自适应，并把最小边缘强度设置为零，以强制使用最大边缘强度，如图：\n \n\n农场机提示找不到可执行渲染的文件：“Katana render executable was not found in the semicolon separated list”（在分号分隔的列表中没有找到Katana渲染的可执行文件），该机器上没有安装相应的软件，或软件没有安装在默认的路径。\n\nCannot find procedure “pgYetiVRayPreRender”（或”pgYetiPreRender”）报错导致渲染暂停：渲染文件中没有Yeti毛发节点，却在渲染文件的渲染设置中填入了“pgYetiVRayPreRender”（或”pgYetiPreRender”）代码，导致渲染器找不到对应的节点而报错，我们只需要打开文件，删除渲染设置中的以下代码就行了（Render Settings &gt; Common &gt; Render Options，删除报错的MEL，一般情况下也可以全部删除）：\n \n \n \n \n\n贴图文件正在上传或修改。日志出现：File“*******”was modified after being opened by OIIO，这是因为文件在渲染的时候，被文件IO读取的贴图文件还在上传或更新中 解决办法：等待贴图上传完成后再渲染文件\n\n盘符掉了或没有输出磁盘： 解决办法：映射一个盘符\n subst D: C:\\D  ::映射D盘盘符到C盘的D文件夹\n\nDeadline农场渲染报错“defaultRenderLayer” is a layer from a referenced and is not allowed to be the current layer ,其可能是之一是：maya 的 renderLayerManage节点被改名导致 maya 不能生成默认的master layer渲染层（在.ma文件中的名称为defaultRenderLayer），因此可以将文件保存为.ma格式的文件，用文本的方式打开，将renderLayerManager节点的名称改为默认的’renderLayerManager’(没有任何修饰)，同时由于默认的renderLayerManager节点已经被修改过，默认的渲染层名称也发生了改变，导致渲染程序在调用的代码中，该层被判定为非默认的渲染层而报错“unable to modify overrides to the default layer”,因此，还需要将文件中的 defaultRenderLayer节点 (本问题记录时该节点名称为 defaultRenderLayer1 ),改为默认的名称defaultRenderLayer，即可。\n\nmaya动画文件直渲，后台批量渲染时，角色控制器带动角色模型不规则抖动的可能原因：这是旧版绑定系统的问题，这种问题一般可通过走 abc 流程规避，否则需要更新绑定的 cluster 节点选项。禁用”cluster.relative”，并将”cluster.angleInterpolation”的值设置为3，代码如下：\n import maya.cmds as mc\nfor each in mc.ls(typ&#x3D;&quot;cluster&quot;):\nmc.setAttr(&quot;cluster1.relative&quot;, 0)\nmc.setAttr(&quot;cluster1.angleInterpolation&quot;, 3)\n\nmaya动画文件直渲，后台批渲时，动画文件中的约束失效，例如角色对道具的约束丢失或者效果不对；可能原因：\n\n动画文件后台渲染其中的动力学不出缓存，会重新计算。\n动画文件后台渲染时表达式会失效。解决办法：（1）烘焙动画曲线：选择绑定组大组执行 Animation &gt; Key &gt; Bake Simulation 等待读条完成后会将控制器的每一帧都K上关键帧，然后再提交渲染即可；（2）在Premel中填入可拖动时间滑块到当前帧的mel表达式，该表达式会在渲染开始前对镜头中的帧进行切换，从开始帧逐渐切换至当前帧，相当于对文件中的控制器进行了一次”脏”运算。达到数据正确的目的。（3）走 abc 流程。\n\n\nmaya 创建polygon报错：error line0:connection not made :”****.instObjGroup[0]”-initalShaderGroup.dagSetMembers[-1].destination is locked:可能原因：\n\n相关节点被锁\n相关属性被锁解决办法：解锁相关节点或相关属性，或者重启 Maya 可解决问题。\n\n\n后台渲染丢材质报错：[mtoa][translator polymesh] ShadingGroup ******:*****SG has no faceShader input …。可能原因：材质没有连接上对应模型或制作过程中切换过不同的渲染器，导致材质与物体mesh的链接断开；解决办法：修改材质文件中的材质链接或重新连接材质，注意查看材质文件的材质、渲染器输出信息；或先赋予Lambert材质,再重新赋予原来的材质。\n\n后台渲染和前台渲染的exr图片颜色空间不一致，或颜色不一致。可能原因：\n\n首选项中勾选了的 Preferences &gt; Output color preferences &gt; Apply Output Transform to Render ，并将Output Transform 设置为 Use View Transform ,该选项会应用 Preferences &gt; Color Transform Preferences 中的 View Transform 值到输出图片，该选项的作用是将渲染预览的结果转换并应用到输出图片（包括色彩空间），如果渲染预览的图片为sRGB编码的色彩空间图，则输出图片也会转换为sRGB色彩空间的图（如下图左1）。\n渲染器驱动节点的”defaultArnoldDriver.colorManagement”渲染设置为了 Use View Transform ，其默认值为 Use Output Transform，原因和 1 一致（正确设置如下图右1所示）。选中驱动节点代码：mc.select(&quot;defaultArnoldDriver.colorManagement&quot;)\n\n\n\n\n\n\n同一个场景代理文件，渲染颜色不一致、闪烁，可能原因：代理文件导入maya后，其材质网络被修改过，使两个aistand_in使用相同的代理颜色却不一样，从而产生错误（原因未知）。解决办法：1.改会原来的材质。2.修改使用两个不同的代理文件。\n\n\n","categories":["Maya","杂项"],"tags":["排错记录","锦囊小妙招"]},{"title":"Maya软件小知识点","url":"/posts/20220503a4.html","content":"\n贴图色彩空间被锁定的情况，解锁所有节点贴图的贴图色彩空间选项：\n import maya.cmds as cmds\nfor i in cmds.ls(type&#x3D;&#39;file&#39;):\n    cmds.connectAttr(&quot;:defaultColorMgtGlobals.cme&quot;,i+&quot;.cme&quot;,f&#x3D;1)\n\n脚本切换渲染器:\n cmds.setAttr(&quot;defaultRenderGlobals.currentRenderer&quot;, &quot;arnold&quot;, type&#x3D;&quot;string&quot;)\n\n获取当前视图快照拍屏：\n ws &#x3D; cmds.workspace(q &#x3D; True, fullName &#x3D; True)\nwsp &#x3D; ws + &quot;&#x2F;&quot; + &quot;images&quot;\nimageSnapshot &#x3D; wsp + &quot;&#x2F;&quot; + &quot;endSnapshot.jpg&quot;\ncmds.refresh(cv&#x3D;True, fe &#x3D; &quot;jpg&quot;, fn &#x3D; imageSnapshot)\n\n脚本设置渲染设置的输出序列图选项：\n mc.setAttr(&quot;defaultRenderGlobals.animation&quot;, True)  # 开启动画帧序列\nmc.setAttr(&quot;defaultRenderGlobals.animationRange&quot;,1)  # 开启动画帧的范围\nmc.setAttr(&quot;defaultRenderGlobals.outFormatControl&quot;, 1)  # 设置帧格式\nmc.setAttr(&quot;defaultRenderGlobals.putFrameBeforeExt&quot;, 1) # 设置图片格式在数字后面（name.#.ext）\n\n创建多相机渲染：\n\n选择相机&gt;AtteibutsEdit&gt;OutputSettings&gt;Renderable(勾选)\nRenderSetting&gt;RednderableCamera&gt;Add RenderableCamera\n\n\nArnold开关运动模糊要同时设置运动模糊可见性:\n mc.setAttr(&quot;defaultRenderGlobals.motionBlur&quot;, 0) #关闭运动模糊（针对于Arnold）\nmc.setAttr(&quot;defaultArnoldRenderOptions.motion_blur_enable&quot;, 0) #关闭运动模糊可见性\nmc.setAttr(&quot;defaultRenderGlobals.motionBlur&quot;, 1) #开启运动模糊\nmc.setAttr(&quot;defaultArnoldRenderOptions.motion_blur_enable&quot;, 1) #开启运动模糊可见性\n\n脚本打印部分渲染节点属性名称和值的方式:\n import maya.cmds as cmds \nrender_glob &#x3D; &quot;defaultRenderGlobals&quot;\nlist_Attr &#x3D; cmds.listAttr(render_glob, r&#x3D;True, s&#x3D;True)\nfor attr in list_Attr:\n    get_attr_name &#x3D; &quot;%s.%s&quot;%(render_glob, attr)\n    print &quot;setAttr %s %s&quot;%(get_attr_name, cmds.getAttr(get_attr_name))\nmtoa 创建和访问AOV:\n import mtoa.aovs as aovs\n# 添加aov\naovs.AOVInterface().addAOV(&#39;aov名称&#39;, aovType&#x3D;&#39;float&#39;)\n# 列出活动状态的aovs\naovs.AOVInterface().getAOVs()\n\nArnold代码加载arnold渲染器并创建默认节点：\n import maya.cmds as mc\nimport mtoa.core\nmc.setAttr(&quot;defaultRenderGlobals.currentRenderer&quot;,&quot;arnold&quot;,typ&#x3D;&quot;string&quot;)\nmtoa.core.createOptions()  # 创建ar默认节点网络\n\n查看 mel 函数帮助：使用 “whatIs ‘mel命令’;” 可以查看mel函数帮助。\n\n设置maya视图窗口为非显卡（不使用显卡）支持的窗口模式：\nimport maya.cmds as mc\ndef switch_preview():\n    all_model_panel &#x3D; mc.getPanel(typ&#x3D;&quot;modelPanel&quot;)\n    for each in all_model_panel:\n        mc.modelEditor(each,e&#x3D;True,rnm&#x3D;&quot;base_OpenGL_Renderer&quot;)  # 查询可用的渲染器名称 mc.modelEditor(each,q&#x3D;True,rendererList&#x3D;True) \n\nXgen相关:\nimport xgenm.xmaya.xgmExternalAPI as xgenmExternalAPI\nimport xgenm as xg\npalettes &#x3D; xg.palettes()  # 获取Xgen 所有描述\nif not (xgenmExternalAPI.xgg.DescriptionEditor is None):\n    xgenmExternalAPI.xgg.DescriptionEditor.refresh(&quot;Full&quot;)  # 刷新所有Xgen面板\n\n开启软件时关闭材质刷新\ncmds.scriptJob(event&#x3D;(&#39;SceneOpened&#39;,&#39;cmds.renderThumbnailUpdate(False)&#39;))\n\n添加回调\nimport maya.OpenMaya as OpenMaya\nOpenMaya.MSceneMessage().addCallback(37, funcName)\n\n清除进程任务\nimport pymel.core.language as pcl\n_jobs &#x3D;pcl.scriptJob(lj&#x3D;1)\n#.清除内存任务 if._jobs:\nfor _job in _jobs:\n    job_id &#x3D; int(_job.split(&#39;:&#39;)[0])\n    print(u&#39;清除进程任务:%s&#39; % _job) \n    try:\n        pcl.scriptJob(kill&#x3D;job_id, force&#x3D;True)\n    except:\n        pass\n\n快速烘焙动画进行动画烘培(Bake Simu ation)的时候，Mava跳过逐帧跑一谝时间滑块。\nimport maya.cmds as cmds\nstart &#x3D;int(cmds.playbackOptions(q&#x3D;True, minTime&#x3D;True))\nend &#x3D; int(cmds.playbackOptions(q&#x3D;True, maxTime&#x3D;True))\ncmds.bakeResults(simulation&#x3D;False, t&#x3D;(start, end))\n\n12代 Intel cpu 不兼容py插件问题：添加环境变量不要py中ssl相关的东西\n变量名：OPENSSL_ia32cap\n变量值：~0x200000200000000\n\n","categories":["Maya","杂项"],"tags":["排错记录","锦囊小妙招"]},{"title":"Maya软件小问题集锦","url":"/posts/20220503a3.html","content":"本文记录了一些Maya中出现的一些小问题：\n\nAOV无法正常创建\nimport maya.cmds as mc\nmc.lockNode(&#39;initialParticleSE&#39;,l&#x3D;0,lu&#x3D;0)\nmc.lockNode(&#39;initialShadingGroup&#39;,l&#x3D;0,lu&#x3D;0)\n\nMaya 操作总是提示 “&#x2F;&#x2F; Error: line 1: Cannot find procedure “onModelChange3dc”. &#x2F;&#x2F;“，这可能是模型制作的时候打开了某个窗口，maya在关闭的时候会保存一份配置在maya文件里，可以从Expression Editor的By Script Node Name里看到，虽然没什么影响，但是真的很烦。解决办法：\nimport pymel.core as pm\n# 获取Maya中的所有模型编辑器并重置 editorChanged 事件\nfor item in pm.lsUI(editors&#x3D;True):\n   if isinstance(item, pm.ui.ModelEditor):\n       pm.modelEditor(item, edit&#x3D;True, editorChanged&#x3D;&quot;&quot;)\n\nRenderSetting渲染面板内容空白，执行mel脚本:\ndeleteUI unifiedRenderGlobalsWindow;\n\n关闭“cannot find procedrure ‘look’”：\n\n执行mel脚本:\n\n方法一：outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;\n方法二：global proc look()&#123;&#125;;\n\n\n执行python脚本:\n maya.mel.eval(&#39;outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;&#39;) \n\n\n删除TurtleDefaultBakeLayer层：\n\n执行mel脚本\n &#x2F;&#x2F;删除海龟渲染 mel脚本\nlockNode -l off TurtleDefaultBakeLayer;\ndelete TurtleDefaultBakeLayer;\nlockNode -l off TurtleRenderOptions;\ndelete TurtleRenderOptions;\nlockNode -l off TurtleBakeLayerManager;\ndelete TurtleBakeLayerManager;\n\n执行python脚本\n def delTurtleRender():\n    if mc.objExists(&#39;TurtleRenderOptions&#39;):\n        mc.lockNode(&#39;TurtleRenderOptions&#39;, &#39;TurtleUIOptions&#39;, &#39;TurtleBakeLayerManager&#39;, &#39;TurtleDefaultBakeLayer&#39;, lock&#x3D;0)\n        mc.delete(&#39;TurtleRenderOptions&#39;, &#39;TurtleUIOptions&#39;, &#39;TurtleBakeLayerManager&#39;, &#39;TurtleDefaultBakeLayer&#39;)\n        print u&quot;海龟渲染节点清理完成&quot;\n    else:\n        print u&quot;场景中海龟渲染节点已清理干净&quot;\ndelTurtleRender()\n\n\nMaya Arnold不能渲染: &#x2F;&#x2F; Rendering with Arnold Renderer… &#x2F;&#x2F; &#x2F;&#x2F; Result: Rendering Completed. See mayaRenderLog.txt for information. &#x2F;&#x2F; 是因为Maya 的mtoa环境变量丢失，导致渲染器使用的部分文件没有调用到，因此直接结束渲染。 解决办法： https://support.solidangle.com/display/AFMUG/Batch+Rendering 的Batch Render Flags   提到了解决问题的办法，就是在环境变量中增加如下环境变量（对应maya版本号）： MAYA_RENDER_DESC_PATH&#x3D;C:\\solidangle\\mtoadeploy\\对应maya版本号 然后，重新打开maya渲染。或者，重新安装渲染器，此办法有概率解决问题。\n\n高版本Maya(2020以上)不能加载Arnold渲染器的问题：需要打补丁程序VC_redist.x64.exe。\n\n\n","categories":["Maya","杂项"],"tags":["排错记录","锦囊小妙招"]},{"title":"Maya文件打开慢或者崩溃的检查办法","url":"/posts/20220503a2.html","content":"项目制作过程中常常会遇到制作文件打不开或者打开慢的情况，对于此类问题：\n\n如果是’.mb’文件，会比较麻烦些，需要在打开文件时不加载引用文件，然后一个一个加载引用文件，根据引用文件的加载情况进行判断是否有引用文件有问题。一般会出现：单个引用文件加载崩溃、单个引用文件加载慢、所有引用文件加载都没问题，但是保存后还是打开有问题，这时就需要分别尝试打开带有加载不同引用文件的maya文件。（之前碰到过引用文件中有的节点有冲突：相同的引用文件单独加载都没问题，但保存后加载会崩溃，然后逐步定位加载有问题的文件一步一步排除，最后将有冲突的节点重建才解决问题。）\n\n如果是’.ma’文件：\n\n使用上面的’.mb’文件的办法。\n在文件中插入 mel 脚本，在打开脚本的同时，执行mel脚本，通过脚本的日志内容情况来判断是什么文件导致的‘.ma’文件打不开，或者打开慢的情况。\n\n\n\n代码如下：\nimport codecs\n\ndef checkMayaAsciiFile(source_file, target_file, log_file):\n    &quot;&quot;&quot;\n    1. 用于检查 Maya Ascii 文件打开崩溃\n    2. - - - - - - - - - - - - - -耗时\n    Args:\n        source_file: ma 文件\n        target_file: 修改后的文件\n        log_file: logging\n\n    Returns: none\n\n    &quot;&quot;&quot;\n    # # 记录打不开的ma文件是从哪一行崩溃的\n    # __startMel &#x3D; &#39;&#39;&#39;python(&quot;logFile&#x3D;&#39;%s&#39;;ff &#x3D; open(logFile,&#39;w&#39;);ff.write(&#39; &#39;);ff.close();&quot;);&#39;&#39;&#39; % log_file\n    # __proc &#x3D; &#39;&#39;&#39;python(&quot;ff &#x3D; open(logFile,&#39;a&#39;);ff.write(&#39;%s - &#123;0&#125;\\\\\\\\n&#39;.format(comp_time));ff.close();&quot;);\\n&#39;&#39;&#39;\n    # __endMel &#x3D; &quot;&quot;\n\n    # 记录打开文件时的耗时信息\n    __startMel &#x3D; &#39;&#39;&#39;python(&quot;from datetime import datetime;import time;line_time&#x3D;datetime.now();time.sleep(0.002);threshold_time&#x3D;datetime.now() - line_time;start_time&#x3D;line_time;logging&#x3D;list();logFile&#x3D;&#39;%s&#39;&quot;);&#39;&#39;&#39; % log_file\n    __proc &#x3D; &#39;&#39;&#39;python(&quot;comp_time &#x3D; datetime.now() - line_time;logging.append(&#39;%s - &#39;+ str(comp_time)) if comp_time &gt; threshold_time else None;line_time &#x3D; datetime.now();&quot;);\\n&#39;&#39;&#39;\n    __endMel &#x3D; &#39;&#39;&#39;python(&quot;logging.append(&#39;\\\\\\\\n\\\\\\\\nStart Time - &#39;+ str(start_time) + &#39;\\\\\\\\nEnd Time - &#39;+ str(line_time) + &#39;\\\\\\\\nTotal Time - &#39; + str(line_time - start_time));ff &#x3D; open(logFile,&#39;w&#39;);[ff.write(line+&#39;\\\\\\\\n&#39;) for line in logging];ff.close();&quot;);&#39;&#39;&#39;\n\n    with codecs.open(source_file, &quot;r&quot;, &quot;gbk&quot;) as f:\n        aLines &#x3D; f.readlines()\n\n    fileter &#x3D; (&quot;select&quot;, &quot;connectAttr&quot;, &quot;dataStructure&quot;, &quot;createNode&quot;, &quot;requires&quot;, &quot;currentUnit&quot;)\n    # other relationship fileInfo\n    rule &#x3D; 1\n    for num, line in enumerate(aLines):\n        line_add &#x3D; &quot;&quot;.join([aLines[num - 1][:-1], __proc % str(num)])\n        if rule:  # 文件开头的 file 每一行都加 mel\n            if __startMel:  # 文件开头结尾初始化命令\n                aLines[num] &#x3D; __startMel + line\n                if __endMel:\n                    aLines[num - 1] &#x3D; __endMel + aLines[num - 1]\n                __startMel &#x3D; 0\n                continue\n            if &quot;file&quot; in line:  # 可能有的设置里会有file字符串,所以这里要独立规则\n                if &quot;;\\n&quot; not in aLines[num - 1]:\n                    continue\n                aLines[num - 1] &#x3D; line_add\n            if &quot;requires&quot; in line:  # requires 之后改变规则\n                rule &#x3D; 0\n\n        # 在 fileter 参数里的,对它的前一行添加 mel\n        # setAttr 用的是 .attr 的方式,在它之后加 mel 会影响下一个 setAttr 所以这里添加这个过滤\n        for _ in fileter:\n            if _ in line:\n                if &quot;;\\n&quot; in aLines[num - 1]:\n                    aLines[num - 1] &#x3D; line_add\n\n    with codecs.open(target_file, &quot;w&quot;, &quot;gbk&quot;) as ff:\n        for lines in aLines:\n            ff.write(lines)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    srcFile &#x3D; r&quot;E:\\test\\shot00401.ma&quot;\n    srcFile &#x3D; srcFile.replace(&quot;\\\\&quot;, &quot;&#x2F;&quot;)\n\n    sourceFile &#x3D; srcFile\n    targetFile &#x3D; srcFile[:-3] + &quot;_v01.ma&quot;\n    logFile &#x3D; srcFile[:-3] + &quot;_v01.txt&quot;\n    # print(sourceFile, targetFile, logFile)\n    checkMayaAsciiFile(sourceFile, targetFile, logFile)\n\n以上代码中，需要将”E:\\test\\shot00401.ma”替换成你的‘.ma’文件路径，执行完成后，会在同级文件目录下生成一个版本号为‘-v01’的‘.ma’文件，使用Maya打开该文件，打开文件的同时会执行文件中的mel脚本保存日志信息，文件读取完成后，也会在统计目录下生成一个版本号为‘-v01’的txt日志文件，打开文件分析即可。\n转载部分内容转载自：https://ruben.blog.csdn.net/article/details/90082639\n","categories":["Maya","小工具"],"tags":["检查","排错记录"]},{"title":"Maya中在物体的点上创建跟踪对象","url":"/posts/20220503a1.html","content":"之前做测量相机焦距工具的时候发现不能把焦距添加约束到物体上的点，尤其是做了abc缓存之后，由于并没有对点进行编辑，不管是在自身空间还是世界空间中，点的位置在数值上都没有变换，被约束的相机的焦点依旧保持在原地，因此对点添加普通的的约束并不能达到效果，我们需要换一种方式进行约束。\n\n可以使用给点创建毛囊的办法，利用uv映射的点的位置始终保持不变，但是物体的世界矩阵在变化的原理，将点世界坐标的信息传递给毛囊，毛囊会一直跟着点的，此时我们只需要约束毛囊就能达到我们想要的效果了。\n\n代码如下：\n# -*- coding:utf-8 -*-\n# !&#x2F;usr&#x2F;bin&#x2F;env python27\n# @Author: Mirror\n# @Time: 2022-03-15\n# description: 该脚本用于在选中点的位置上创建定位毛囊，该毛囊通过UV点定位，所有使用后不能调整点所在的UV\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport maya.cmds as mc\n\ndef buildFollicle(points):\n    if not points:\n        return\n    if type(points).__name__ &#x3D;&#x3D; &quot;str&quot;:\n        points &#x3D; [points]\n    for point in points:\n        poly_transform &#x3D; mc.listRelatives(mc.listRelatives(point, p&#x3D;True, s&#x3D;True)[0], p&#x3D;True, s&#x3D;True)[0]\n        point_uvVertex &#x3D; mc.polyListComponentConversion(point, fv&#x3D;True, tuv&#x3D;True)\n        point_uvposition &#x3D; mc.polyEditUV(point_uvVertex[0], q&#x3D;1)\n\n        follicle &#x3D; mc.createNode(&quot;follicle&quot;, n&#x3D;&quot;follicle_%s&quot; % point.replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;, &quot;&quot;).replace(&quot;.&quot;, &quot;_&quot;))\n        follicle_transform &#x3D; mc.listRelatives(follicle, p&#x3D;True)[0]\n\n        mc.connectAttr(poly_transform + &quot;.worldMatrix[0]&quot;, follicle + &quot;.inputWorldMatrix&quot;)\n        mc.connectAttr(poly_transform + &quot;.outMesh&quot;, follicle + &quot;.inputMesh&quot;)\n        mc.connectAttr(follicle + &quot;.outTranslate&quot;, follicle_transform + &quot;.translate&quot;)\n        mc.connectAttr(follicle + &quot;.outRotate&quot;, follicle_transform + &quot;.rotate&quot;)\n        mc.setAttr(follicle_transform + &quot;.parameterU&quot;, point_uvposition[0])\n        mc.setAttr(follicle_transform + &quot;.parameterV&quot;, point_uvposition[1])\n\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    vertexs &#x3D; mc.ls(sl&#x3D;True,fl&#x3D;True)\n    buildFollicle(vertexs)\n\n\n注意：在添加了定位的毛囊之后，不能修改UV，否则毛囊会回到原点，约束失效，需要重新创建毛囊和约束。\n参考官网中相关的介绍：https://help.autodesk.com/view/MAYAUL/2018/CHS/?guid=GUID-A0D2DD53-FE41-4244-8635-CD4651ABF97F\n","categories":["Maya","小工具"],"tags":["灯光","UV"]},{"title":"一些好用的网站","url":"/posts/20220501a2.html","content":"本文推荐一些多快好省的网站、技术大佬的博客网站、专业网站。\n\n\n图标下载\n\nIcon图标下载：https://icon-icons.com/zh/\n阿里巴巴矢量图库：https://www.iconfont.cn/\n图片格式转换： https://www.butterpig.top/ico/\n动态图标库：https://loading.io/\n开源图标网站1：https://remixicon.com/\n开源图标网站2：https://iconpark.oceanengine.com/home\n开源图标网站3：https://iconoir.com/\n开源图标网站4：https://feathericons.com/\n\n\n影视行业软件下载网站：\n\n画忆大佬的软件下载网站(无毒无公害)：www.iiicg.com\nnuke插件网 站：www.nukepedia.com\n\n\n技术大佬们的博客网页\n\nTD手册：https://cg-td-course.readthedocs.io/zh_CN/latest/index.html\n凌云大佬技术博客分享：https://lingyunfx.com/\n汝小右大佬博客：https://ruben.blog.csdn.net/?type=blog\n\n\n行业官网\n\nMaya2022 用户文档：https://help.autodesk.com/view/MAYAUL/2022/CHS/\nYeti 用户文档：https://support.peregrinelabs.com/support/solutions/66000172201\nArnold 用户文档：https://www.arnoldrenderer.com/news/\nNuke 用户文档：https://learn.foundry.com/nuke/13.1/content/learn_nuke.html\nKatana 用户文档：https://learn.foundry.com/katana/5.0/Content/learn_katana.html\nDeadline 用户文档：https://docs.thinkboxsoftware.com/\nPyside2 用户文档：https://wiki.qt.io/Main \n\nhttps://doc.qt.io/qtforpython-5/modules.html\n\n\n\n\nShotGrid 用户文档：https://help.autodesk.com/view/SGSUB/CHS/\nAutoIt3 用户文档：https://www.autoitscript.com/autoit3/docs/\nUSD 用户文档：https://graphics.pixar.com/usd/release/index.html\nUE4 官网：https://www.unrealengine.com/zh-CN\nACES 用户手册：https://acescentral.com/knowledge-base-2/\nRez 用户手册：https://github.com/AcademySoftwareFoundation/rez\n\n\n\n","categories":["Doc"],"tags":["网站推荐"]},{"title":"QT中的系统托盘图标和系统消息推送","url":"/posts/20220501a1.html","content":"本文记录: 使用 PySide2 编写工具界面时，需要为工具创建系统托盘图标以及推送消息的方法。以方便用户对工具进行操作。\n\n\n通过 PySide2 创建系统托盘，需要使用 PySide2.QtWidgets.QSystemTrayIcon 这个类。这个类中需要使用了以下常用方法，就可以创建最基本的系统托盘图标：\n\n\nQSystemTrayIcon   创建一个系统托盘对象\nQSystemTrayIcon.setContextMenu    添加右键菜单(QMenu)\nQSystemTrayIcon.showMessage   在右下角弹出要提示消息\nQObject.connect 连接信号和槽\n\n使用上面的方法，可以完成：\n\n在系统托盘中创建一个程序图标。\n\n  \n\n在程序创建完成托盘图标后，推送一条提示程序已经启动的系统消息。\n\n  \n\n鼠标点击图标时的左右键功能。\n\n  \n代码示例如下:\nimport sys\nfrom PySide2.QtWidgets import QApplication, QAction, QMenu, QSystemTrayIcon\nfrom PySide2.QtCore import SIGNAL, QObject\nfrom PySide2.QtGui import QIcon\n\ndef close():\n    print(&quot;close&quot;)\n\ndef restart():\n    print(&quot;restart&quot;)\n\ndef show():\n    print(&quot;show&quot;)\n\napp &#x3D; QApplication(sys.argv)\n\nexit &#x3D; QAction(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu.ico&quot;), &quot;Exit&quot;, )\nQObject.connect(exit, SIGNAL(&quot;triggered()&quot;), close)\nres &#x3D; QAction(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu1.ico&quot;), &quot;Restart&quot;, )\nQObject.connect(res, SIGNAL(&quot;triggered()&quot;), restart)\n\nmenu &#x3D; QMenu()  # 创建菜单，添加菜单选项\nmenu.addAction(exit)\nmenu.addAction(res)\n\ntrayIcon &#x3D; QSystemTrayIcon(QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu4.ico&quot;))  # 创建系统托盘\ntrayIcon.setContextMenu(menu)\nQObject.connect(trayIcon, SIGNAL(&quot;activated(QSystemTrayIcon::ActivationReason)&quot;), show)\n\ntrayIcon.show()\ntrayIcon.setToolTip(&quot;启动器&quot;)\ntrayIcon.showMessage(&quot;启动器已经启动!&quot;, &quot;左击显示窗口\\n右击显示菜单&quot;, QIcon(&quot;E:&#x2F;Python_study&#x2F;startLauncher&#x2F;Icon&#x2F;Menu_Note1.ico&quot;))\n\nsys.exit(app.exec_())\n\n\n执行代码后，会在电脑桌面系统托盘创建一个本程序的图标，同时会推送一条启动信息，该信息会自动收回。上面的代码没有判断点的是左还是右键，所以只要鼠标点击图标都会先打印一遍 “show”,请自行判断。\n","categories":["Qt","学习笔记"],"tags":["学习笔记","QT事件","信号&槽","系统托盘图标和消息"]},{"title":"USD框架的搭建","url":"/posts/20220421a1.html","content":"今天来介绍一下 windows 环境下 USD 的独立安装过程。首先，我们需要了解几个网站：\nUSD 的帮助文档 ：https://graphics.pixar.com/usd/release/index.html\nUSD 的Github仓库 ：https://github.com/PixarAnimationStudios/USD\n\n安装准备：需要准备：Python2、Cmake、NASM、Microsoft Visual Studio2017、Microsoft Visual Studio Code\n1. 确认环境中有Python2。在 windows 上安装 USD 需要我们的环境中有 Python， 由于 USD 目前还不支持Python3 ，因此我使用的是 Python2.7.16 ,没有Python2 的小伙伴可以从官网下载，下载安装好后，需要调整一下环境变量的顺序，将Python2的相关环境变量提升到Python3的前面，这样可以在后面安装的时候直接调用Python2的环境,就不会出现一些奇怪的问题导致安装失败，如下图。\n\n\n2. 安装CMAKE工具，如果电脑上没有CMAKE，可以从这里下载，往下翻，找到相应的平台和系统版本，下载到一个可安装的文件，使用默认安装就好。\n\n\n3. 安装NASM，如果电脑上也没有NASM，则可以从这里下载，打开链接后选择一个合适的版本，我使用的是2.15.05版本的NASM，双击文件夹，选择自己系统对应的文件夹，再次双击，可以看到一个安装程序，点击即可下载，没有特殊需求的话，尽量使用默认安装。\n\n\n4. 安装Microsoft Visual Studio，USD 暂时不支持较新的版本，本案例使用的是VS2017版本，可以从这里下载，选择一个合适的版本，安装过程中选择使用C++的桌面开发。\n\n5. 安装Microsoft Visual Studio Code，如果没有VSCode，可以从这里下载，选择一个合适的版本，下载后默认安装好，打开下载Python拓展插件，并将上面安装的Python2的执行程序路径填入对应位置，如下图所示。\n\n\n\n\n\n接下来我们还需要为Python2安装一些功能模块：PySide、pyd、pyopengl、Jinja2，在cmd中依次执行下面的指令即可\npip install PySide\npip install pyd\npip install pyopengl\npip install Jinja2\n注：这里如果出现“pip Fatal error in launcher: Unable to create process...”错误，可以通过python安装文件的修复功能来解决，点击repair。\n\n构建 USD先从USD 的Github仓库下载 USD 源码到本地，打开“x86 Native Tools Command Prompt VS 2017”界面，这里不能使用x64,并且对于高版本的VS,不管是\"X64\" 还是 \"x86\" 均不能安装成功。输入 python \"你的USD源码下载位置\"\\build_scripts\\build_usd.py \"C:\\USD\" ，其中\"C:\\USD\"是你的安装位置（安装位置中似乎不能有空格，我尝试了几次将usd安装在带空格的\"Program Files (x86)\"中，都没有成功）。程序会自动为你安装zlib，boost，TBB，OpenSubdiv用来构建USD环境。这个过程只有简单的几条语句提示，没有进度条，并且可能会报错或者安装不成功（也许是下载速度的原因），多执行几次上面的构建指令就好了，我也是安装了三次才成功。成功后会提示你，需要将 \"C:\\USD\\lib\\python\"添加进系统变量PYTHONPATH中，再在系统变量 PATH 中添加 \"C:\\USD\\bin\" 和 \"C:\\USD\\lib\"两个路径，如下图所示。\n\n\n至此USD环境就搭建好了。\n验证打开一个cmd窗口，cd 进入你的USD源代码目录,然后输入指令：“usdview .\\extras\\usd\\tutorials\\convertingLayerFormats\\Sphere.usd”，出现下面的界面就表示成功了。\n\n接下来就可以愉快地学习案例了！！！\n参考文章\nhttps://zhuanlan.zhihu.com/p/437422802\nhttps://github.com/PixarAnimationStudios/USD/blob/release/README.md#getting-and-building-the-code\n\n","categories":["Doc","学习笔记"],"tags":["USD","Pipeline"]},{"title":"QT中的异形窗口","url":"/posts/20220326a2.html","content":"记录一下 QT 中异形窗口的创建。\n主要标志在 QWidget 中，通过给窗口设置特定的标志，可以将窗口设置为不同的形状，比如让窗口无标题，或者直接让主窗口透明\nsetWindowFlags(Qt.FramelessWindowHint)      # 去掉标题栏\nsetMask(QPixmap(img).mask())                # 设置图片透明的地方为穿透\nsetAttribute(Qt.WA_TranslucentBackground)   # 设置窗口透明\n\n当为窗口设置了使用图片作为 Mask 遮罩后，Qt.FramelessWindowHint 标志会自动指定。\n实现示例创建一个基本窗口# Author: Mirror\nimport sys\nfrom PySide2.QtWidgets import QApplication, QWidget\nfrom PySide2.QtCore import Qt\nfrom PySide2.QtGui import QPixmap\n\nclass MainWindow(QWidget):\n    def __init__(self,):\n        super().__init__()\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    app &#x3D; QApplication(sys.argv)\n    form &#x3D; MainWindow()  # 实例化窗口小部件\n    form.show()\n    sys.exit(app.exec_())\n\n窗口效果\n设置窗口标志self.setWindowFlags(Qt.FramelessWindowHint)  # 去掉标题\n\n窗口效果窗口会变成一块没有标题的白板\n设置窗口Maskself.starticon &#x3D; QPixmap(r&quot;ImagePath&quot;)\nself.setMask(self.starticon.mask())\n\n窗口效果窗口会根据你使用的 Mask 图片进行裁剪\n窗口重写事件由于窗口被设置为无标题窗口后，鼠标不能对窗口进行移动，因此，我们还需要将窗口的鼠标事件进行重写。完整代码：\n# !&#x2F;user&#x2F;bin&#x2F;python37\n# -*- coding: utf-8 -*-\n# Author:Mirror\n# Time: 2022&#x2F;03&#x2F;26\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport sys\nfrom PySide2.QtWidgets import QApplication,QWidget\nfrom PySide2.QtCore import Qt\nfrom PySide2.QtGui import QPixmap, QCursor\n\nclass MainWindow(QWidget):\n    def __init__(self,):\n        super().__init__()\n        self.setWindowFlags(Qt.FramelessWindowHint)  # 去掉标题（还有一些别的窗口类型选择，请自行查阅）\n        self.starticon &#x3D; QPixmap(r&quot;E:\\Python_study\\startLauncher\\Icon\\startBackgroundMask.svg&quot;)\n        self.setMask(self.starticon.mask())\n\n    # 鼠标按下\n    def mousePressEvent(self, event):\n        if event.button() &#x3D;&#x3D; Qt.LeftButton:\n            self.m_drag &#x3D; True  # 鼠标按下或抬起标志位\n            self.m_DragPosition &#x3D; event.globalPos() - self.pos()  # 当前单击点相对于窗口本身的坐标(只检测窗口中的点击)\n            self.setCursor(QCursor(Qt.SizeAllCursor))  # 设置光标形状 小手抓取\n\n        if event.button() &#x3D;&#x3D; Qt.RightButton:  # 按下右键 取消左键按下，结束鼠标移动时间\n            if self.m_drag &#x3D;&#x3D; True:\n                self.m_drag &#x3D; False\n\n    # 鼠标移动\n    def mouseMoveEvent(self, QMouseEvent):\n        if Qt.LeftButton and self.m_drag:\n            # 当左键移动窗体修改偏移值\n            self.move(QMouseEvent.globalPos() - self.m_DragPosition)\n\n    # 鼠标抬起\n    def mouseReleaseEvent(self, QMouseEvent):\n        self.m_drag &#x3D; False\n        self.setCursor(QCursor(Qt.ArrowCursor))\n\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    app &#x3D; QApplication(sys.argv)\n    form &#x3D; MainWindow()\n    form.show()\n    sys.exit(app.exec_())\n\n通过上面的代码，我们就可以获得一个可以被鼠标移动的异形窗口啦。\n","categories":["Qt","学习笔记"],"tags":["学习笔记","QT事件","异形窗口"]},{"title":"QT中QToolButton的双击事件","url":"/posts/20220326a1.html","content":"前言写工具界面的时候，发现 QPushButton 按钮不能被图标完全覆盖，而选择使用 QToolButton 按钮，但是 QToolButton 按钮本身是没有双击事件的，我在写工具的时候又对这个双击事件很执着，就自己实现一下，并为该结果做记录。\n\n实现逻辑要实现 QToolButton 按钮的双击事件：需要新建一个继承于 QToolButton 的子类，该类继承 QToolButton 的 click 鼠标单击事件，添加 singleClicked 和 doubleClicked 两个信号用于发送我们想要的单/双击信号，并在子类中添加一个 Qtimer 作为判断依据：将 QTimer 设置为单次触发, 并为QTimer 设定一个较短的时间，在该时间内，click信号链接到事件判断函数，如果再次点击该按钮则判断为双击事件，同时将 QTimer 停止；反之 QTimer 超时，QTimer 发送超时信号到单击事件函数，也需要将Qtimer 停止。当实例化这个子类后，点击按钮，该 click 信号即在实例内部进行判断。\n\n代码示例# !&#x2F;user&#x2F;bin&#x2F;python37\n# -*- coding: utf-8 -*-\n# Author:Mirror\n# Time: 2022&#x2F;03&#x2F;26\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport sys\nfrom PySide2.QtWidgets import QApplication, QToolButton\nfrom PySide2.QtCore import Qt, Signal, QTimer\n\nclass DccButton(QToolButton):\n    &quot;&quot;&quot;定义ToolButton按钮双击事件&quot;&quot;&quot;\n    doubleClicked &#x3D; Signal()  # 双击信号\n    singleClicked &#x3D; Signal()  # 单击信号\n    def __init__(self):\n        super(DccButton, self).__init__()\n        self.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)  # 设置图标在字体之上\n        self.timer &#x3D; QTimer()  # 创建触发器\n        self.timer.setSingleShot(True) # 仅单次触发\n        self.timer.setInterval(200) # 触发间隔，用于判断是否为双击\n        self.timer.timeout.connect(self.singleClick) # 超时信号连接至单击\n        self.clicked.connect(self.checkDoubleClick) # 连接至成员函数判断是否为双击\n\n    def singleClick(self):\n        &quot;&quot;&quot;\n            发送单击信号\n        &quot;&quot;&quot;\n        self.timer.stop()\n        self.setDown(False)\n        self.singleClicked.emit()\n        print(&quot;单击&quot;)\n\n    def checkDoubleClick(self):\n        &quot;&quot;&quot;\n            判断是否为双击信号，否则信号超时\n        &quot;&quot;&quot;\n        if not self.isDown():\n            self.setDown(True)\n        if self.timer.isActive():\n            self.timer.stop()\n            self.setDown(False)\n            self.doubleClicked.emit()\n            print(&quot;双击&quot;)\n            return\n        else:\n            self.timer.start()\n\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    app &#x3D; QApplication(sys.argv)\n    form &#x3D; DccButton()\n    form.show()\n    sys.exit(app.exec_())\n","categories":["Qt","学习笔记"],"tags":["学习笔记","QT事件","信号&槽"]},{"title":"rez安装使用","url":"/posts/20220314a1.html","content":"Rez 是一个跨平台程序包管理器，通过它可以给程序配置独立的环境，每个独立环境中只是引用了这些包。所以它的环境配置是轻量级的，与其它程序包环境管理不同的是，所有的程序包都安装在一个中央统一的位置，尽管有几百个包，通常也只需要几秒就可以进行配置。将 Rez 作为工作室 DCC 软件启动器依赖项，是个不错的选择。下面将简单介绍 Windows 环境下，Rez 包管理器如何安装使用。\n下载安装包从 GitHub 上拉取 Rez 原项目的的相关仓库，然后打开CMD进入拉取仓库所在的目录中执行(建议在C盘根目录)：\npython .&#x2F;install.py \n这将会把包安装在当前位置的 &#x2F;opt&#x2F;rez 目录下也可以使用Pip进行安装：\npip install rez\n但使用 pip 的安装方式并不能很好的用在生产环境中,使用 install 脚本安装是推荐的方法，它可以保证 Rez 拥有独立 python 于的环境独立运行。安装完成后，cmd中会出现提示信息。然后，需要在环境变量 PATH 中添加值 ‘安装rez的路径’&#x2F;opt&#x2F;rez&#x2F;bin&#x2F;rez。\n创建基本的 Rez 包这里需要使用管理员权限去安装包，rez-bind 工具创建基于已安装在系统上的软件的 Rez 包：（–quickstart是以标准形式安装包）\nrez-bind --quickstart\n你也可以分开安装\nrez-bind platform\nrez-bind arch\nrez-bind os\nrez-bind python\n安装好之后，会在 %userprofile%&#x2F;packages 目录下找到已经安装的 Rez 包\n验证安装结果为了验证是否安装成功，可以使用下面的命令：（其中 “which python”是你的python版本）\nrez-env python-which python\n使用 exit 退出环境。\n构建第一个包.需要确认%userprofile%&#x2F;packages 存在且可写入.需要确认cmake 工具安装且可用（注：官方文档中会使用这个工具在ios系统上安装下面的包，但我还未在Windows10系统上成功安装该包，似乎有些依赖包的冲突问题，但好像不影响使用，正在求证中。。。）rez-build 工具用于构建包并在本地安装它们（%userprofile%&#x2F;packages下）。 完成后，您可以通过 rez-env 使用它们，就像任何其他软件包一样：\ncd example_packages&#x2F;hello_world\nrez-build --install\n\n测试构建的包使用rez-env命令来请求一个（或多个）你已经安装的软件包环境\nrez-env hello_world\n提示符前的插入符号 (&gt;) 是一个视觉提示，告诉你现在位于 rez 配置的子 shell 中。 Rez 不会更新当前环境，而是配置一个子shell 并将你置于其中。如果你已经在rez shell的配置环境中，并且忘记了当前可用的软件包列表。可以使用 rez-context 工具查看：\nrez-context\n退出这个环境，使用exit命令。\n你还可以创建一个已配置的环境并在其中运行一个命令，只需一个命令。 当您使用这种形式时，shell 会在命令运行后立即退出：\nrez-env hello_world -- hello \n\n\n软件包命令查看搜索路径:\nrez-config\n\n查看当前配置环境：\nrez-context\n\n\n在共享路径下搜索插件包首先，需要为系统设置配置文件的用户环境变量 REZ_CONFIG_FILE 指向 rezconfig.py文件；为系统用户的环境变量中添加环境变量 REZ_CONFIG_FILE ，并且值为”S:\\opt\\rez\\Lib\\site-packages\\rez\\rezconfig.py”(本文将 rez安装在S盘，对应安装的根目录即可)，然后添加插件包的存放路径即可，若不添加环境变量，则默认从安装路径获取配置文件信息。下面是配置文件中，通过修改packages_path变量修改获取共享路径中的插件路径：\n# The package search path. Rez uses this to find packages. A package with the\n# same name and version in an earlier path takes precedence.\npackages_path &#x3D; [\n    &quot;~&#x2F;packages&quot;,           # locally installed pkgs, not yet deployed\n    &quot;~&#x2F;.rez&#x2F;packages&#x2F;int&quot;,  # internally developed pkgs, deployed\n    &quot;~&#x2F;.rez&#x2F;packages&#x2F;ext&quot;,  # external (3rd party) pkgs, such as houdini, boost\n    &quot;S:&#x2F;rez&#x2F;packages&#x2F;dcc&quot;,  # dcc软件共享路径\n    &quot;S:&#x2F;rez&#x2F;packages&#x2F;plugins&quot;,  # 插件共享路径\n    &quot;S:&#x2F;rez&#x2F;packages&#x2F;third_party&quot;, # 第三方插件路径\n    &quot;S:&#x2F;rez&#x2F;packages&#x2F;tools&quot; # 自定义工具路径\n]","categories":["Rez"],"tags":["Pipeline","包管理"]},{"title":"CG流程中\"USD\"的探索与运用","url":"/posts/20220307a1.html","content":"\nUSD部分名词中文概述点击这里查看。\nmaya输出USD：当一个USD文件输出错误，不能用于reference要重新输出USD文件时，需将错误的文件删除再输出USD文件（覆盖无效依旧会使用内存中暂存的USD数据），若不删除，即使设置正确，输出的数据依旧是错误的（maya2023.0测试结果）。\n从maya导出usd,不勾选任何材质球，导入后即为干净的模型USD文件。\n导出设置“Create USD Parent Scope”可用于编辑Layerusd时，识别usd文件中的prom模型分类，在USD文件中会将defaultPrim值设置为“Create USD Parent Scope”的值，并且会在xfrom外多定义一层Scope。\n\n\n\nmaya2023 自身的USD导出的USD数据，其中材质网络的部分虽有记录但不能在maya中直接使用。\nmaya2023 自身的USD导出的USD数据，可以reference但是没材质，不能用于Arnold的StandIn;arnold插件导出的USD数据，携带ArnoldOptions设置。其可以用于StandIn，也可以用于USD层编辑器，但是不能reference。\n目前maya 2023 自身的USD功能以及Arnold的USD功能还不完善，还有许多功能需要开发才能用于项目流程中。\n\n————— 更新于2022-06-01 —————\n","categories":["Doc","学习笔记"],"tags":["USD","Pipeline"]},{"title":"Deadline中的事件示例","url":"/posts/20220306a1.html","content":"此文章是记录Deadline农场管理软件中的消息事件插件编写的示例。\n事件插件的作用和执行顺序Deadline 的所有插件都是Python写的，事件插件可用于更新新快照或任务的状态，或者可用于在一个作业状态更改时处理相关的作业。并且插件都是以非交互式的方式执行，编写插件时不应该包含阻塞操作(如无限循环)或需要用户输入的界面。当我们的事件插件被执行时，日志中会显示插件是从哪里加载的。Deadline中有很多事件，事件插件的触发是按顺序的，并且顺序是可配置的：\n\n创建事件脚本首先要在存储库的custom\\events文件夹中创建一个文件夹，并为其命名您的事件插件，如：\n\n创建好文件夹后，我们需要新建一个和该文件夹相同明明的 .py 文件，并在文件中写入相应的基本内容（导入deadline事件命名空间；GetDeadlineEventListener()函数获取MyEvent类的一个实例，没有会报错；MyEvent类将需要基于想要响应的事件实现某些回调；当不再使用该事件插件，CleanupDeadlineEventListener()函数进行自动清理。）：\n\nfrom Deadline.Events import *\n\ndef GetDeadlineEventListener():\n    &quot;&quot;&quot;This is the function that Deadline calls to get an instance of the\n    main DeadlineEventListener class.\n    &quot;&quot;&quot;\n    return MyEvent()\n\ndef CleanupDeadlineEventListener(deadlinePlugin):\n    &quot;&quot;&quot;This is the function that Deadline calls when the event plugin is\n    no longer in use so that it can get cleaned up.\n    &quot;&quot;&quot;\n    deadlinePlugin.Cleanup()\n\nclass MyEvent(DeadlineEventListener):\n    &quot;&quot;&quot;This is the main DeadlineEventListener class for MyEvent&quot;&quot;&quot;\n    # TODO: Place code here to replace &quot;pass&quot;\n    pass\n\n当我们完成上述脚本文件的内容后，我们将会得到下面的脚本内容：\n#!&#x2F;usr&#x2F;bin&#x2F;env python3\n# -*- coding:utf-8 -*-\n# @Auther: Mirror\n# @Time: 2020&#x2F;07&#x2F;01\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nfrom System import *\nfrom System.Collections.Specialized import *\nfrom System.IO import *\nfrom System.Text import *\nfrom Deadline.Scripting import *\nfrom Deadline.Events import *\nimport time\n\n\n######################################################################\n## This is the function that Deadline calls to get an instance of the\n## main DeadlineEventListener class.\n######################################################################\ndef GetDeadlineEventListener():\n    return MyEvent()\n\n\n######################################################################\n## This is the function that Deadline calls when the event plugin is\n## no longer in use so that it can get cleaned up.\n######################################################################\ndef CleanupDeadlineEventListener(deadlinePlugin):\n    deadlinePlugin.Cleanup()\n\n\n######################################################################\n## This is the main DeadlineEventListener class for MyEvent.\n######################################################################\nclass MyEvent(DeadlineEventListener):\n\n    def __init__(self):\n        # Set up the event callbacks here\n        self.OnJobFinishedCallback +&#x3D; self.OnJobFinished\n        self.OnJobFailedCallback +&#x3D; self.OnJobFailed\n\n    def Cleanup(self):\n        del self.OnJobFinishedCallback\n        del self.OnJobFailedCallback\n\n    def OnJobFinished(self, job):\n        # TODO: Connect to pipeline site to notify it that the job for a particular\n        # shot or task is complete.\n        job_name &#x3D; job.JobName\n        job_mach &#x3D; job.GetJobInfoKeyValue(&quot;MachineName&quot;)\n        job_user &#x3D; job.JobUserName\n        if job_mach.lower() &#x3D;&#x3D; &quot;renderfarm&quot;:\n            slaves &#x3D; None\n        else:\n            slaves &#x3D; [job_mach]\n        if slaves:\n            for each in slaves:\n                curr_time &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))\n                slave &#x3D; each\n                massages &#x3D; &quot;Cur_time:  &#123;curtime&#125;\\nJob_user:  &#123;user&#125;\\n\\nmassages:  Job named \\&#39;&#123;jobname&#125;\\&#39; had been complate&quot;.format(\n                    curtime&#x3D;curr_time, user&#x3D;job_user, jobname&#x3D;job_name)\n                self.sendmessages(slave, massages)\n        print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n        self.LogInfo(&quot;\\&#39;%s\\&#39; is complated&quot; % job_name)\n        self.LogInfo(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n\n    def OnJobFailed(self, job):\n        &quot;&quot;&quot;\n        Deadline will to do sometion when job or task is faild\n        :param job: which Work being monitored\n        :return: None\n        &quot;&quot;&quot;\n        job_name &#x3D; job.JobName\n        job_mach &#x3D; job.GetJobInfoKeyValue(&quot;MachineName&quot;)\n        job_user &#x3D; job.JobUserName\n        if job_mach.lower() &#x3D;&#x3D; &quot;renderfarm&quot;:\n            slaves &#x3D; [&quot;DESKTOP-Mirror&quot;]\n        else:\n            if job_mach &#x3D;&#x3D; &quot;DESKTOP-Mirror&quot;:\n                slaves &#x3D; [job_mach]\n            else:\n                slaves &#x3D; [job_mach, &quot;DESKTOP-Mirror&quot;]\n        for each in slaves:\n            curr_time &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))\n            slave &#x3D; each\n            massages &#x3D; &quot;Cur_time:  &#123;curtime&#125;\\nJob_user:  &#123;user&#125;\\nmassages:  Job named \\&#39;&#123;jobname&#125;\\&#39; had been failed&quot;.format(\n                curtime&#x3D;curr_time, user&#x3D;job_user, jobname&#x3D;job_name)\n            self.sendmessages(slave, massages)\n        print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n        self.LogInfo(&quot;\\&#39;%s\\&#39; is failed&quot; % job_name)\n        self.LogInfo(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n\n    def sendmessages(self, slaves, messages):\n        &quot;&quot;&quot;\n        :param\n            slaves: machines&#96;s machines name or IP address.\n            messages: the messages which is send by current serve]\n        :return\n            cmd is executed by system\n        &quot;&quot;&quot;\n        args &#x3D; StringCollection()\n        args.Add(&quot;-SendPopupMessage&quot;)\n        args.Add(&quot;%s&quot; % slaves)\n        args.Add(&quot;%s&quot; % messages)\n        ClientUtils.ExecuteCommand(args)\n\n\n\n创建事件参数文件创建完事件插件的脚本后，我们需要在上述文件夹中为事件插件添加与文件夹同名的参数文件（.param）供 Deadline 进行读取，创建参数界面：\n参数文件内容：\n[State]\nType=Enum\nItems=Global Enabled;Opt-In;Disabled\nCategory=Options\nCategoryOrder=0\nIndex=0\nLabel=State\nDefault=Disabled\nDescription=How this event plug-in should respond to events. If Global, all jobs and slaves will trigger the events for this plugin. If Opt-In, jobs and slaves can choose to trigger the events for this plugin. If Disabled, no events are triggered for this plugin.\n\n[EventCallbacks]\nType=Label\nDescription=The Event Callbacks that this Event Plugin subscribes to.\nDefault=OnJobFailed\n\n它将声明 Monitor 用来生成用户界面的属性，该用户界面用于修改数据库中的自定义设置，创建该文件后，打开监视器并进入超级用户模式。然后选择Tools -&gt; Configure Events，在左边的列表中查找该事件插件。\n\n至此，在 Deadline 中创建自定义任务消息失败&#x2F;成功的事件已经完成，每当Deadline 中有任务失败时&#x2F;成功时，Deadline 会自动给任务的提交者发送一条相关的消息弹框，用于给制作人员反馈及时的渲染消息。\n注意：需要注意 Deadline 当前使用的 Python 版本，避免出现不兼容的情况\n咱们有空可以看看官方文档是怎么说的，里面有更加详细的内容哦。\n官方文档中事件脚本文档","categories":["Deadline","插件"],"tags":["插件"]},{"title":"如何搭建个人博客","url":"/posts/20220302a2.html","content":"作为一名学习任何技术都习惯做笔记的好学生，还在使用思维导图记录知识点？或是用word写文档，甚至是\"白纸黑字\"码字！！！都2202年了，是不是该寻找一种既方便自己随时查找翻看，又可以和小朋友们一起分享知识和经验的方式呢？这时，拥有一个属于自己的个人博客，实属是一个迫在眉睫的需求。于是，我有了自己的博客。接下来将介绍从无到有搭建属于自己的个人博客过程。\n\n准备材料1.一台能联网、没有脑梗的计算机2.Windows系统（我就只会用“窗口”）3.git包管理工具4.一个知道账号和密码的github账号5.记住这个网址，一会儿要用：https://www.nodejs.org/6.随时准备问候度娘，因为我也不清楚你会遇到些什么疑难杂症\n开始搭建本地环境首先，点击下载git，下载适合自己系统的最新git版本安装包，以默认方式安装。 \n然后，我们再在电脑上访问刚才让你记住的网址，从网址上下载我们需要的LTS版node.js安装包，直接双击安装它。不出意外的话，安装好的node.js会给你反馈安装了两个组件（node.js和npm包管理工具），我们可以直接去cmd中验证。\n\n打开cmd,利用npm包管理工具安装今天的主角Hexo博客，先输入命令行安装cnpm的同时将镜像源指向淘宝：\n\nnpm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org\n\n安装hexo-cli：\n\ncnpm install -g hexo-cli\n\n找个你觉得合适的位置创建一个文件夹，用于存放你的博客产生的所有文件，在cmd中将路径切换到创建的文件夹：\n\ncd &#x2F;d &quot;你刚刚创建的文件夹路径&quot;\n\n初始化咱们的博客目录：\n\nhexo init \n\n启动我们的Hexo本地服务，可在https://localhost:4000访问，但博客中只有一篇和hexo用户指南相关的文章：\n\nhexo s\n\n如果网页打不开，win10执行下面代码后再重复上一步： \n\nnpm install hexo-server\n\n创建新的博客文章： \n\nhexo new &quot;我的第一篇博客文章&quot;\n\n创建好后，在刚刚创建的博客文件夹的\\source\\_posts\\路径下能看到刚才创建的\"我的第一篇博客文章.md\"文件，用文本编辑器即可对内容进行编辑，然后刷新https://localhost:4000，就能看到刚刚创建的博客文章出现在网页上，ctrl + C 退出本地服务，。\n\n清除产生的静态博客文件(public)文件夹： \n\nhexo clean\n\n\n构建存储库登录github,创建一个新的仓库用于存储从本地推送的静态博客文件：repository neme 必须是：\"GitHub昵称加.github.io\"，description添加自定义描述，创建库。\ncmd下载hexo插件：\n\ncnpm install --save hexo-deployer-git\n\n文本打开博客文件夹根目录下的\"_config.yml\"文件，在文件尾部添加在文件尾部添加：\n\n## 添加储存库配置\ndeploy:\n  type: git\n  repo: (你的储存库地址)\n  branch: master \n## 注意：冒号后面有空格\n\n要将博客部署到github上，需要先配置git全局用户名和邮箱：\n\ngit config --global user.email &quot;github中的邮箱地址&quot;\ngit config --global user.name &quot;github中的用户名&quot;\n\n从22021年8月14日(七夕)那天开始，推送代码到GitHub需要使用token登录而不是密码，因此，我们需要先获取token。\n\n使用git生成SSH，运行 git Bash 客户端，检测是否存在ssh文件,换句话说就是检查是否存在 id_rsa.pub 或 id_dsa.pub 文件,如果存在可以跳过下面两步，输入如下代码：\n\ncd ~&#x2F;.ssh\nls\n\n创建SSH：\n\nssh-keygen -t rsa -C &quot;你的邮箱&quot;\n\n等待一会儿，当看到\"Your identification has been saved in /c/Users/you/.ssh/id_rsa.\nYour public key has been saved in /c/Users/you/.ssh/id_rsa.pub.\nThe key fingerprint is:.............\"内容时，表示创建成功。在C盘User文件夹（可能会在桌面）可以找到ssh文件夹， 需要把id_rsa.pub文件中的内容添加到github。步骤是 Settings-->SSH and GPG Keys --->News SSH key，然后把id_rsa里的内容复制进去。\n\n回到cmd,部署博客到Github,两次输入都需要输入用户名和令牌(令牌不要手动输入，可以直接复制粘贴，尽管看不到粘贴内容，但还是要操作，才能成功):\n\nhexo d\n\n稍等两分钟，就可以访问博客页啦：https://github昵称加.github.io\n\nnote: 若推送过程中出现下列警告：\nwarning: LF will be replaced by CRLF in tags&#x2F;XXXX&#x2F;index.html.The file will have its original line endings in your working directory\n\n这只是一个警告，我们直接忽略就好。或者，可使用全局配置来禁用自动转换：\ngit config --global core.autocrlf false\n\n更换主题可以 点击这里 获取更多主题仓库地址，克隆主题到本地：\n\ngit clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;主题名称\n\n修改博客根目录_config.yml文件，修改theme字段后的内容为 “主题名称”。\n\n清理hexo目录：\n\nhexo clean\n\n重新生成hexo静态博客文件夹及其内容：\n\nhexo g\n\n推送远端：\n\nhexo d\n\n\n大佬的博客搭建教程视频：点击这里，更多的部署细节可在视频中找到哦。\n\n博客评论在cleanCloud上托管valine评论通过cleanCloud发送邮件https://github.com/DesertsP/Valine-Admin.git 远程库https://github.com/DesertsP/Valine-Admin  评论邮箱通知\nhttps://to35uwtu.lc-cn-n1-shared.com   Request 接口AKISMET_KEY  e79de4c39e2c  垃圾评论过滤器键值\nhttp://www.cimoc.cn/2022/02/16/hexo-next-valine-leancloud/https://github.com/DesertsP/Valine-Admin\n","categories":["Doc","学习笔记"],"tags":["Blog","Hexo","github"]},{"title":"CG流程中使用ACES色彩管理","url":"/posts/20220302a1.html","content":"构建CG流程中的ACES色彩管理流程 ,为什么要构建呢？因为：1.色域更高，能容纳更多的色彩，显示的色彩更丰富；2.能接受更高的灯光强度，画面比较不会过曝（不要调皮地将灯光强度调的特别高哦）;3.更物理更真实，颜色会随着亮度地提升，饱和度逐渐降低。相对的就会有些缺点：图片占用存储空间会变大(对影视动画没什么影响)。\n在CG流程中的大概过程就是，sRGB图片进入DCC软件被AECScg线性转换函数转换编码到ACES色域中被管理&gt;渲染器处理贴图信息后生成ACES色域图片&gt;经过编码转换到视图中显示或输出为指定色域的图片用于存储(srgb或ACES)、进一步编辑（ACES）\n测试环境Substance painter 7.1 + Doc 2020.4 + Nukel2.3 + ACES1.1\n\nSP软件配置由于SP要在7.4版本以后才支持 OCIO 配置文件，并且目前大部分资产贴图都采用sRGB色域编码，因此默认使用传统 SP(sRGB)到 MAYA(ACES) 中进行 sRGB 色域空间转换到 ACES 色域空间的方式。传统SP流程可以通过LMT(外观转换)的LUT(查找表)文件用于显示（只是看起来和AECES差不多，但实际上还是SRGB色域的图片）具体方法是：file > import resource > 添加资源 > 选择Lut文件 > 修改定义为 colorLut > 导入到\"工具架\" > 导入，然后在显示设置中将 activate post effects恢复默认,勾选activate post effects，勾选activate post effects > tone mapping(色调映射),将 activate post effects > tone mapping > function(功能)设置为log(日志)，并勾选activate color porfile > porfile 修改为 ACES_Standard_log,white_Point 设置为默认值，此时我们从SP软件的视口中看见的色彩在视觉上基本等同ACES色域图显示的效果。\n\nMay启动时配置 ACES 色彩管理Maya中使用 ACES 色彩管理空间，在具备有效的 config.ocio 配置文件的情况下，为 Maya 设置环境变量\"OCIO = 文件全路径\",此时Maya中的色彩管理空间将使用 OCIO 配置文样中的设置，该设置会在基于ACES 色彩管理的基础上自动修改渲染预览界面和视图界面的色彩空间，我们在显示器中看到的色彩信息并非线性空间的色彩信息，Maya后台输出的图片也是经 ACES 色彩空间编码后的图片，此时将渲染图片放入使用相同 ACES 配置文件的 Nuke 软件中，即可直接对 ACES 图片进行线性数据的操作。\n\n\nMaya 应用 OCIO 输入色彩空间规则到图片使用 OCIO 配置文件后，若勾选\"使用 OCIO 输入颜色空间规则\"则会使用\"OCIO Standard Rule\"对输入的文件进行色彩空间的转换，若不使用，则需要手动制定规则（自定义的配置不起作用时，可尝试将软件切成英文版)，然后将自定义的标准的色彩管理策略导出为 CM 文件,并添加环境变量\"MAYA_COLOR_MANAGEMENT_POLICY_FILE=CM文件全路径\"、\"MAYA_COLOR_MANAGEMENT_POLICY_LOCK=1\",用以全局配置所有渲染制作机，使保持相同的色彩配置，手动指定规则将按照规则的从上往下的顺序应用规则，由匹配成功的第一个规则指定输入的色彩空间。\n\n\n色彩空间管理的其他设置Ui 设置:启用后 Maya中的色彩盒子会显示得较灰一些，但不影响 ACES 色域着色。\n\n浮点渲染目标:开启色彩管理后，该选项也应该开启,才能在 Maya2020 中查看到正确的显示结果，并且应该使用32位格式，否则可能会出现色彩信息的裁剪，显示不正确，吸管吸取不到正确的色彩信息等情况。导出 CM 首选项：将自定义的色采管理首选项导出到指定的 CM 文件中，可用于软件启动的环境变量。\nNuke 中配置使用 ACES 色彩管理手动配置：\n仅为当前项目配置 ACES:\n打开软件后，按S键进行项目配置：点击 project setting >color栏，将\"color management\"修改为\"OCIO\",将COIO_config 修改为\"custom\", 然后将 OCIO 配置文件填入“custom_OCIO_config\"选项中（需保证Nuke中使用的 OCIO 配置文件和 MAYA 中使用的保持一致)或选择 Nuke 自带的 OCIO 配置文件，然后Nuke 即可自动设置部分常用的色彩空间编码设置。对于实拍源素材需要单独配置 Lut格式。\n\n  \n为 Nuke 默认启动配置 ACES\n为软件默认配置:\n1.打开Nuke首选项:选择 Color Management 选择 Nuke 自带的 OCIO 配置或使用自己的 OCIO 配置，即可为软件配置 ACES 色彩管理空间，重启软件即可生效。\n2.环境变量配置，启动环境中添加环境变量：OCIO = 文件位置\n\n\n\nNuke 输出sRGB素材对于使用EXR输出作为合成过程的中间素材，使用默认的 ACES 色域编码的exr格式文件，保持图片信息的完整，勾选\"输出保持ACES 兼容的EXR\"；输出序列时，则直接转回sRGB色域编码（使用output_srgb编码方式输出）\n\n\n\n\n\n\n相关软件插件下载链接Substance Painter插件滤镜：https://pan.baidu.com/s/1FFpBeih902gMJWVQrzEwbw 提取码: anqqOCIO配置文件下载地址：https://github.com/colour-science/OpenColorIO-Configs/tree/feature/aces-1.2-config\n","categories":["Doc","学习笔记"],"tags":["灯光合成","ACES","学习笔记"]},{"title":"Maya获取选中相机视角中的所有对象","url":"/posts/20220228a1.html","content":"从Maya视图窗口中获取相机视角中所有的对象，可以利用OpenMaya和OpenMayaUI两个模块来完成此功能，首先需要指定相机，并通过遍历相机视口，来获取相机视口中的对象：\n\n#!&#x2F;usr&#x2F;bin&#x2F;env python\n# -*- coding:utf-8 -*-\n# @Auth0r: Mirror\n# @Time: ----\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\nimport maya.cmds as cmds\nimport maya.OpenMaya as OpenMaya\nimport maya.OpenMayaUI as OpenMayaUI\n\n\ndef getObjInView(cam):\n    # 添加相机到 MDagPath\n    mdag_path &#x3D; OpenMaya.MDagPath()\n    sel &#x3D; OpenMaya.MSelectionList()\n    sel.add(cam)\n    sel.getDagPath(0, mdag_path)\n\n    # 遍历视口\n    draw_traversal &#x3D; OpenMayaUI.MDrawTraversal()\n\n    # 创建视锥\n    draw_traversal.setFrustum(mdag_path, cmds.getAttr(&quot;defaultResolution.width&quot;),cmds.getAttr(&quot;defaultResolution.height&quot;))\n    draw_traversal.traverse()\n    frustum_objs &#x3D; []\n\n    # Loop through obiects within frustum\n    for i in range(draw_traversal.numberOfItems()):\n        # 先返回shape, 所以需要先获取它的transforn\n        shape_dag_path &#x3D; OpenMaya.MDagPath()\n        draw_traversal.itemPath(i, shape_dag_path)\n        transform_dag_path &#x3D; OpenMaya.MDagPath()\n        OpenMaya.MDagPath.getAPathTo(shape_dag_path.transform(), transform_dag_path)\n        # 获取物体的长名并且确保它是有效的transform\n        obj &#x3D; transform_dag_path.fullPathName()\n\n        if cmds.objExists(obj):\n            frustum_objs.append(obj)\n            cmds.select(frustum_objs)\n\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    # 需要指定相机\n    cam &#x3D; &#39;persp&#39;  # 指定相机\n    getObjInView(cam) \n\n","categories":["Maya","杂项"],"tags":["OpenMaya"]},{"title":"Maya获取指定物体到Camera焦点平面的距离","url":"/posts/20220227a1.html","content":"文章介绍在Maya中获取物体到相机焦点所在平面的距离，并将获取到的距离写入相机的焦距属性，使用Arnold渲染。\n本文介绍两种获取相机焦距的方法提供参考：一种是利用向量计算的办法计算向量之间的投射长度获取焦距，另一种是使用约束的方式获取焦距。\n\n方法一：计算向量在三维空间中，已知相机单位向量、位置和物体坐标，可计算出相机焦点到物体的距离（该距离并非我们所要求的焦点平面到物体的距离），得到一个空间中存在的长方体，经过对物体和相机两点之间构成的向量投射到相机单位向量方向上的投影长度，即我们所求的相机焦点平面到物体的距离。如下图所示，空间中，我们需要获取线段ob之间的距离，其中线段oa之间的距离可根据相机和物体的坐标计算得出，相机法向量v可从相机中获取，由此我们可计算得出线段oa在向量v方向的投影。\n\n\n首先，我们需要通过xfrom方法获取相机的法向量：\n\nCam &#x3D; mc.xform(cam.name(), q&#x3D;True, ws&#x3D;True, m&#x3D;True)[8:11]  # 数组第8到第10位为相机法向量\nCam_vector &#x3D; np.array(Cam) * -1   # 由于取出的数据是列表，这里需要转换成向量再取反，即为相机单位向量方向\n\n\n获取相机的坐标和物体的坐标，计算得出向量oa：\n\ndef getVector(locatorP, camP):\n    &quot;&quot;&quot;计算向量坐标\n        locatorP: 物体坐标\n        camP：相机坐标\n    &quot;&quot;&quot;\n    newVector &#x3D; (locatorP[0] - camP[0], locatorP[1] - camP[1], locatorP[2] - camP[2])\n    return newVector\n\n\n由于需要区分向量之间的夹角，若为锐角，焦距为正，反之为负：\n\ndef judgeAngle(_ang):\n    &quot;&quot;&quot;计算向量角度为锐角还是钝角&quot;&quot;&quot;\n    _flag &#x3D; (_ang * 180.0) &#x2F; pi\n    print(u&quot;向量间的角度为: %s 度(角度制)&quot; % _flag)\n    if (_flag &gt; 90) and (_flag &lt;&#x3D; 180):\n        return -1\n    elif (_flag &lt; 90) and (_flag &gt;&#x3D; 0):\n        return 1\n    elif _flag &#x3D;&#x3D; 90:\n        return 0\n\n\n使用上面获得的数据，即可求出相机焦点平面到物体的距离。以下为工具完整脚本：\n\n#!&#x2F;usr&#x2F;bin&#x2F;env python\n# -*- coding:utf-8 -*-\n# @Author: MirrorCG\n# @Time: 2021&#x2F;12&#x2F;28\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport maya.cmds as mc\nimport pymel.core as pm\nimport maya.mel as mel\nfrom math import pi, cos\nimport numpy as np\n\n\ndef getVector(locatorP, camP):\n    &quot;&quot;&quot;计算向量坐标&quot;&quot;&quot;\n    newVector &#x3D; (locatorP[0] - camP[0], locatorP[1] - camP[1], locatorP[2] - camP[2])\n    return newVector\n\n\ndef squareRVector(_vector):\n    &quot;&quot;&quot;计算平方根，向量长度&quot;&quot;&quot;\n    AB &#x3D; (_vector[0] * _vector[0] + _vector[1] * _vector[1] + _vector[2] * _vector[2]) ** 0.5\n    return AB\n\n\ndef judgeAngle(_ang):\n    &quot;&quot;&quot;计算向量角度为锐角还是钝角&quot;&quot;&quot;\n    _flag &#x3D; (_ang * 180.0) &#x2F; pi\n    print(u&quot;向量间的角度为: %s 度(角度制)&quot; % _flag)\n    if (_flag &gt; 90) and (_flag &lt;&#x3D; 180):\n        return -1\n    elif (_flag &lt; 90) and (_flag &gt;&#x3D; 0):\n        return 1\n    elif _flag &#x3D;&#x3D; 90:\n        return 0\n\n\ndef getCam(camName):\n    &quot;&quot;&quot;获取选中的相机，填入窗口&quot;&quot;&quot;\n    try:\n        cam &#x3D; pm.ls(sl&#x3D;True)[0].getChildren()[0]  # 选择相机\n    except IndexError as e:\n        mc.warning(u&quot;未选中对象&quot;)\n        return\n    if (not cam) or (cam.nodeType() !&#x3D; &quot;camera&quot;):\n        mc.warning(u&quot;未选中相机&quot;)\n        return\n    _camName &#x3D; cam.longName()\n    mc.textField(camName, e&#x3D;True, tx&#x3D;_camName)\n\n\ndef createLocator(locName, camName):\n    &quot;&quot;&quot;创建&#x2F;获取locator,移动至相机位置，并将改1ocator填入窗口中&quot;&quot;&quot;\n    try:\n        cam &#x3D; pm.ls(mc.textField(camName, q&#x3D;True, tx&#x3D;True))[0].getParent()\n    except IndexError as e:\n        mc.warning(u&quot;请选择并添加相机&quot;)\n        return\n    camP &#x3D; cam.getTranslation().get()  # 相机坐标\n    if mc.objExists(&quot;find_focous&quot;) and pm.nodeType(pm.ls(&quot;find_focous&quot;)[0].getChildren()[0]) &#x3D;&#x3D; &quot;locator&quot;:\n        loc &#x3D; pm.ls(&quot;find_focous&quot;)[0]\n    else:\n        loc &#x3D; pm.createNode(&quot;locator&quot;).getParent()\n        loc.rename(&quot;find_focous&quot;)\n    loc.setAttr(&quot;translate&quot;, camP)\n    mc.textField(locName, e&#x3D;True, tx&#x3D;loc.name())\n\n\ndef getInstance(instName, camName, locName, *args):\n    &quot;&quot;&quot;计算焦距，判断距离方向&quot;&quot;&quot;\n    if (not mc.textField(camName, q&#x3D;True, tx&#x3D;True)) or (not mc.textField(locName, q&#x3D;True, tx&#x3D;True)):\n        mc.warning(u&quot;请填入相机或locator(&#96;find_focous&#96;)&quot;)\n        return\n    cam &#x3D; pm.ls(mc.textField(camName, q&#x3D;True, tx&#x3D;True))[0].getParent()\n    camP &#x3D; cam.getTranslation().get()\n    loc &#x3D; pm.ls(mc.textField(locName, q&#x3D;True, tx&#x3D;True))[0]\n    cam_vector &#x3D; np.array(mc.xform(cam.name(), q&#x3D;True, ws&#x3D;True, m&#x3D;True)[8:11]) * -1  # 获取相机单位向量(从maya获取的向量需要取反\n    locatorP &#x3D; loc.getAttr(&quot;translate&quot;)  # 定位器坐标\n    AB_vector &#x3D; getVector(locatorP, camP)\n    AB &#x3D; squareRVector(AB_vector)  # 定位器距离相机距离\n    print(u&quot;定位器距离相机: %s 个单位&quot; % AB)\n    x &#x3D; np.array(cam_vector)\n    y &#x3D; np.array(AB_vector)\n    lx &#x3D; np.sqrt(x.dot(x))\n    ly &#x3D; np.sqrt(y.dot(y))\n    cos_angle &#x3D; x.dot(y) &#x2F; (lx * ly)\n    _angle &#x3D; np.arccos(cos_angle)\n    _flag &#x3D; judgeAngle(_angle)\n    if AB &#x3D;&#x3D; 0:\n        focus &#x3D; 0.1\n    else:\n        focus &#x3D; abs(cos(_angle) * AB)\n    if _flag &#x3D;&#x3D; 1:\n        pass\n    elif _flag &#x3D;&#x3D; -1:\n        focus &#x3D; (-1 * focus)\n    elif _flag &#x3D;&#x3D; 0:\n        focus &#x3D; 0.1\n    print(u&quot;相机焦距为: %s 个单位&quot; % focus)\n    mc.textField(instName, e&#x3D;True, tx&#x3D;&quot;%s&quot; % focus)\n    try:\n        cam.setAttr(&quot;focusDistance&quot;, focus)\n    except RuntimeError as e:\n        print(u&quot;焦距小于默认最小值,设定为0.1&quot;)\n    cam.setAttr(&quot;focusDistance&quot;, 0.1)\n    print(&quot;&#x3D;&quot; * 40)\n\n\ndef toolDoc(winName):\n    &quot;&quot;&quot;工具帮助&quot;&quot;&quot;\n    win_name &#x3D; u&quot;工具帮助&quot;\n    if mc.window(win_name, q&#x3D;True, ex&#x3D;True):\n        mc.deleteUI(win_name, window&#x3D;True)\n    helpWin&#x3D; mc.window(u&quot;工具帮助&quot;, t&#x3D;u&quot;工具帮助&quot;, wh&#x3D;(700, 70), p&#x3D;winName)\n    mc.paneLayout()\n    mc.textScrollList(&quot;line&quot;,\n                      append&#x3D;[u&quot;1.选择相机：先选择要测量焦距的相机，再点击按钮(相机名可以手动填入，但相机名为长名，防止错误选择相机)&quot;,\n                              u&quot;2.创建locator：点击后创建定位器，或手动填入已有的locator(默认创建的1ocator为&#39;find_focous&#39;,手动填入不用点击)&quot;,\n                              u&quot;3.计算焦距按钮：先移动调整好位置的1ocator，点击&#39;移动locator，计算焦距&#39;按钮，即可测出想要的焦距&quot;,\n                              u&quot;4.帮 助：本工具的使用说明&quot;])\n    mc.textScrollList(&quot;line&quot;, edit&#x3D;True, lf&#x3D;[(1, &quot;fixedWidthFont&quot;), (2, &quot;fixedWidthFont&quot;), (3, &quot;fixedWidthFont&quot;), (4, &quot;fixedWidthFont&quot;)])\n    mc.showWindow(helpWin)\n\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    win_name &#x3D; u&quot;测量相机焦距&quot;\n    if mc.window(win_name, q&#x3D;True, ex&#x3D;True):\n        mc.deleteUI(win_name, window&#x3D;True)\n    win &#x3D; mc.window(win_name, title&#x3D;u&quot;测量相机焦距&quot;, iconName&#x3D;u&quot;Short_Name&quot;, widthHeight&#x3D;(400, 110))\n    mc.columnLayout(adjustableColumn&#x3D;True, rs&#x3D;2)\n    mc.rowColumnLayout(numberOfColumns&#x3D;3, columnAttach&#x3D;(1, &quot;right&quot;, 0), columnWidth&#x3D;[(1, 60), (2, 240), (3, 100)])\n    mc.text(label&#x3D;u&#39;相 机 名:&#39;, align&#x3D;&#39;left&#39;)\n    camName &#x3D; mc.textField()\n    mc.button(label&#x3D;u&#39;选择相机&#39;, command&#x3D;&quot;getCam(camName)&quot;)\n    mc.setParent(&#39;..&#39;)\n    mc.rowColumnLayout(numberOfColumns&#x3D;3, columnAttach&#x3D;(1, &#39;right&#39;, 0), columnWidth&#x3D;[(1, 60), (2, 240), (3, 100)])\n    mc.text(label&#x3D;u&#39;locator: &#39;, align&#x3D;&#39;left&#39;)\n    locName &#x3D; mc.textField()\n    mc.button(label&#x3D;u&#39;创建1ocator&#39;, command&#x3D;&quot;createLocator(locName,camName)&quot;)\n    mc.setParent(&#39;..&#39;)\n    mc.button(label&#x3D;u&quot;移动locator,计算距离&quot;, command&#x3D;&quot;getInstance(instName, camName, 1ocName)&quot;, bgc&#x3D;(1, 0.73, 0.14))\n    mc.rowColumnLayout(numberOfColumns&#x3D;4, columnAttach&#x3D;(1, &#39;right&#39;, 0), columnWidth&#x3D;[(1, 60), (2, 200), (3, 100), (4, 40)])\n    mc.text(label&#x3D;u&#39;焦  距:&#39;, align&#x3D;&#39;left&#39;)\n    instName &#x3D; mc.textField(ed&#x3D;False, bgc&#x3D;(0.64, 0.79, 10.48))\n    mc.text(label&#x3D;u&quot; &quot;, align&#x3D;&#39;left&#39;)\n    mc.button(label&#x3D;u&#39;帮助&#39;, command&#x3D;&quot;toolDoc(win)&quot;)\n    mc.setParent(&quot;..&quot;)\n    mc.setParent(&quot;..&quot;)\n    mc.showWindow(win)\n\n\n若要动态获取相机焦距，可将下面的脚本修改后填入相机属性的表达式中。\n\nvector $camP &#x3D; &#96;getAttr camera1.translate&#96;; &#x2F;&#x2F;相机坐标\nfloat $camVct[16] &#x3D; &#96;xform -q -m -ws camera1&#96;; &#x2F;&#x2F;相机世界空间矩阵\nvector $camVector &#x3D; &lt;&lt;$camVct [8],$camVct[9],$camVct [10]&gt;&gt;*-1;  &#x2F;&#x2F;从maya中获取的相机向量，需要取反\nvector $locP &#x3D; &#96;getAttr find_focous.translate&#96;;\nvector $lcInstance &#x3D; $locP - $camP;\nfloat $inst &#x3D; mag($locP - $camP); &#x2F;&#x2F;物体距离相机的距离\nfloat $_angle &#x3D; angle($camVector,$lcInstance); &#x2F;&#x2F;向量间的夹角\nfloat $_focus &#x3D; cos($_angle)*$inst; &#x2F;&#x2F;焦距\nfloat $flag &#x3D; ($_angle*180)&#x2F;3.141592657;\nif ($flag &gt;&#x3D; 90)\n&#123;\n    $focus &#x3D; 0.1;\n&#125;\nprint $_focus;\ncameraShape1.focusDistance &#x3D; $_focus;\n\n\n\n方法二：添加约束在相机位置创建两个定位器：其中一号定位器p到相机上，使用二号定位器约束一号定位器的Z轴，并设置Z轴数值的最大值（因为方向是反的，所以设置最大值，可以自己尝试一下），将二号定位器移动到物体的位置并添加约束，此时，一号定位器的Z轴数值即是相机焦距，将此属性连接到相机的aifocus属性即可动态获取相机焦距，如下图所示：\n\n\n约束工具如下：\n\n#!&#x2F;usr&#x2F;bin&#x2F;env python\n# -*- coding:utf-8 -*-\n# @Auth0r: MirrorCG\n# @Time: 2021&#x2F;12&#x2F;28\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\nimport maya.cmds as mc\nimport pymel.core as pm\n\n\nclass getDistance():\n    def __init__(self):\n        win_name &#x3D; u&quot;测量相机焦距&quot;\n        if mc.window(win_name, q&#x3D;True, ex&#x3D;True):\n            mc.deleteUI(win_name, window&#x3D;True)\n        self.win &#x3D; mc.window(win_name, title&#x3D;u&quot;测量相机焦距&quot;, iconName&#x3D;u&#39;short Name&#39;, widthHeight&#x3D;(400, 120))\n        mc.columnLayout(adjustableColumn&#x3D;True, rs&#x3D;2)\n        mc.rowColumnLayout(numberOfColumns&#x3D;3, columnAttach&#x3D;(1, &#39;right&#39;, 0), columnWidth&#x3D;[(1, 60), (2, 240), (3, 100)])\n        mc.text(label&#x3D;u&quot;相 机 名:&quot;, align&#x3D;&#39;left&#39;)\n        self.camName &#x3D; mc.textField()\n        mc.button(label&#x3D;u&quot;选择相机&quot;, command&#x3D;lambda x: self.getCam(self.camName))\n        mc.setParent(&#39;..&#39;)\n        mc.rowColumnLayout(numberOfColumns&#x3D;3, columnAttach&#x3D;(1, &#39;right&#39;, 0), columnWidth&#x3D;[(1, 60), (2, 240), (3, 100)])\n        mc.text(label&#x3D;u&quot;locator:&quot;, align&#x3D;&#39;left&#39;)\n        self.locName &#x3D; mc.textField()\n        mc.button(label&#x3D;u&quot;创建locator&quot;, command&#x3D;lambda x: self.createLocators(self.locName))\n        mc.setParent(&quot;..&quot;)\n        mc.rowColumnLayout(numberOfColumns&#x3D;3, columnWidth&#x3D;[(1, 180), (2, 40), (3, 180)])\n        mc.button(label&#x3D;u&quot;约束到选择的物体&quot;, command&#x3D;lambda x: self.addCtrlWithObj(), bgc&#x3D;(1, 0.73, 0.14))\n        mc.text(label&#x3D;u&#39; &#39;, align&#x3D;&#39;right&#39;)\n        mc.button(label&#x3D;u&quot;清除产生的对象&quot;, command&#x3D;lambda x: self.cleanAll(), bgc&#x3D;(1, 0.73, 0.14))\n        mc.setParent(&quot;..&quot;)\n        mc.rowColumnLayout(numberOfColumns&#x3D;2, columnAttach&#x3D;(1, &#39;right&#39;, 0), columnWidth&#x3D;[(1, 360), (2, 40)])\n        mc.text(label&#x3D;u&#39; &#39; * 8, align&#x3D;&#39;left&#39;)\n        mc.button(label&#x3D;u&quot;帮助&quot;, command&#x3D;lambda x: self.toolDoc())\n        mc.setParent(&#39;..&#39;)\n        mc.setParent(&#39;..&#39;)\n        mc.showWindow(self.win)\n\n    def getCam(self, *args):\n        &quot;&quot;&quot;获取选中的相机，填入窗口&quot;&quot;&quot;\n        try:\n            cam &#x3D; pm.ls(sl&#x3D;True)[0].getChildren()[0]  # 选择相机\n        except IndexError as e:\n            mc.warning(u&quot;未选中对象&quot;)\n            return\n        if (not cam) or (cam.nodeType() !&#x3D; &quot;camera&quot;):\n            mc.warning(u&quot;未选中相机&quot;)\n            return\n        _camName &#x3D; cam.longName()\n        mc.textField(self.camName, e&#x3D;True, tx&#x3D;_camName)\n\n    def connectParm(self, loc_a):\n        &quot;&quot;&quot;连接相机属性&quot;&quot;&quot;\n        cam &#x3D; pm.ls(mc.textField(self.camName, q&#x3D;True, tx&#x3D;True))[0]\n        # cam.setAttr(&quot;aiEnableDOF&quot;,1)\n        node_name &#x3D; &quot;distance_data&quot;\n        if mc.objExists(node_name):\n            mc.delete(node_name)\n        mc.createNode(&quot;floatMath&quot;, n&#x3D;node_name)\n        mc.setAttr(node_name + &quot;.operation&quot;, 2)\n        mc.setAttr(node_name + &quot;.floatB&quot;, -1)\n        mc.connectAttr(loc_a.name() + &quot;.translateZ&quot;, node_name + &quot;.floatA&quot;, f&#x3D;True)\n        mc.connectAttr(node_name + &quot;.outFloat&quot;, cam.name() + &quot;.aiFocusDistance&quot;, f&#x3D;True)\n\n    def addCtrl(self, loc_m, loc_a):\n        &quot;&quot;&quot;m添加约束和设置可见性&quot;&quot;&quot;\n        cam &#x3D; mc.textField(self.camName, q&#x3D;True, tx&#x3D;True)\n        mc.parent(loc_a.name(), cam)\n        mc.transformLimits(loc_a.name(), tz&#x3D;(-1, -0.02), etz&#x3D;(0, 1))\n        mc.setAttr(loc_a.fullPath() + &quot;.visibility&quot;, 0)\n        mc.setAttr(loc_a.fullPath() + &quot;.visibility&quot;, lock&#x3D;True)\n\n        mc.parentConstraint(loc_m.name(), loc_a.name(), mo&#x3D;True, st&#x3D;[&quot;x&quot;, &quot;y&quot;], sr&#x3D;[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])\n\n    def createLocators(self, *args):\n        &quot;&quot;&quot;创建 &#x2F; 获取1ocator, 移动至相机位置，并将该主1ocator填入窗口中&quot;&quot;&quot;\n        try:\n            cam &#x3D; pm.ls(mc.textField(self.camName, q&#x3D;True, tx&#x3D;True))[0].getParent().fullPath()\n        except IndexError as e:\n            mc.warning(u&quot;请选择并添加正确的相机&quot;)\n            return\n        cam_p &#x3D; mc.xform(cam, q&#x3D;True, ws&#x3D;True, t&#x3D;True)  # 相机世界坐标\n        if mc.objExists(&quot;find_focus&quot;):  # 用于移动的locator\n            loc_m &#x3D; pm.ls(&quot;find_focus&quot;)[0]\n            pm.delete(loc_m)\n        loc_m &#x3D; pm.createNode(&quot;locator&quot;).getParent()\n        loc_m.rename(&quot;find_focus&quot;)\n\n        if mc.objExists(&quot;cam_center&quot;):\n            loc_a &#x3D; pm.ls(&quot;cam_center&quot;)[0]\n            pm.delete(loc_a)\n        loc_a &#x3D; pm.createNode(&quot;locator&quot;).getParent()\n        loc_a.rename(&quot;cam_center&quot;)\n\n        loc_m.setAttr(&quot;translate&quot;, cam_p)\n        loc_a.setAttr(&quot;translate&quot;, cam_p)\n        mc.textField(self.locName, e&#x3D;True, tx&#x3D;loc_m.name())\n\n        self.addCtrl(loc_m, loc_a)  # 添加约束和设置可见性\n        self.connectParm(loc_a)\n\n    def addCtrlWithObj(self, *args):\n        &quot;&quot;&quot;约束到物体&quot;&quot;&quot;\n        try:\n            loc_m &#x3D; pm.ls(mc.textField(self.locName, q&#x3D;True, tx&#x3D;True))[0].fullPath()\n        except IndexError as e:\n            mc.warning(u&quot;未创建或填入定位器&quot;)\n            return\n        obj &#x3D; &quot;&quot;\n        for i in mc.ls(sl&#x3D;True):\n            if &quot;find focus&quot; not in i:\n                obj &#x3D; i\n                break\n            continue\n        if not obj:\n            mc.warning(u&quot;未选择约束物体，或约束物体名称中含有&#39;find_focus&#39;字符串&quot;)\n        mc.parentConstraint(obj, loc_m, mo&#x3D;True, sr&#x3D;[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])\n\n    def cleanAll(self, *arqs):\n        &quot;&quot;&quot;清除本工具产生的所有节点&quot;&quot;&quot;\n        node_list &#x3D; [&quot;distance_data&quot;, &quot;find_focus&quot;, &quot;cam_center&quot;]\n        for i in node_list:\n            if mc.objExists(i):\n                mc.delete(i)\n\n    def toolDoc(self):\n        &quot;&quot;&quot;工具帮助&quot;&quot;&quot;\n        win_name &#x3D; u&quot;工具帮助&quot;\n        if mc.window(win_name, q&#x3D;True, ex&#x3D;True):\n            mc.deleteUI(win_name, window&#x3D;True)\n        help_win &#x3D; mc.window(u&quot;工具帮助&quot;, t&#x3D;u&quot;工具帮助&quot;, wh&#x3D;(640, 100), p&#x3D;self.win)\n        mc.paneLayout()\n        mc.textScrollList(&quot;line&quot;, append&#x3D;[u&quot;1.选择相机:先选择要测量焦距的相机，再点击按钮(相机名可以手动填入，但相机名为长名，防止错误选择相机)&quot;,\n                                          u&quot;2,创建locator:点击后，在相机处创建定位器，创建的1ocator名称为&#39;find focous&#39;&quot;,\n                                          u&quot;3.约束到选择物体:先调整好locator(find focous)的位置，选择约束物体，点击&#39;约束到选择物体&#39;，即测出想要的焦距，属性将自动连接&quot;,\n                                          u&quot;4.清除对象，清除本工具产生的相关节点&quot;, u&quot;5.帮助:本工具的使用说明&quot;])\n        mc.textScrollList(&quot;line&quot;, edit&#x3D;True, lf&#x3D;[(1, &quot;fixedWidthFont&quot;), (2, &quot;fixedWidthFont&quot;), (3, &quot;fixedWidthFont&quot;),\n                                                 (4, &quot;fixedWidthFont&quot;), (5, &quot;fixedWidthFont&quot;)])\n\n        mc.showWindow(help_win)\n\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    tool &#x3D; getDistance()\n\n\n\n","categories":["Maya","小工具"],"tags":["灯光","向量计算"]},{"title":"关于Aitoon材质灯光分层的探索","url":"/posts/20220226a2.html","content":"起因前段时间，开始对在 Maya 中进行三渲二的渲染分层有了兴趣。于是，我就尝试自己探索一下：在 Maya 中使用 Aitoon 材质进行三渲二的灯光分层，以及在 Nuke中进行合成的流程。现在的三渲二影视作品普遍采用亮面、暗面加边缘光的方式进行灯光分层，部分镜头需要以亮面、灰面和暗面加边缘光的方式进行灯光分层，灯光师仅完成灯光角度的设计即可，最终画面氛围和效果需要合成师完成，这种分层方式使用aitoon材质球可以很容易地完成。\n\n测试环境:maya 2018.5+Arnold 6.0.1.0测试角色:不要钱的派大星\n一. 材质相关前期部门仅制作卡通材质，不需要在材质球中为rim、highlight 指定灯光。材质球的base 权重需要设定为1（下图1），关闭材质的能量守恒选项和间接反射（下图2），材质的baseTonemap属性都链接ramp节点并保持只有两个点。调节材质、线框效果与贴图的阴影融合等步骤需要前期部门调整到最终效果。如果做了材质阴影融合，材质部门需要提供另一套只带有阴影贴图的 aimatte 材质球用于切换，供灯光部门渲染阴影通道使用。\n\n\n\n\n\n二．灯光环节流程1.灯光使用要求\n\n由于卡通材质的特殊性，灯光渲染需要至少一盏光源即可区分亮暗，根据官方介绍虽然 aitoon 材质并不挑剔灯光类型，但由于面光源和skydome等灯光的性质，可能会导致受光面的强度大于1，从而导致莫名的错误，灯光的要求使用平行光、点光源或者聚光灯，并且这三种光源对于风格化高光的形成效果较好，可控性更高。\n    2.Aov及渲染分层\n通过对aitoon材质的渲染，我们可以获取Arnold提供的所有的Aov通道，但由于aitoon材质球并非基干物理的材质球，并不能按照LPE的方式进行分层，传统的分成方式需要考虑灯光的强度和颜色对贴图的影响以及材质之间的影响，而卡通渲染并不计算diffuse的灯光颜色信息，因此我们可以采用diffusealbedo+主光照射范围+暗部颜色+平面反射+透射的方式进行分层，此方法能保持合成的可调性的同时也最大限度保留了材质的效果。通过读取模型的材质信息，给模型添加附加属性，用aiuserdata节点传递已经记录的每个模型的材质球信息，即可确认模型被灯光照射的亮暗面的范围，最终输出通道，具体方式如下：\n    (1)主光照射范围+暗部颜色\n给每一个材质为aitoon的物体添加Arnold额外属性(color1,color2.pos1,pos2.interpolation)用于记录数据（下图左一），该属性记录材质球的basetonemap中ramp 的信息（下图右一），其中颜色数据使用vector类型 ，位置数据使用float类型，ramp的过度类型使用int类型，这三种类型分别可对应用户数据节点的 aiUserDataColor、aiUserDataFloat、aiUserDatalnt。\n\n\n\n\n以 toon_key 为例创建自定义 aov（下图左一），通过创建自定义的aov，将aov色器选择为新创建的 aitoon 卡通材质球 关闭该aitoon 材质球的能量守恒，边缘，高光。将basecolor调为1，并给basetonemap链接一个默认的ramp节点。创建2个aiUserDataColor2个aiUserDataFloat1个aiUserDatalnt节点，并将color1、color2分别填入aiUserDataColor，pos1、pos2分别填入aiUserDataFloat，interpolation填入aiUserDatalnt，将五个节点链接到上一步的ramp中即可渲染出，所需要的包含有灯光照射的两部范围信息的aov，该aov的色彩信息为仅为灯光照射的亮面（toon_key）(不含材质信息)，以此类推，可获得暗面的颜色（toon_env），渲染出的aov（下图右一）\n\n\n\n\n至此，我们获得需要的灯光层，该灯光层保留材质的 ramp 亮暗面信息和亮暗部区域(非aitoon 材质渲染为黑色。\n    (2) Diffuse abedle、高光和透射\n材质本身的高光和透射可利用maya自身的aov输出，分别为specular direct、specular indirect，transmission direct， transmission indirect。\n    (3) edge\n物体的边缘线输出，需要通过自定义edge aov进行输出，需要将aov的filter设定为 contour类型否则渲染不出线框（如下图）。\n\n\n\n\n    (4) 边缘光和风格化高光\n为了便于调节，aitoon材质的rim边缘光和风格化高光可通过单独分层并对层中的物体进行材质覆盖的方式进行提取aov，单独分层也有利于控制效果。\n    (5) 其他需要的aov\n除上述aov外,其他一些aov可根据需求添加，本文考虑使用的辅助aov包括:N、 fresnel、OCC、RBzd、P、crypto_matte(三种)、direct和indirect 可在含有非aitoon材质时输出，用于调整非aitoon材质物体。\n    (6)文件分层\n文件的分层方式通过maya的renderSetup分层方式进行分层，最后以模板的形式导出渲染层，供流程使用。使用render Setup的方 式分层可以很方便地对模型进行材质覆盖、属性覆盖和导出自定义aov的操作，以边光和风格化层高光为例，为保持物体边缘光的统一性，需要整体赋予一个aitoon材质球，用于调整边缘光效果;而材质球的边缘光和风格化高光属性是没有填入对应灯光的shape名称的，因此可以在覆盖材质或者属性的基础上，统一给相关的模型覆盖属性或材质球，达到渲染效果。\n\n三．合成通过上面的方法，我们可以得到合成所需要的aov，通过合成树即可还原灯光渲染的效果（合成树中的图片不是本例的图片，此处仅做示范），并在此基础上由合成师进行环境氛围和灯光效果的调整即可（如下图）。\n\n\n\n\n\n四．写在最后此方法按照aitoon材质球的非基于物理渲染的特性，以basetonemap的ramp与贴图相乘得出最终颜色信息的特点，进行aov分层;它相对于单纯使用aitoon材质球对物体进行材质覆盖的方式进行亮暗部区分的优点在于，不以单一的材质覆盖的亮暗部过度信息、能更准确地保留材质的亮暗部范围和过度方式、能分别获取到材质的亮暗部rgb信息。相对于传统基于物理的分层方式，能单独调整亮暗面颜色信息，由于三渲二不能在灯光中处理氛围，此方式在合成中可调性更高。\n\n注意：在输出AOV通道时，若自定义的AOV和Arnold渲染器自带的AOV一起渲染出图时，会导致Arnold渲染器自带的Aov渲染错误，不渲染出正确的信息，因此，自定义的AOV需要单独分层渲染。\n","categories":["Maya","arnold"],"tags":["灯光","Aitoon","aiUserData","Aov"]},{"title":"博客文章语法示例","url":"/posts/20220220a2.html","content":"这是文章摘要 ，下面是废话\n文件最上方以 — 分隔的区域称为”Front_matter”\n第一章首行缩进内容\n\n段落格式段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车，\n也可以在段落后面使用一个空行来表示重新开始一个段落\n字体斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本\n分隔线\n\n\n\n\n删除线BAIDU.COM\n下划线带下划线文本\n脚注[^要注明的文本]\n这是引用块NEW: DevDocs now comes with syntax highlighting. http://devdocs.io\n@DevDocswww.baidu.com\n\n这是文字链接下载git\n这是一个链接 菜鸟教程或直接使用网址 https://www.runoob.com\n这是代码块alert(&#39;Hello World!&#39;);\n\n[rectangle setX: 10 y: 10 width: 20 height: 20];\n\nArray.maparray.map(callback[, thisArg])\n\n_.compactUnderscore.js_.compact([0, 1, false, 2, &#39;&#39;, 3]);\n&#x3D;&gt; [1, 2, 3]\n\n这是反引号代码块\n标题array.map(callback[, thisArg])\nprint(11111)\n\npull quote\ncontentsssssssss\n\n\n这是jsFiddle(jsFiddle是一个在线的shell编辑器)\n\n在文章中插入指定大小的图片\n  \nhtml支持的使用表放置图片的方式\n\n\n\n\n\n这是视频\n这是文本引用\nPost not found: hexo-4-released How to use  tag in title\n\n这是数据引用&lt;% for (var link in site.data.menu) { %&gt;  <a href=\"\"> &lt;%&#x3D; link %&gt; &lt;% } %&gt;\n\n第二章内容\n表格这是表格示例，使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行\n\n\n\n左对齐\n右对齐\n居中对齐\n\n\n\n单元格\n单元格\n单元格\n\n\n单元格\n单元格\n单元格\n\n\n区块\n无标区块1\n\n\n无标区块2\n\n\n有标区块\n\n区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：\n\n嵌套标区块1\n\n嵌套区块2\n\n嵌套区块3\n\n\n\n嵌套区块4\n\n\n列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\n\n第一项\n\n\n第二项\n\n\n第三项\n\n嵌套列表列表嵌套只需在子列表中的选项前面添加两个或四个空格即可\n\n第一项\n嵌套的第一个元素\n\n\n\n参考文献www.codesheep.cn\n\n\n\n\n\nvar gitalk = new Gitalk({\n    id: '',\n    clientID: '',\n    clientSecret: '',\n    repo: 'gitalk',\n    owner: 'JairusTse',\n    admin: ['JairusTse'],\n    labels: ['Gitalk'],\n    perPage: 50\n})\ngitalk.render('gitalk-container')\n\n","categories":["Doc","学习笔记"],"tags":["Blog","Markdown"]},{"title":"Hexo文档","url":"/posts/20220220a1.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Doc"],"tags":["Blog","Hexo"]}]