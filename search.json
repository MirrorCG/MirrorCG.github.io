[{"title":"Windows任务计划","url":"/posts/20220510a1.html","content":"工作中有时需要定时执行一些规律性的脚本操作，比如，清除磁盘垃圾、定时下载任务等。这些任务执行虽然简单，但是需要人力进行日常维护。通常有两种方式可以方便处理这类型任务：\n\n以本机作为脚本任务的执行者，开启电脑后，通过ide运行任务，但是每次开机都需要手动执行，或者将程序打包成exe程序再放入启动文件夹。\n以本机作为服务器，通过任务计划的触发器，自动执行指定任务，不需要每次开机后再手动执行。\n\n下面将介绍第二种方式——任务计划\n\n打开计划任务程序\n\n\n\n\n\n创建一个新的任务计划文件夹（推荐）或在“任务计划程序库”中创建基本任务:提一下”创建基本任务”和”创建任务”的区别是一个有引导界面，一个直接弹出设置界面直接设置。\n\n\n  \n\n输入任务名称和描述。\n\n  \n\n选择触发器，修改触发器触发的时间和间隔，这里暂时只能创建一个触发器，我们可以创建完任务计划后进行添加或修改触发器。\n\n \n\n选择任务操作，并填入相关参数，这里很重要，它可以决定你的任务计划是否正常执行，原则上越简单越好（后面会进行详解）；然后点击完成。\n\n \n\n“创建基本任务”完成后，我们还需要对其进行一些的修改；选择任务点击属性对任务进行修改。\n\n  “操作”项暂不做修改；”条件”项也比较简单，都是字面意思，这里不做讲解；  note：每次手动运行任务后，若任务状态没有更改成预期状态，可通过右键任务选择“刷新”选项进行任务状态的刷新。\n\n关于”操作”项中的设置需要注意：由于我们使用的是.bat脚本中通过python程序调用.py脚本，因此这里的”程序或脚本”填入 XXX\\test.bat(不加引号)，”添加参数（可选）”为空，“起始于（可选）”则是.py文件所在的目录，而不是执行程序或者.bat脚本所在的目录，否则执行的结果会出错；若不填(缺省状态)，那么自动将该处的目录位置定位到”程序或脚本”的目录位置。并且调用的程序需要传入参数，例如”程序或脚本”填入Python编译器路径 C:\\Python27\\python.exe ，而”添加参数（可选）”为.py文件，那么“起始于（可选）”则是.py文件所在的目录。最后说一下，任务计划中所用到的所有的文件最好放置在本地路径。\n\n实践踩坑和解决办法在这次工作中由于需要每天调用pythonAPI对程序的服务端进行调整，因此使用了任务计划调用bat脚本的方式执行任务。该bat脚本中，仅简单的一句'XXX/python.exe XXX/XXX/xxx.py'---使用编译器编译python脚本，该任务在我本机上执行没有任务问题，于是将任务计划部署到农场机器上，此时任务就出现了问题：创建的任务不会成功执行，或者执行结果不为'成功执行（0X0）',或者执行结果为'成功执行（0X1）'（失败状态）或者直接失败，找了很久的原因，排除几乎所有的可能性（计算机休眠、计算机系统配置不对、任务权限不够、bat脚本有问题、.py脚本有问题、任务手动运行后状态没有及时切换导致新实例不能创建、不能访问网络盘资源、脚本“起始于（可选）”参数不对、执行程序带引号等等）。最后本着\"越简单越好\"的原则，直接将bat脚本拆开，将python编译器的位置填入\"程序或脚本\"，\"添加参数（可选）\"填入.py脚本，“起始于（可选）”填入.py脚本路径，问题才得到解决。\n猜测和计算机系统有关，由于我本机使用的是Windows10 的操作系统，而农场机使用的是Windows server2012 的操作系统。\n\n\n\n\n\n参考官方介绍：https://forsenergy.com/zh-cn/gpmc/html/688d2d42-454a-4e2e-90c0-557f959d49b0.htm参考文章：https://www.jianshu.com/p/c627c77f6ea3\n","categories":["Doc"],"tags":["windows","排错记录"]},{"title":"Deadline如何使用PythonAPI","url":"/posts/20220505a1.html","content":"前言本文介绍如何使用 Deadline 的 Python API 操作Deadline。通过 Python API 可在 Python 中与 HTTP API 通信。\n\n拷贝 PythonAPI 模块首先在使用 API 之前，需要配置python环境使我们可以调用到 API。我们需要安装和使用 python2.7.9或 3.7 以上的python版本，然后将 Deadline 储存库路径（//your/repository/api/python）下的整个“Deadline”文件夹复制到Python 安装路径下的的“site-packages”文件夹，API 即可调用。\n\n\n开启 WebService 服务我们还需要通过 WebService 通信以发送和接收请求，因此，还要在 Deadline 管理的局域网中的任何一台可见的设备上运行 WebService服务，该服务为“C:\\Program Files\\Thinkbox\\Deadline10\\bin\\deadlinewebservice.exe”，打开后，我们就可以通过该设备的设备名称或者Ip地址进行通讯，API访问的端口默认情况下为8082。\n\n\n使用 PythonAPI使用时，必须创建一个 DeadlineCon 对象。该对象用于与 WebService 通信以发送和接收请求，该对象需要两个参数：“运行 WebService 服务的设备名或IP地址”、“该设备上允许 WebService 通信的端口号（默认为8082）”，这两个参数可以从已经运行的 WebService 通讯服务上找到。\n\n\n然后我们就可以使用API创建一个连接对象“connectionObject &#x3D; Deadline.DeadlineConnect.DeadlineCon(‘WebServiceName’, WebServicePortNumber)”， 通过该对象，我们可以查询、修改 Deadline 上的大部分信息。\n示例代码1：查询作业组、暂停指定作业\nimport Deadline.DeadlineConnect as Connect  # 导入 Deadline.DeadlineConnect 作为连接\nconnectionObject = Connect.DeadlineCon('DESKTOP-Mirror', 8082)\nprint(connectionObject.Groups.GetGroupNames())\n#[\"group1\",\"group2\",\"group3\"]\njobId = \"622c38262812473ba4c08eca\"  #(有效的job ID号)\nprint(connectionObject.Jobs.SuspendJob(jobId))\n# 'Success'\n\n示例代码2：提交作业\nimport Deadline.DeadlineConnect as Connect\n\nDeadline = Connect.DeadlineCon('DESKTOP-Mirror', 8082)\nJobInfo = &#123;\n    \"Name\": \"Submitted via Python\",\n    \"UserName\": \"UserName\",\n    \"Frames\": \"0-1\",\n    \"Plugin\": \"VraySpawner\"\n&#125;\n\nPluginInfo = &#123;\n    \"Version\": \"Max2014\"\n&#125;\n\ntry:\n    newJob = connectionObject.Jobs.SubmitJob(JobInfo, PluginInfo)\n    print(newJob)\nexcept:\n    print(\"Sorry, Web Service is currently down!\")\n\n\n参考\n官方说明：https://docs.thinkboxsoftware.com/products/deadline/10.1/3_Python%20Reference/index.html#intro_sec\n\n","categories":["Deadline","插件"],"tags":["插件"]},{"title":"Maya中材质文件和缓存文件相结合进行渲染的几种方式","url":"/posts/20220503a6.html","content":"前言本文记录材质文件和缓存文件相结合，组装渲染镜头文件的几种方式.\n\n缓存驱动材质文件进行渲染使用缓存文件驱动材质文件的方式进行渲染。\n缓存文件直接替换材质文件的几何体进行渲染缓存文件包裹材质文件进行渲染给缓存文件赋予材质进行渲染","categories":["Maya","杂项"],"tags":["Pipeline","灯光"]},{"title":"Maya软件渲染问题集锦","url":"/posts/20220503a5.html","content":"\n渲染崩溃可能的问题：\n\n被赋予Arnold材质3s散射的物体是片，导致散射时不是在物体内部散射，而是在整个场景中散射，计算量特别大从而崩溃\n\n\nRedshift:提示：’Mesh pCubeShape1 is instanced and uses adaptive tessellation, which isn’t supported. Disabling tessellation. If you need tessellation, please use fixed tessellation settings: i.e. disable ‘screen space adaptive’ and set ‘min edge length’ to zero to force a maximum tessellation level’。对象细分后在实例错误提示：对象在实例化后细分，被实例化对象在屏幕自适应时找不到细分对象，就不会进行细分。如果需要细分，就关闭屏幕自适应，并把最小边缘强度设置为零，以强制使用最大边缘强度，如图：\n \n\n农场机提示找不到可执行渲染的文件：“Katana render executable was not found in the semicolon separated list”（在分号分隔的列表中没有找到Katana渲染的可执行文件），该机器上没有安装相应的软件，或软件没有安装在默认的路径。\n\nCannot find procedure “pgYetiVRayPreRender”报错导致渲染暂停：渲染文件中没有Yeti毛发节点，却在渲染文件的渲染设置中填入了“pgYetiVRayPreRender”代码，导致渲染器找不到对应的节点而报错，我们只需要打开文件，删除渲染设置中的以下代码就行了（Render Settings &gt; Common &gt; Render Options，删除报错的MEL，一般情况下也可以全部删除）：\n \n \n \n \n\n贴图文件正在上传或修改。日志出现：File“*******”was modified after being opened by OIIO，这是因为文件在渲染的时候，被文件IO读取的贴图文件还在上传或更新中 解决办法：等待贴图上传完成后再渲染文件\n\n盘符掉了或没有输出磁盘： 解决办法：映射一个盘符\n subst D: C:\\D  ::映射D盘盘符到C盘的D文件夹\n\nDeadline农场渲染报错“defaultRenderLayer” is a layer from a referenced and is not allowed to be the current layer ,其可能是之一是：maya 的 renderLayerManage节点被改名导致 maya 不能生成默认的master layer渲染层（在.ma文件中的名称为defaultRenderLayer），因此可以将文件保存为.ma格式的文件，用文本的方式打开，将renderLayerManager节点的名称改为默认的’renderLayerManager’(没有任何修饰)，同时由于默认的renderLayerManager节点已经被修改过，默认的渲染层名称也发生了改变，导致渲染程序在调用的代码中，该层被判定为非默认的渲染层而报错“unable to modify overrides to the default layer”,因此，还需要将文件中的 defaultRenderLayer节点 (本问题记录时该节点名称为 defaultRenderLayer1 ),改为默认的名称defaultRenderLayer，即可。\n\n\n","categories":["Maya","杂项"],"tags":["锦囊小妙招"]},{"title":"Maya软件小知识点","url":"/posts/20220503a4.html","content":"\n贴图色彩空间被锁定的情况，解锁所有节点贴图的贴图色彩空间选项：\n import maya.cmds as cmds\nfor i in cmds.ls(type='file'):\n    cmds.connectAttr(\":defaultColorMgtGlobals.cme\",i+\".cme\",f=1)\n\n脚本切换渲染器:\n cmds.setAttr(\"defaultRenderGlobals.currentRenderer\", \"arnold\", type=\"string\")\n\n获取当前视图快照拍屏：\n ws = cmds.workspace(q = True, fullName = True)\nwsp = ws + \"/\" + \"images\"\nimageSnapshot = wsp + \"/\" + \"endSnapshot.jpg\"\ncmds.refresh(cv=True, fe = \"jpg\", fn = imageSnapshot)\n\n脚本设置渲染设置的输出序列图选项：\n mc.setAttr(\"defaultRenderGlobals.animation\", True)  # 开启动画帧序列\nmc.setAttr(\"defaultRenderGlobals.animationRange\",1)  # 开启动画帧的范围\nmc.setAttr(\"defaultRenderGlobals.outFormatControl\", 1)  # 设置帧格式\nmc.setAttr(\"defaultRenderGlobals.putFrameBeforeExt\", 1) # 设置图片格式在数字后面（name.#.ext）\n\n创建多相机渲染：\n\n选择相机&gt;AtteibutsEdit&gt;OutputSettings&gt;Renderable(勾选)\nRenderSetting&gt;RednderableCamera&gt;Add RenderableCamera\n\n\nArnold开关运动模糊要同时设置运动模糊可见性:\n mc.setAttr(\"defaultRenderGlobals.motionBlur\", 0) #关闭运动模糊（针对于Arnold）\nmc.setAttr(\"defaultArnoldRenderOptions.motion_blur_enable\", 0) #关闭运动模糊可见性\nmc.setAttr(\"defaultRenderGlobals.motionBlur\", 1) #开启运动模糊\nmc.setAttr(\"defaultArnoldRenderOptions.motion_blur_enable\", 1) #开启运动模糊可见性\n\n脚本打印部分渲染节点属性名称和值的方式:\n import maya.cmds as cmds \nrender_glob = \"defaultRenderGlobals\"\nlist_Attr = cmds.listAttr(render_glob, r=True, s=True)\nfor attr in list_Attr:\n    get_attr_name = \"%s.%s\"%(render_glob, attr)\n    print \"setAttr %s %s\"%(get_attr_name, cmds.getAttr(get_attr_name))\nmtoa 创建和访问AOV:\n import mtoa.aovs as aovs\n# 添加aov\naovs.AOVInterface().addAOV('aov名称', aovType='float')\n# 列出活动状态的aovs\naovs.AOVInterface().getAOVs()\n\nArnold代码加载arnold渲染器并创建默认节点：\n import maya.cmds as mc\nimport mtoa.core\nmc.setAttr(\"defaultRenderGlobals.currentRenderer\",\"arnold\",typ=\"string\")\nmtoa.core.createOptions()  # 创建ar默认节点网络\n\n查看 mel 函数帮助：使用 “whatIs ‘mel命令’;” 可以查看mel函数帮助。\n\n设置maya视图窗口为非显卡（不使用显卡）支持的窗口模式：\nimport maya.cmds as mc\ndef switch_preview():\n    all_model_panel = mc.getPanel(typ=\"modelPanel\")\n    for each in all_model_panel:\n        mc.modelEditor(each,e=True,rnm=\"base_OpenGL_Renderer\")  # 查询可用的渲染器名称 mc.modelEditor(each,q=True,rendererList=True) \n\nXgen相关:\nimport xgenm.xmaya.xgmExternalAPI as xgenmExternalAPI\nimport xgenm as xg\npalettes = xg.palettes()  # 获取Xgen 所有描述\nif not (xgenmExternalAPI.xgg.DescriptionEditor is None):\n    xgenmExternalAPI.xgg.DescriptionEditor.refresh(\"Full\")  # 刷新所有Xgen面板\n\n","categories":["Maya","杂项"],"tags":["锦囊小妙招"]},{"title":"Maya软件小问题集锦","url":"/posts/20220503a3.html","content":"本文记录了一些Maya中出现的一些小问题：\n\nAOV无法正常创建\nimport maya.cmds as mc\nmc.lockNode('initialParticleSE',l=0,lu=0)\nmc.lockNode('initialShadingGroup',l=0,lu=0)\n\nMaya 操作总是提示 “&#x2F;&#x2F; Error: line 1: Cannot find procedure “onModelChange3dc”. &#x2F;&#x2F;“，这可能是模型制作的时候打开了某个窗口，maya在关闭的时候会保存一份配置在maya文件里，可以从Expression Editor的By Script Node Name里看到，虽然没什么影响，但是真的很烦。解决办法：\nimport pymel.core as pm\n# 获取Maya中的所有模型编辑器并重置 editorChanged 事件\nfor item in pm.lsUI(editors=True):\n   if isinstance(item, pm.ui.ModelEditor):\n       pm.modelEditor(item, edit=True, editorChanged=\"\")\n\nRenderSetting渲染面板内容空白，执行mel脚本:\ndeleteUI unifiedRenderGlobalsWindow;\n\n关闭“cannot find procedrure ‘look’”：\n\n执行mel脚本:\n\n方法一：outlinerEditor -edit -selectCommand \"\" \"outlinerPanel1\";\n方法二：global proc look()&#123;&#125;;\n\n\n执行python脚本:\n maya.mel.eval(&#39;outlinerEditor -edit -selectCommand &quot;&quot; &quot;outlinerPanel1&quot;;&#39;) \n\n\n删除TurtleDefaultBakeLayer层：\n\n执行mel脚本\n //删除海龟渲染 mel脚本\nlockNode -l off TurtleDefaultBakeLayer;\ndelete TurtleDefaultBakeLayer;\nlockNode -l off TurtleRenderOptions;\ndelete TurtleRenderOptions;\nlockNode -l off TurtleBakeLayerManager;\ndelete TurtleBakeLayerManager;\n\n执行python脚本\n def delTurtleRender():\n    if mc.objExists('TurtleRenderOptions'):\n        mc.lockNode('TurtleRenderOptions', 'TurtleUIOptions', 'TurtleBakeLayerManager', 'TurtleDefaultBakeLayer', lock=0)\n        mc.delete('TurtleRenderOptions', 'TurtleUIOptions', 'TurtleBakeLayerManager', 'TurtleDefaultBakeLayer')\n        print u\"海龟渲染节点清理完成\"\n    else:\n        print u\"场景中海龟渲染节点已清理干净\"\ndelTurtleRender()\n\n\nMaya Arnold不能渲染: &#x2F;&#x2F; Rendering with Arnold Renderer… &#x2F;&#x2F; &#x2F;&#x2F; Result: Rendering Completed. See mayaRenderLog.txt for information. &#x2F;&#x2F; 是因为Maya 的mtoa环境变量丢失，导致渲染器使用的部分文件没有调用到，因此直接结束渲染。 解决办法： https://support.solidangle.com/display/AFMUG/Batch+Rendering 的Batch Render Flags   提到了解决问题的办法，就是在环境变量中增加如下环境变量（对应maya版本号）： MAYA_RENDER_DESC_PATH&#x3D;C:\\solidangle\\mtoadeploy\\对应maya版本号 然后，重新打开maya渲染。或者，重新安装渲染器，有概率解决问题。\n\n\n","categories":["Maya","杂项"],"tags":["锦囊小妙招"]},{"title":"Maya文件打开慢或者崩溃的检查办法","url":"/posts/20220503a2.html","content":"项目制作过程中常常会遇到制作文件打不开或者打开慢的情况，对于此类问题：\n\n如果是’.mb’文件，会比较麻烦些，需要在打开文件时不加载引用文件，然后一个一个加载引用文件，根据引用文件的加载情况进行判断是否有引用文件有问题。一般会出现：单个引用文件加载崩溃、单个引用文件加载慢、所有引用文件加载都没问题，但是保存后还是打开有问题，这时就需要分别尝试打开带有加载不同引用文件的maya文件。（之前碰到过引用文件中有的节点有冲突：相同的引用文件单独加载都没问题，但保存后加载会崩溃，然后逐步定位加载有问题的文件一步一步排除，最后将有冲突的节点重建才解决问题。）\n\n如果是’.ma’文件：\n\n使用上面的’.mb’文件的办法。\n在文件中插入 mel 脚本，在打开脚本的同时，执行mel脚本，通过脚本的日志内容情况来判断是什么文件导致的‘.ma’文件打不开，或者打开慢的情况。\n\n\n\n代码如下：\nimport codecs\n\ndef checkMayaAsciiFile(source_file, target_file, log_file):\n    \"\"\"\n    1. 用于检查 Maya Ascii 文件打开崩溃\n    2. - - - - - - - - - - - - - -耗时\n    Args:\n        source_file: ma 文件\n        target_file: 修改后的文件\n        log_file: logging\n\n    Returns: none\n\n    \"\"\"\n    # # 记录打不开的ma文件是从哪一行崩溃的\n    # __startMel = '''python(\"logFile='%s';ff = open(logFile,'w');ff.write(' ');ff.close();\");''' % log_file\n    # __proc = '''python(\"ff = open(logFile,'a');ff.write('%s - &#123;0&#125;\\\\\\\\n'.format(comp_time));ff.close();\");\\n'''\n    # __endMel = \"\"\n\n    # 记录打开文件时的耗时信息\n    __startMel = '''python(\"from datetime import datetime;import time;line_time=datetime.now();time.sleep(0.002);threshold_time=datetime.now() - line_time;start_time=line_time;logging=list();logFile='%s'\");''' % log_file\n    __proc = '''python(\"comp_time = datetime.now() - line_time;logging.append('%s - '+ str(comp_time)) if comp_time > threshold_time else None;line_time = datetime.now();\");\\n'''\n    __endMel = '''python(\"logging.append('\\\\\\\\n\\\\\\\\nStart Time - '+ str(start_time) + '\\\\\\\\nEnd Time - '+ str(line_time) + '\\\\\\\\nTotal Time - ' + str(line_time - start_time));ff = open(logFile,'w');[ff.write(line+'\\\\\\\\n') for line in logging];ff.close();\");'''\n\n    with codecs.open(source_file, \"r\", \"gbk\") as f:\n        aLines = f.readlines()\n\n    fileter = (\"select\", \"connectAttr\", \"dataStructure\", \"createNode\", \"requires\", \"currentUnit\")\n    # other relationship fileInfo\n    rule = 1\n    for num, line in enumerate(aLines):\n        line_add = \"\".join([aLines[num - 1][:-1], __proc % str(num)])\n        if rule:  # 文件开头的 file 每一行都加 mel\n            if __startMel:  # 文件开头结尾初始化命令\n                aLines[num] = __startMel + line\n                if __endMel:\n                    aLines[num - 1] = __endMel + aLines[num - 1]\n                __startMel = 0\n                continue\n            if \"file\" in line:  # 可能有的设置里会有file字符串,所以这里要独立规则\n                if \";\\n\" not in aLines[num - 1]:\n                    continue\n                aLines[num - 1] = line_add\n            if \"requires\" in line:  # requires 之后改变规则\n                rule = 0\n\n        # 在 fileter 参数里的,对它的前一行添加 mel\n        # setAttr 用的是 .attr 的方式,在它之后加 mel 会影响下一个 setAttr 所以这里添加这个过滤\n        for _ in fileter:\n            if _ in line:\n                if \";\\n\" in aLines[num - 1]:\n                    aLines[num - 1] = line_add\n\n    with codecs.open(target_file, \"w\", \"gbk\") as ff:\n        for lines in aLines:\n            ff.write(lines)\n\nif __name__ == '__main__':\n    srcFile = r\"E:\\test\\shot00401.ma\"\n    srcFile = srcFile.replace(\"\\\\\", \"/\")\n\n    sourceFile = srcFile\n    targetFile = srcFile[:-3] + \"_v01.ma\"\n    logFile = srcFile[:-3] + \"_v01.txt\"\n    # print(sourceFile, targetFile, logFile)\n    checkMayaAsciiFile(sourceFile, targetFile, logFile)\n\n以上代码中，需要将”E:\\test\\shot00401.ma”替换成你的‘.ma’文件路径，执行完成后，会在同级文件目录下生成一个版本号为‘-v01’的‘.ma’文件，使用Maya打开该文件，打开文件的同时会执行文件中的mel脚本保存日志信息，文件读取完成后，也会在统计目录下生成一个版本号为‘-v01’的txt日志文件，打开文件分析即可。\n转载部分内容转载自：https://ruben.blog.csdn.net/article/details/90082639\n","categories":["Maya","小工具"],"tags":["检查"]},{"title":"在物体的点上创建跟踪对象","url":"/posts/20220503a1.html","content":"之前做测量相机焦距工具的时候发现不能把焦距添加约束到物体上的点，尤其是做了abc缓存之后，由于并没有对点进行编辑，不管是在自身空间还是世界空间中，点的位置在数值上都没有变换，被约束的相机的焦点依旧保持在原地，因此对点添加普通的的约束并不能达到效果，我们需要换一种方式进行约束。\n\n可以使用给点创建毛囊的办法，利用uv映射的点的位置始终保持不变，但是物体的世界矩阵在变化的原理，将点世界坐标的信息传递给毛囊，毛囊会一直跟着点的，此时我们只需要约束毛囊就能达到我们想要的效果了。\n\n代码如下：\n# -*- coding:utf-8 -*-\n# !/usr/bin/env python27\n# @Author: Mirror\n# @Time: 2022-03-15\n# description: 该脚本用于在选中点的位置上创建定位毛囊，该毛囊通过UV点定位，所有使用后不能调整点所在的UV\n# =========================================\nimport maya.cmds as mc\n\ndef buildFollicle(points):\n    if not points:\n        return\n    if type(points).__name__ == \"str\":\n        points = [points]\n    for point in points:\n        poly_transform = mc.listRelatives(mc.listRelatives(point, p=True, s=True)[0], p=True, s=True)[0]\n        point_uvVertex = mc.polyListComponentConversion(point, fv=True, tuv=True)\n        point_uvposition = mc.polyEditUV(point_uvVertex[0], q=1)\n\n        follicle = mc.createNode(\"follicle\", n=\"follicle_%s\" % point.replace(\"[\", \"\").replace(\"]\", \"\").replace(\".\", \"_\"))\n        follicle_transform = mc.listRelatives(follicle, p=True)[0]\n\n        mc.connectAttr(poly_transform + \".worldMatrix[0]\", follicle + \".inputWorldMatrix\")\n        mc.connectAttr(poly_transform + \".outMesh\", follicle + \".inputMesh\")\n        mc.connectAttr(follicle + \".outTranslate\", follicle_transform + \".translate\")\n        mc.connectAttr(follicle + \".outRotate\", follicle_transform + \".rotate\")\n        mc.setAttr(follicle_transform + \".parameterU\", point_uvposition[0])\n        mc.setAttr(follicle_transform + \".parameterV\", point_uvposition[1])\n\n\nif __name__ == \"__main__\":\n    vertexs = mc.ls(sl=True,fl=True)\n    buildFollicle(vertexs)\n\n\n注意：在添加了定位的毛囊之后，不能修改UV，否则毛囊会回到原点，约束失效，需要重新创建毛囊和约束。\n参考官网中相关的介绍：https://help.autodesk.com/view/MAYAUL/2018/CHS/?guid=GUID-A0D2DD53-FE41-4244-8635-CD4651ABF97F\n","categories":["Maya","小工具"],"tags":["灯光","UV"]},{"title":"一些好用的网站","url":"/posts/20220501a2.html","content":"本文推荐一些多快好省的网站、技术大佬的博客网站、专业网站。\n\n\n图标下载\n\nIcon图标下载：https://icon-icons.com/zh/\n阿里巴巴矢量图库：https://www.iconfont.cn/\n图片格式转换： https://www.butterpig.top/ico/\n\n\n影视行业软件下载网站：\n\n画忆大佬的软件下载网站(无毒无公害)：www.iiicg.com\n\n\n技术大佬们的博客网页\n\nTD手册：https://cg-td-course.readthedocs.io/zh_CN/latest/index.html\n凌云大佬技术博客分享：https://lingyunfx.com/\n汝小右大佬博客：https://ruben.blog.csdn.net/?type=blog\n\n\n行业官网\n\nMaya2022 用户文档：https://help.autodesk.com/view/MAYAUL/2022/CHS/\nYeti 用户文档：https://support.peregrinelabs.com/support/solutions/66000172201\nArnold 用户文档：https://www.arnoldrenderer.com/news/\nNuke 用户文档：https://learn.foundry.com/nuke/13.1/content/learn_nuke.html\nKatana 用户文档：https://learn.foundry.com/katana/5.0/Content/learn_katana.html\nDeadline 用户文档：https://docs.thinkboxsoftware.com/\nPyside2 用户文档：https://wiki.qt.io/Main\nShotGrid 用户文档：https://help.autodesk.com/view/SGSUB/CHS/\nAutoIt3 用户文档：https://www.autoitscript.com/autoit3/docs/\n\n\n\n","categories":["Doc"],"tags":["网站推荐"]},{"title":"QT中的系统托盘图标和系统消息推送","url":"/posts/20220501a1.html","content":"本文记录: 使用 PySide2 编写工具界面时，需要为工具创建系统托盘图标以及推送消息的方法。以方便用户对工具进行操作。\n\n\n通过 PySide2 创建系统托盘，需要使用 PySide2.QtWidgets.QSystemTrayIcon 这个类。这个类中需要使用了以下常用方法，就可以创建最基本的系统托盘图标：\n\n\nQSystemTrayIcon   创建一个系统托盘对象\nQSystemTrayIcon.setContextMenu    添加右键菜单(QMenu)\nQSystemTrayIcon.showMessage   在右下角弹出要提示消息\nQObject.connect 连接信号和槽\n\n使用上面的方法，可以完成：\n\n在系统托盘中创建一个程序图标。\n\n  \n\n在程序创建完成托盘图标后，推送一条提示程序已经启动的系统消息。\n\n  \n\n鼠标点击图标时的左右键功能。\n\n  \n代码示例如下:\nimport sys\nfrom PySide2.QtWidgets import QApplication, QAction, QMenu, QSystemTrayIcon\nfrom PySide2.QtCore import SIGNAL, QObject\nfrom PySide2.QtGui import QIcon\n\ndef close():\n    print(\"close\")\n\ndef restart():\n    print(\"restart\")\n\ndef show():\n    print(\"show\")\n\napp = QApplication(sys.argv)\n\nexit = QAction(QIcon(\"E:/Python_study/startLauncher/Icon/Menu.ico\"), \"Exit\", )\nQObject.connect(exit, SIGNAL(\"triggered()\"), close)\nres = QAction(QIcon(\"E:/Python_study/startLauncher/Icon/Menu1.ico\"), \"Restart\", )\nQObject.connect(res, SIGNAL(\"triggered()\"), restart)\n\nmenu = QMenu()  # 创建菜单，添加菜单选项\nmenu.addAction(exit)\nmenu.addAction(res)\n\ntrayIcon = QSystemTrayIcon(QIcon(\"E:/Python_study/startLauncher/Icon/Menu4.ico\"))  # 创建系统托盘\ntrayIcon.setContextMenu(menu)\nQObject.connect(trayIcon, SIGNAL(\"activated(QSystemTrayIcon::ActivationReason)\"), show)\n\ntrayIcon.show()\ntrayIcon.setToolTip(\"启动器\")\ntrayIcon.showMessage(\"启动器已经启动!\", \"左击显示窗口\\n右击显示菜单\", QIcon(\"E:/Python_study/startLauncher/Icon/Menu_Note1.ico\"))\n\nsys.exit(app.exec_())\n\n\n执行代码后，会在电脑桌面系统托盘创建一个本程序的图标，同时会推送一条启动信息，该信息会自动收回。上面的代码没有判断点的是左还是右键，所以只要鼠标点击图标都会先打印一遍 “show”,请自行判断。\n","categories":["Qt","学习笔记"],"tags":["QT事件","信号&槽","系统托盘图标和消息"]},{"title":"USD框架的搭建","url":"/posts/20220421a1.html","content":"今天来介绍一下 windows 环境下 USD 的独立安装过程。首先，我们需要了解几个网站：\nUSD 的帮助文档 ：https://graphics.pixar.com/usd/release/index.html\nUSD 的Github仓库 ：https://github.com/PixarAnimationStudios/USD\n\n安装准备：需要准备：Python2、Cmake、NASM、Microsoft Visual Studio2017、Microsoft Visual Studio Code\n1. 确认环境中有Python2。在 windows 上安装 USD 需要我们的环境中有 Python， 由于 USD 目前还不支持Python3 ，因此我使用的是 Python2.7.16 ,没有Python2 的小伙伴可以从官网下载，下载安装好后，需要调整一下环境变量的顺序，将Python2的相关环境变量提升到Python3的前面，这样可以在后面安装的时候直接调用Python2的环境,就不会出现一些奇怪的问题导致安装失败，如下图。\n\n\n2. 安装CMAKE工具，如果电脑上没有CMAKE，可以从这里下载，往下翻，找到相应的平台和系统版本，下载到一个可安装的文件，使用默认安装就好。\n\n\n3. 安装NASM，如果电脑上也没有NASM，则可以从这里下载，打开链接后选择一个合适的版本，我使用的是2.15.05版本的NASM，双击文件夹，选择自己系统对应的文件夹，再次双击，可以看到一个安装程序，点击即可下载，没有特殊需求的话，尽量使用默认安装。\n\n\n4. 安装Microsoft Visual Studio，USD 暂时不支持较新的版本，本案例使用的是VS2017版本，可以从这里下载，选择一个合适的版本，安装过程中选择使用C++的桌面开发。\n\n5. 安装Microsoft Visual Studio Code，如果没有VSCode，可以从这里下载，选择一个合适的版本，下载后默认安装好，打开下载Python拓展插件，并将上面安装的Python2的执行程序路径填入对应位置，如下图所示。\n\n\n\n\n\n接下来我们还需要为Python2安装一些功能模块：PySide、pyd、pyopengl、Jinja2，在cmd中依次执行下面的指令即可\npip install PySide\npip install pyd\npip install pyopengl\npip install Jinja2\n注：这里如果出现“pip Fatal error in launcher: Unable to create process...”错误，可以通过python安装文件的修复功能来解决，点击repair。\n\n构建 USD先从USD 的Github仓库下载 USD 源码到本地，打开“x86 Native Tools Command Prompt VS 2017”界面，这里不能使用x64,并且对于高版本的VS,不管是\"X64\" 还是 \"x86\" 均不能安装成功。输入 python \"你的USD源码下载位置\"\\build_scripts\\build_usd.py \"C:\\USD\" ，其中\"C:\\USD\"是你的安装位置（安装位置中似乎不能有空格，我尝试了几次将usd安装在带空格的\"Program Files (x86)\"中，都没有成功）。程序会自动为你安装zlib，boost，TBB，OpenSubdiv用来构建USD环境。这个过程只有简单的几条语句提示，没有进度条，并且可能会报错或者安装不成功（也许是下载速度的原因），多执行几次上面的构建指令就好了，我也是安装了三次才成功。成功后会提示你，需要将 \"C:\\USD\\lib\\python\"添加进系统变量PYTHONPATH中，再在系统变量 PATH 中添加 \"C:\\USD\\bin\" 和 \"C:\\USD\\lib\"两个路径，如下图所示。\n\n\n至此USD环境就搭建好了。\n验证打开一个cmd窗口，cd 进入你的USD源代码目录,然后输入指令：“usdview .\\extras\\usd\\tutorials\\convertingLayerFormats\\Sphere.usd”，出现下面的界面就表示成功了。\n\n接下来就可以愉快地学习案例了！！！\n参考文章\nhttps://zhuanlan.zhihu.com/p/437422802\nhttps://github.com/PixarAnimationStudios/USD/blob/release/README.md#getting-and-building-the-code\n\n","categories":["Doc","学习笔记"],"tags":["USD","Pipeline"]},{"title":"QT中的异形窗口","url":"/posts/20220326a2.html","content":"记录一下 QT 中异形窗口的创建。\n主要标志在 QWidget 中，通过给窗口设置特定的标志，可以将窗口设置为不同的形状，比如让窗口无标题，或者直接让主窗口透明\nsetWindowFlags(Qt.FramelessWindowHint)      # 去掉标题栏\nsetMask(QPixmap(img).mask())                # 设置图片透明的地方为穿透\nsetAttribute(Qt.WA_TranslucentBackground)   # 设置窗口透明\n\n当为窗口设置了使用图片作为 Mask 遮罩后，Qt.FramelessWindowHint 标志会自动指定。\n实现示例创建一个基本窗口# Author: Mirror\nimport sys\nfrom PySide2.QtWidgets import QApplication, QWidget\nfrom PySide2.QtCore import Qt\nfrom PySide2.QtGui import QPixmap\n\nclass MainWindow(QWidget):\n    def __init__(self,):\n        super().__init__()\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    app &#x3D; QApplication(sys.argv)\n    form &#x3D; MainWindow()  # 实例化窗口小部件\n    form.show()\n    sys.exit(app.exec_())\n\n窗口效果\n设置窗口标志self.setWindowFlags(Qt.FramelessWindowHint)  # 去掉标题\n\n窗口效果窗口会变成一块没有标题的白板\n设置窗口Maskself.starticon &#x3D; QPixmap(r&quot;ImagePath&quot;)\nself.setMask(self.starticon.mask())\n\n窗口效果窗口会根据你使用的 Mask 图片进行裁剪\n窗口重写事件由于窗口被设置为无标题窗口后，鼠标不能对窗口进行移动，因此，我们还需要将窗口的鼠标事件进行重写。完整代码：\n# !&#x2F;user&#x2F;bin&#x2F;python37\n# -*- coding: utf-8 -*-\n# Author:Mirror\n# Time: 2022&#x2F;03&#x2F;26\n# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nimport sys\nfrom PySide2.QtWidgets import QApplication,QWidget\nfrom PySide2.QtCore import Qt\nfrom PySide2.QtGui import QPixmap, QCursor\n\nclass MainWindow(QWidget):\n    def __init__(self,):\n        super().__init__()\n        self.setWindowFlags(Qt.FramelessWindowHint)  # 去掉标题（还有一些别的窗口类型选择，请自行查阅）\n        self.starticon &#x3D; QPixmap(r&quot;E:\\Python_study\\startLauncher\\Icon\\startBackgroundMask.svg&quot;)\n        self.setMask(self.starticon.mask())\n\n    # 鼠标按下\n    def mousePressEvent(self, event):\n        if event.button() &#x3D;&#x3D; Qt.LeftButton:\n            self.m_drag &#x3D; True  # 鼠标按下或抬起标志位\n            self.m_DragPosition &#x3D; event.globalPos() - self.pos()  # 当前单击点相对于窗口本身的坐标(只检测窗口中的点击)\n            self.setCursor(QCursor(Qt.SizeAllCursor))  # 设置光标形状 小手抓取\n\n        if event.button() &#x3D;&#x3D; Qt.RightButton:  # 按下右键 取消左键按下，结束鼠标移动时间\n            if self.m_drag &#x3D;&#x3D; True:\n                self.m_drag &#x3D; False\n\n    # 鼠标移动\n    def mouseMoveEvent(self, QMouseEvent):\n        if Qt.LeftButton and self.m_drag:\n            # 当左键移动窗体修改偏移值\n            self.move(QMouseEvent.globalPos() - self.m_DragPosition)\n\n    # 鼠标抬起\n    def mouseReleaseEvent(self, QMouseEvent):\n        self.m_drag &#x3D; False\n        self.setCursor(QCursor(Qt.ArrowCursor))\n\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    app &#x3D; QApplication(sys.argv)\n    form &#x3D; MainWindow()\n    form.show()\n    sys.exit(app.exec_())\n\n通过上面的代码，我们就可以获得一个可以被鼠标移动的异形窗口啦。\n","categories":["Qt","学习笔记"],"tags":["QT事件","异形窗口"]},{"title":"QT中QToolButton的双击事件","url":"/posts/20220326a1.html","content":"前言写工具界面的时候，发现 QPushButton 按钮不能被图标完全覆盖，而选择使用 QToolButton 按钮，但是 QToolButton 按钮本身是没有双击事件的，我在写工具的时候又对这个双击事件很执着，就自己实现一下，并为该结果做记录。\n\n实现逻辑要实现 QToolButton 按钮的双击事件：需要新建一个继承于 QToolButton 的子类，该类继承 QToolButton 的 click 鼠标单击事件，添加 singleClicked 和 doubleClicked 两个信号用于发送我们想要的单/双击信号，并在子类中添加一个 Qtimer 作为判断依据：将 QTimer 设置为单次触发, 并为QTimer 设定一个较短的时间，在该时间内，click信号链接到事件判断函数，如果再次点击该按钮则判断为双击事件，同时将 QTimer 停止；反之 QTimer 超时，QTimer 发送超时信号到单击事件函数，也需要将Qtimer 停止。当实例化这个子类后，点击按钮，该 click 信号即在实例内部进行判断。\n\n代码示例# !/user/bin/python37\n# -*- coding: utf-8 -*-\n# Author:Mirror\n# Time: 2022/03/26\n# ================================\nimport sys\nfrom PySide2.QtWidgets import QApplication, QToolButton\nfrom PySide2.QtCore import Qt, Signal, QTimer\n\nclass DccButton(QToolButton):\n    \"\"\"定义ToolButton按钮双击事件\"\"\"\n    doubleClicked = Signal()  # 双击信号\n    singleClicked = Signal()  # 单击信号\n    def __init__(self):\n        super(DccButton, self).__init__()\n        self.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)  # 设置图标在字体之上\n        self.timer = QTimer()  # 创建触发器\n        self.timer.setSingleShot(True) # 仅单次触发\n        self.timer.setInterval(200) # 触发间隔，用于判断是否为双击\n        self.timer.timeout.connect(self.singleClick) # 超时信号连接至单击\n        self.clicked.connect(self.checkDoubleClick) # 连接至成员函数判断是否为双击\n\n    def singleClick(self):\n        \"\"\"\n            发送单击信号\n        \"\"\"\n        self.timer.stop()\n        self.setDown(False)\n        self.singleClicked.emit()\n        print(\"单击\")\n\n    def checkDoubleClick(self):\n        \"\"\"\n            判断是否为双击信号，否则信号超时\n        \"\"\"\n        if not self.isDown():\n            self.setDown(True)\n        if self.timer.isActive():\n            self.timer.stop()\n            self.setDown(False)\n            self.doubleClicked.emit()\n            print(\"双击\")\n            return\n        else:\n            self.timer.start()\n\n\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n    form = DccButton()\n    form.show()\n    sys.exit(app.exec_())\n","categories":["Qt","学习笔记"],"tags":["QT事件","信号&槽"]},{"title":"rez安装使用","url":"/posts/20220314a1.html","content":"Rez 是一个跨平台程序包管理器，通过它可以给程序配置独立的环境，每个独立环境中只是引用了这些包。所以它的环境配置是轻量级的，与其它程序包环境管理不同的是，所有的程序包都安装在一个中央统一的位置，尽管有几百个包，通常也只需要几秒就可以进行配置。将 Rez 作为工作室 DCC 软件启动器依赖项，是个不错的选择。下面将简单介绍 Windows 环境下，Rez 包管理器如何安装使用。\n下载安装包从 GitHub 上拉取 Rez 原项目的的相关仓库，然后打开CMD进入拉取仓库所在的目录中执行：\npython .&#x2F;install.py \n这将会把包安装在当前位置的 &#x2F;opt&#x2F;rez 目录下也可以使用Pip进行安装：\npip install rez\n但使用 pip 的安装方式并不能很好的用在生产环境中,使用 install 脚本安装是推荐的方法，它可以保证 Rez 拥有独立 python 于的环境独立运行。\n创建基本的 Rez 包这里需要使用管理员权限去安装包，rez-bind 工具创建基于已安装在系统上的软件的 Rez 包：（–quickstart是以标准形式安装包）\nrez-bind --quickstart\n你也可以分开安装\nrez-bind platform\nrez-bind arch\nrez-bind os\nrez-bind python\n安装好之后，会在 %userprofile%&#x2F;packages 目录下找到已经安装的 Rez 包\n验证安装结果为了验证是否安装成功，可以使用下面的命令：（其中 “which python”是你的python版本）\nrez-env python-which python\n使用 exit 退出环境。\n构建第一个包.需要确认%userprofile%&#x2F;packages 存在且可写入.需要确认cmake 工具安装且可用（注：官方文档中会使用这个工具在ios系统上安装下面的包，但我还未在Windows10系统上成功安装该包，似乎有些依赖包的冲突问题，但好像不影响使用，正在求证中。。。）rez-build 工具用于构建包并在本地安装它们（%userprofile%&#x2F;packages下）。 完成后，您可以通过 rez-env 使用它们，就像任何其他软件包一样：\ncd example_packages&#x2F;hello_world\nrez-build --install\n\n测试构建的包使用rez-env命令来请求一个（或多个）你已经安装的软件包环境\nrez-env hello_world\n提示符前的插入符号 (&gt;) 是一个视觉提示，告诉你现在位于 rez 配置的子 shell 中。 Rez 不会更新当前环境，而是配置一个子shell 并将你置于其中。如果你已经在rez shell的配置环境中，并且忘记了当前可用的软件包列表。可以使用 rez-context 工具查看：\nrez-context\n退出这个环境，使用exit命令。\n你还可以创建一个已配置的环境并在其中运行一个命令，只需一个命令。 当您使用这种形式时，shell 会在命令运行后立即退出：\n","categories":["Rez"],"tags":["Pipeline","包管理"]},{"title":"CG流程中\"USD\"的探索与运用","url":"/posts/20220307a1.html","content":"","categories":["Doc","学习笔记"],"tags":["USD","Pipeline"]},{"title":"Deadline中的事件示例","url":"/posts/20220306a1.html","content":"此文章是记录Deadline农场管理软件中的消息事件插件编写的示例。\n事件插件的作用和执行顺序Deadline 的所有插件都是Python写的，事件插件可用于更新新快照或任务的状态，或者可用于在一个作业状态更改时处理相关的作业。并且插件都是以非交互式的方式执行，编写插件时不应该包含阻塞操作(如无限循环)或需要用户输入的界面。当我们的事件插件被执行时，日志中会显示插件是从哪里加载的。Deadline中有很多事件，事件插件的触发是按顺序的，并且顺序是可配置的：\n\n创建事件脚本首先要在存储库的custom\\events文件夹中创建一个文件夹，并为其命名您的事件插件，如：\n\n创建好文件夹后，我们需要新建一个和该文件夹相同明明的 .py 文件，并在文件中写入相应的基本内容（导入deadline事件命名空间；GetDeadlineEventListener()函数获取MyEvent类的一个实例，没有会报错；MyEvent类将需要基于想要响应的事件实现某些回调；当不再使用该事件插件，CleanupDeadlineEventListener()函数进行自动清理。）：\n\nfrom Deadline.Events import *\n\ndef GetDeadlineEventListener():\n    \"\"\"This is the function that Deadline calls to get an instance of the\n    main DeadlineEventListener class.\n    \"\"\"\n    return MyEvent()\n\ndef CleanupDeadlineEventListener(deadlinePlugin):\n    \"\"\"This is the function that Deadline calls when the event plugin is\n    no longer in use so that it can get cleaned up.\n    \"\"\"\n    deadlinePlugin.Cleanup()\n\nclass MyEvent(DeadlineEventListener):\n    \"\"\"This is the main DeadlineEventListener class for MyEvent\"\"\"\n    # TODO: Place code here to replace \"pass\"\n    pass\n\n当我们完成上述脚本文件的内容后，我们将会得到下面的脚本内容：\n#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n# @Auther: Mirror\n# @Time: 2020/07/01\n# =========================================\nfrom System import *\nfrom System.Collections.Specialized import *\nfrom System.IO import *\nfrom System.Text import *\nfrom Deadline.Scripting import *\nfrom Deadline.Events import *\nimport time\n\n\n######################################################################\n## This is the function that Deadline calls to get an instance of the\n## main DeadlineEventListener class.\n######################################################################\ndef GetDeadlineEventListener():\n    return MyEvent()\n\n\n######################################################################\n## This is the function that Deadline calls when the event plugin is\n## no longer in use so that it can get cleaned up.\n######################################################################\ndef CleanupDeadlineEventListener(deadlinePlugin):\n    deadlinePlugin.Cleanup()\n\n\n######################################################################\n## This is the main DeadlineEventListener class for MyEvent.\n######################################################################\nclass MyEvent(DeadlineEventListener):\n\n    def __init__(self):\n        # Set up the event callbacks here\n        self.OnJobFinishedCallback += self.OnJobFinished\n        self.OnJobFailedCallback += self.OnJobFailed\n\n    def Cleanup(self):\n        del self.OnJobFinishedCallback\n        del self.OnJobFailedCallback\n\n    def OnJobFinished(self, job):\n        # TODO: Connect to pipeline site to notify it that the job for a particular\n        # shot or task is complete.\n        job_name = job.JobName\n        job_mach = job.GetJobInfoKeyValue(\"MachineName\")\n        job_user = job.JobUserName\n        if job_mach.lower() == \"renderfarm\":\n            slaves = None\n        else:\n            slaves = [job_mach]\n        if slaves:\n            for each in slaves:\n                curr_time = time.strftime('%Y-%m-%d', time.localtime(time.time()))\n                slave = each\n                massages = \"Cur_time:  &#123;curtime&#125;\\nJob_user:  &#123;user&#125;\\n\\nmassages:  Job named \\'&#123;jobname&#125;\\' had been complate\".format(\n                    curtime=curr_time, user=job_user, jobname=job_name)\n                self.sendmessages(slave, massages)\n        print(\"================================================================================================\")\n        self.LogInfo(\"\\'%s\\' is complated\" % job_name)\n        self.LogInfo(\"================================================================================================\")\n\n    def OnJobFailed(self, job):\n        \"\"\"\n        Deadline will to do sometion when job or task is faild\n        :param job: which Work being monitored\n        :return: None\n        \"\"\"\n        job_name = job.JobName\n        job_mach = job.GetJobInfoKeyValue(\"MachineName\")\n        job_user = job.JobUserName\n        if job_mach.lower() == \"renderfarm\":\n            slaves = [\"DESKTOP-Mirror\"]\n        else:\n            if job_mach == \"DESKTOP-Mirror\":\n                slaves = [job_mach]\n            else:\n                slaves = [job_mach, \"DESKTOP-Mirror\"]\n        for each in slaves:\n            curr_time = time.strftime('%Y-%m-%d', time.localtime(time.time()))\n            slave = each\n            massages = \"Cur_time:  &#123;curtime&#125;\\nJob_user:  &#123;user&#125;\\nmassages:  Job named \\'&#123;jobname&#125;\\' had been failed\".format(\n                curtime=curr_time, user=job_user, jobname=job_name)\n            self.sendmessages(slave, massages)\n        print(\"================================================================================================\")\n        self.LogInfo(\"\\'%s\\' is failed\" % job_name)\n        self.LogInfo(\"================================================================================================\")\n\n    def sendmessages(self, slaves, messages):\n        \"\"\"\n        :param\n            slaves: machines`s machines name or IP address.\n            messages: the messages which is send by current serve]\n        :return\n            cmd is executed by system\n        \"\"\"\n        args = StringCollection()\n        args.Add(\"-SendPopupMessage\")\n        args.Add(\"%s\" % slaves)\n        args.Add(\"%s\" % messages)\n        ClientUtils.ExecuteCommand(args)\n\n\n\n创建事件参数文件创建完事件插件的脚本后，我们需要在上述文件夹中为事件插件添加与文件夹同名的参数文件（.param）供 Deadline 进行读取，创建参数界面：\n参数文件内容：\n[State]\nType=Enum\nItems=Global Enabled;Opt-In;Disabled\nCategory=Options\nCategoryOrder=0\nIndex=0\nLabel=State\nDefault=Disabled\nDescription=How this event plug-in should respond to events. If Global, all jobs and slaves will trigger the events for this plugin. If Opt-In, jobs and slaves can choose to trigger the events for this plugin. If Disabled, no events are triggered for this plugin.\n\n[EventCallbacks]\nType=Label\nDescription=The Event Callbacks that this Event Plugin subscribes to.\nDefault=OnJobFailed\n\n它将声明 Monitor 用来生成用户界面的属性，该用户界面用于修改数据库中的自定义设置，创建该文件后，打开监视器并进入超级用户模式。然后选择Tools -&gt; Configure Events，在左边的列表中查找该事件插件。\n\n至此，在 Deadline 中创建自定义任务消息失败&#x2F;成功的事件已经完成，每当Deadline 中有任务失败时&#x2F;成功时，Deadline 会自动给任务的提交者发送一条相关的消息弹框，用于给制作人员反馈及时的渲染消息。\n注意：需要注意 Deadline 当前使用的 Python 版本，避免出现不兼容的情况\n咱们有空可以看看官方文档是怎么说的，里面有更加详细的内容哦。\n","categories":["Deadline","插件"],"tags":["插件"]},{"title":"如何搭建个人博客","url":"/posts/20220302a2.html","content":"作为一名学习任何技术都习惯做笔记的好学生，还在使用思维导图记录知识点？或是用word写文档，甚至是\"白纸黑字\"码字！！！都2202年了，是不是该寻找一种既方便自己随时查找翻看，又可以和小朋友们一起分享知识和经验的方式呢？这时，拥有一个属于自己的个人博客，实属是一个迫在眉睫的需求。于是，我有了自己的博客。接下来将介绍从无到有搭建属于自己的个人博客过程。\n\n准备材料1.一台能联网、没有脑梗的计算机2.Windows系统（我就只会用“窗口”）3.git包管理工具4.一个知道账号和密码的github账号5.记住这个网址，一会儿要用：https://www.nodejs.org/6.随时准备问候度娘，因为我也不清楚你会遇到些什么疑难杂症\n开始搭建本地环境首先，点击下载git，下载适合自己系统的最新git版本安装包，以默认方式安装。 \n然后，我们再在电脑上访问刚才让你记住的网址，从网址上下载我们需要的LTS版node.js安装包，直接双击安装它。不出意外的话，安装好的node.js会给你反馈安装了两个组件（node.js和npm包管理工具），我们可以直接去cmd中验证。\n\n打开cmd,利用npm包管理工具安装今天的主角Hexo博客，先输入命令行安装cnpm的同时将镜像源指向淘宝：\n\nnpm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org\n\n安装hexo-cli：\n\ncnpm install -g hexo-cli\n\n找个你觉得合适的位置创建一个文件夹，用于存放你的博客产生的所有文件，在cmd中将路径切换到创建的文件夹：\n\ncd &#x2F;d &quot;你刚刚创建的文件夹路径&quot;\n\n初始化咱们的博客目录：\n\nhexo init \n\n启动我们的Hexo本地服务，可在https://localhost:4000访问，但博客中只有一篇和hexo用户指南相关的文章：\n\nhexo s\n\n如果网页打不开，win10执行下面代码后再重复上一步： \n\nnpm install hexo-server\n\n创建新的博客文章： \n\nhexo new &quot;我的第一篇博客文章&quot;\n\n创建好后，在刚刚创建的博客文件夹的\\source\\_posts\\路径下能看到刚才创建的\"我的第一篇博客文章.md\"文件，用文本编辑器即可对内容进行编辑，然后刷新https://localhost:4000，就能看到刚刚创建的博客文章出现在网页上，ctrl + C 退出本地服务，。\n\n清除产生的静态博客文件(public)文件夹： \n\nhexo clean\n\n\n构建存储库登录github,创建一个新的仓库用于存储从本地推送的静态博客文件：repository neme 必须是：\"GitHub昵称加.github.io\"，description添加自定义描述，创建库。\ncmd下载hexo插件：\n\ncnpm install --save hexo-deployer-git\n\n文本打开博客文件夹根目录下的\"_config.yml\"文件，在文件尾部添加在文件尾部添加：\n\n## 添加储存库配置\ndeploy:\n  type: git\n  repo: (你的储存库地址)\n  branch: master \n## 注意：冒号后面有空格\n\n要将博客部署到github上，需要先配置git全局用户名和邮箱：\n\ngit config --global user.email \"github中的邮箱地址\"\ngit config --global user.name \"github中的用户名\"\n\n从22021年8月14日(七夕)那天开始，推送代码到GitHub需要使用token登录而不是密码，因此，我们需要先获取token。\n\n使用git生成SSH，运行 git Bash 客户端，检测是否存在ssh文件,换句话说就是检查是否存在 id_rsa.pub 或 id_dsa.pub 文件,如果存在可以跳过下面两步，输入如下代码：\n\ncd ~/.ssh\nls\n\n创建SSH：\n\nssh-keygen -t rsa -C &quot;你的邮箱&quot;\n\n等待一会儿，当看到\"Your identification has been saved in /c/Users/you/.ssh/id_rsa.\nYour public key has been saved in /c/Users/you/.ssh/id_rsa.pub.\nThe key fingerprint is:.............\"内容时，表示创建成功。在C盘User文件夹（可能会在桌面）可以找到ssh文件夹， 需要把id_rsa.pub文件中的内容添加到github。步骤是 Settings-->SSH and GPG Keys --->News SSH key，然后把id_rsa里的内容复制进去。\n\n回到cmd,部署博客到Github,两次输入都需要输入用户名和令牌(令牌不要手动输入，可以直接复制粘贴，尽管看不到粘贴内容，但还是要操作，才能成功):\n\nhexo d\n\n稍等两分钟，就可以访问博客页啦：https://github昵称加.github.io\n\n\n更换主题可以 点击这里 获取更多主题仓库地址，克隆主题到本地：\n\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/主题名称\n\n修改博客根目录_config.yml文件，修改theme字段后的内容为 “主题名称”。\n\n清理hexo目录：\n\nhexo clean\n\n重新生成hexo静态博客文件夹及其内容：\n\nhexo g\n\n推送远端：\n\nhexo d\n\n\n大佬的博客搭建教程视频：点击这里，更多的部署细节可在视频中找到哦。\n","categories":["Doc","学习笔记"],"tags":["Blog","Hexo","github"]},{"title":"CG流程中使用ACES色彩管理","url":"/posts/20220302a1.html","content":"构建CG流程中的ACES色彩管理流程 ,为什么要构建呢？因为：1.色域更高，能容纳更多的色彩，显示的色彩更丰富；2.能接受更高的灯光强度，画面比较不会过曝（不要调皮地将灯光强度调的特别高哦）;3.更物理更真实，颜色会随着亮度地提升，饱和度逐渐降低。相对的就会有些缺点：图片占用存储空间会变大(对影视动画没什么影响)。\n在CG流程中的大概过程就是，sRGB图片进入DCC软件被AECScg线性转换函数转换编码到ACES色域中被管理&gt;渲染器处理贴图信息后生成ACES色域图片&gt;经过编码转换到视图中显示或输出为指定色域的图片用于存储(srgb或ACES)、进一步编辑（ACES）\n测试环境Substance painter 7.1 + Maya 2020.4 + Nukel2.3 + ACES1.1\n\nSP软件配置由于SP要在7.4版本以后才支持 OCIO 配置文件，并且目前大部分资产贴图都采用sRGB色域编码，因此默认使用传统 SP(sRGB)到 MAYA(ACES) 中进行 sRGB 色域空间转换到 ACES 色域空间的方式。传统SP流程可以通过LMT(外观转换)的LUT(查找表)文件用于显示（只是看起来和AECES差不多，但实除上还是SRGB色域的图片）具体方法是：file > import resource > 添加资源 > 选择Lut文件 > 修改定义为 colorLut > 导入到\"工具架\" > 导入，然后在显示设置中将 activate post effects恢复默认,勾选activate post effects，勾选activate post effects > tone mapping(色调映射),将 activate post effects > tone mapping > function(功能)设置为log(日志)，并勾选activate color porfile > porfile 修改为 ACES_Standard_log,white_Point 设置为默认值，此时我们从SP软件的视口中看见的色彩在视觉上基本等同ACES色域图显示的效果。\n\nMay启动时配置 ACES 色彩管理Maya中使用 ACES 色彩管理空间，在具备有效的 config.ocio 配置文件的情况下，为 Maya 设置环境变量\"OCIO = 文件全路径\",此时Maya中的色彩管理空间将使用 OCIO 配置文样中的设置，该设置会在基于ACES 色彩管理的基础上自动修改渲染预览界面和视图界面的色彩空间，我们在显示器中看到的色彩信息并非线性空间的色彩信息，Maya后台输出的图片也是经 ACES 色彩空间编码后的图片，此时将渲染图片放入使用相同 ACES 配置文件的 Nuke 软件中，即可直接对 ACES 图片进行线性数据的操作。\n\n\nMaya 应用 OCIO 输入色彩空间规则到图片使用 OCIO 配置文件后，若勾选\"使用 OCIO 输入颜色空间规则\"则会使用\"OCIO Standard Rule\"对输入的文件进行色彩空间的转换，若不使用，则需要手动制定规则（自定义的配置不起作用时，可尝试将软件切成英文版)，然后将自定义的标准的色彩管理策略导出为 CM 文件,并添加环境变量\"MAYA_COLOR_MANAGEMENT_POLICY_FILE=CM文件全路径\"、\"MAYA_COLOR_MANAGEMENT_POLICY_LOCK=1\",用以全局配置所有渲染制作机，使保持相同的色彩配置，手动指定规则将按照规则的从上往下的顺序应用规则，由匹配成功的第一个规则指定输入的色彩空间。\n\n\n色彩空间管理的其他设置Ui 设置:启用后 Maya中的色彩盒子会显示得较灰一些，但不影响 ACES 色域着色。\n\n浮点渲染目标:开启色彩管理后，该选项也应该开启,才能在 Maya2020 中查看到正确的显示结果，并且应该使用32位格式，否则可能会出现色彩信息的裁剪，显示不正确，吸管吸取不到正确的色彩信息等情况。导出 CM 首选项：将自定义的色采管理首选项导出到指定的 CM 文件中，可用于软件启动的环境变量。\nNuke 中配置使用 ACES 色彩管理手动配置：\n仅为当前项目配置 ACES:\n打开软件后，按S键进行项目配置：点击 project setting >color栏，将\"color management\"修改为\"OCIO\",将COIO_config 修改为\"custom\", 然后将 OCIO 配置文件填入“custom_OCIO_config\"选项中（需保证Nuke中使用的 OCIO 配置文件和 MAYA 中使用的保持一致)或选择 Nuke 自带的 OCIO 配置文件，然后Nuke 即可自动设置部分常用的色彩空间编码设置。对于实拍源素材需要单独配置 Lut格式。\n\n  \n为 Nuke 默认启动配置 ACES\n为软件默认配置:\n1.打开Nuke首选项:选择 Color Management 选择 Nuke 自带的 OCIO 配置或使用自己的 OCIO 配置，即可为软件配置 ACES 色彩管理空间，重启软件即可生效。\n2.环境变量配置，启动环境中添加环境变量：OCIO = 文件位置\n\n\n\nNuke 输出sRGB素材对于使用EXR输出作为合成过程的中间素材，使用默认的 ACES 色域编码的exr格式文件，保持图片信息的完整，勾选\"输出保持ACES 兼容的EXR\"；输出序列时，则直接转回sRGB色域编码（使用output_srgb编码方式输出）\n\n\n\n\n\n\n相关软件插件下载链接Substance Painter插件滤镜：https://pan.baidu.com/s/1FFpBeih902gMJWVQrzEwbw 提取码: anqqOCIO配置文件下载地址：https://github.com/colour-science/OpenColorIO-Configs/tree/feature/aces-1.2-config\n","categories":["Maya","杂项"],"tags":["灯光","合成","ACES"]},{"title":"Maya获取选中相机视角中的所有对象","url":"/posts/20220228a1.html","content":"从Maya视图窗口中获取相机视角中所有的对象，可以利用OpenMaya和OpenMayaUI两个模块来完成此功能，首先需要指定相机，并通过遍历相机视口，来获取相机视口中的对象：\n\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n# @Auth0r: Mirror\n# @Time: ----\n# =========================================\n\nimport maya.cmds as cmds\nimport maya.OpenMaya as OpenMaya\nimport maya.OpenMayaUI as OpenMayaUI\n\n\ndef getObjInView(cam):\n    # 添加相机到 MDagPath\n    mdag_path = OpenMaya.MDagPath()\n    sel = OpenMaya.MSelectionList()\n    sel.add(cam)\n    sel.getDagPath(0, mdag_path)\n\n    # 遍历视口\n    draw_traversal = OpenMayaUI.MDrawTraversal()\n\n    # 创建视锥\n    draw_traversal.setFrustum(mdag_path, cmds.getAttr(\"defaultResolution.width\"),cmds.getAttr(\"defaultResolution.height\"))\n    draw_traversal.traverse()\n    frustum_objs = []\n\n    # Loop through obiects within frustum\n    for i in range(draw_traversal.numberOfItems()):\n        # 先返回shape, 所以需要先获取它的transforn\n        shape_dag_path = OpenMaya.MDagPath()\n        draw_traversal.itemPath(i, shape_dag_path)\n        transform_dag_path = OpenMaya.MDagPath()\n        OpenMaya.MDagPath.getAPathTo(shape_dag_path.transform(), transform_dag_path)\n        # 获取物体的长名并且确保它是有效的transform\n        obj = transform_dag_path.fullPathName()\n\n        if cmds.objExists(obj):\n            frustum_objs.append(obj)\n            cmds.select(frustum_objs)\n\n\nif __name__ == \"__main__\":\n    # 需要指定相机\n    cam = 'persp'  # 指定相机\n    getObjInView(cam) \n\n","categories":["Maya","杂项"],"tags":["OpenMaya"]},{"title":"Maya获取指定物体到Camera焦点平面的距离","url":"/posts/20220227a1.html","content":"文章介绍在Maya中获取物体到相机焦点所在平面的距离，并将获取到的距离写入相机的焦距属性，使用Arnold渲染。\n本文介绍两种获取相机焦距的方法提供参考：一种是利用向量计算的办法计算向量之间的投射长度获取焦距，另一种是使用约束的方式获取焦距。\n\n方法一：计算向量在三维空间中，已知相机单位向量、位置和物体坐标，可计算出相机焦点到物体的距离（该距离并非我们所要求的焦点平面到物体的距离），得到一个空间中存在的长方体，经过对物体和相机两点之间构成的向量投射到相机单位向量方向上的投影长度，即我们所求的相机焦点平面到物体的距离。如下图所示，空间中，我们需要获取线段ob之间的距离，其中线段oa之间的距离可根据相机和物体的坐标计算得出，相机法向量v可从相机中获取，由此我们可计算得出线段oa在向量v方向的投影。\n\n\n首先，我们需要通过xfrom方法获取相机的法向量：\n\nCam = mc.xform(cam.name(), q=True, ws=True, m=True)[8:11]  # 数组第8到第10位为相机法向量\nCam_vector = np.array(Cam) * -1   # 由于取出的数据是列表，这里需要转换成向量再取反，即为相机单位向量方向\n\n\n获取相机的坐标和物体的坐标，计算得出向量oa：\n\ndef getVector(locatorP, camP):\n    \"\"\"计算向量坐标\n        locatorP: 物体坐标\n        camP：相机坐标\n    \"\"\"\n    newVector = (locatorP[0] - camP[0], locatorP[1] - camP[1], locatorP[2] - camP[2])\n    return newVector\n\n\n由于需要区分向量之间的夹角，若为锐角，焦距为正，反之为负：\n\ndef judgeAngle(_ang):\n    \"\"\"计算向量角度为锐角还是钝角\"\"\"\n    _flag = (_ang * 180.0) / pi\n    print(u\"向量间的角度为: %s 度(角度制)\" % _flag)\n    if (_flag > 90) and (_flag &lt;= 180):\n        return -1\n    elif (_flag &lt; 90) and (_flag >= 0):\n        return 1\n    elif _flag == 90:\n        return 0\n\n\n使用上面获得的数据，即可求出相机焦点平面到物体的距离。以下为工具完整脚本：\n\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n# @Author: MirrorCG\n# @Time: 2021/12/28\n# =========================================\nimport maya.cmds as mc\nimport pymel.core as pm\nimport maya.mel as mel\nfrom math import pi, cos\nimport numpy as np\n\n\ndef getVector(locatorP, camP):\n    \"\"\"计算向量坐标\"\"\"\n    newVector = (locatorP[0] - camP[0], locatorP[1] - camP[1], locatorP[2] - camP[2])\n    return newVector\n\n\ndef squareRVector(_vector):\n    \"\"\"计算平方根，向量长度\"\"\"\n    AB = (_vector[0] * _vector[0] + _vector[1] * _vector[1] + _vector[2] * _vector[2]) ** 0.5\n    return AB\n\n\ndef judgeAngle(_ang):\n    \"\"\"计算向量角度为锐角还是钝角\"\"\"\n    _flag = (_ang * 180.0) / pi\n    print(u\"向量间的角度为: %s 度(角度制)\" % _flag)\n    if (_flag > 90) and (_flag &lt;= 180):\n        return -1\n    elif (_flag &lt; 90) and (_flag >= 0):\n        return 1\n    elif _flag == 90:\n        return 0\n\n\ndef getCam(camName):\n    \"\"\"获取选中的相机，填入窗口\"\"\"\n    try:\n        cam = pm.ls(sl=True)[0].getChildren()[0]  # 选择相机\n    except IndexError as e:\n        mc.warning(u\"未选中对象\")\n        return\n    if (not cam) or (cam.nodeType() != \"camera\"):\n        mc.warning(u\"未选中相机\")\n        return\n    _camName = cam.longName()\n    mc.textField(camName, e=True, tx=_camName)\n\n\ndef createLocator(locName, camName):\n    \"\"\"创建/获取locator,移动至相机位置，并将改1ocator填入窗口中\"\"\"\n    try:\n        cam = pm.ls(mc.textField(camName, q=True, tx=True))[0].getParent()\n    except IndexError as e:\n        mc.warning(u\"请选择并添加相机\")\n        return\n    camP = cam.getTranslation().get()  # 相机坐标\n    if mc.objExists(\"find_focous\") and pm.nodeType(pm.ls(\"find_focous\")[0].getChildren()[0]) == \"locator\":\n        loc = pm.ls(\"find_focous\")[0]\n    else:\n        loc = pm.createNode(\"locator\").getParent()\n        loc.rename(\"find_focous\")\n    loc.setAttr(\"translate\", camP)\n    mc.textField(locName, e=True, tx=loc.name())\n\n\ndef getInstance(instName, camName, locName, *args):\n    \"\"\"计算焦距，判断距离方向\"\"\"\n    if (not mc.textField(camName, q=True, tx=True)) or (not mc.textField(locName, q=True, tx=True)):\n        mc.warning(u\"请填入相机或locator(`find_focous`)\")\n        return\n    cam = pm.ls(mc.textField(camName, q=True, tx=True))[0].getParent()\n    camP = cam.getTranslation().get()\n    loc = pm.ls(mc.textField(locName, q=True, tx=True))[0]\n    cam_vector = np.array(mc.xform(cam.name(), q=True, ws=True, m=True)[8:11]) * -1  # 获取相机单位向量(从maya获取的向量需要取反\n    locatorP = loc.getAttr(\"translate\")  # 定位器坐标\n    AB_vector = getVector(locatorP, camP)\n    AB = squareRVector(AB_vector)  # 定位器距离相机距离\n    print(u\"定位器距离相机: %s 个单位\" % AB)\n    x = np.array(cam_vector)\n    y = np.array(AB_vector)\n    lx = np.sqrt(x.dot(x))\n    ly = np.sqrt(y.dot(y))\n    cos_angle = x.dot(y) / (lx * ly)\n    _angle = np.arccos(cos_angle)\n    _flag = judgeAngle(_angle)\n    if AB == 0:\n        focus = 0.1\n    else:\n        focus = abs(cos(_angle) * AB)\n    if _flag == 1:\n        pass\n    elif _flag == -1:\n        focus = (-1 * focus)\n    elif _flag == 0:\n        focus = 0.1\n    print(u\"相机焦距为: %s 个单位\" % focus)\n    mc.textField(instName, e=True, tx=\"%s\" % focus)\n    try:\n        cam.setAttr(\"focusDistance\", focus)\n    except RuntimeError as e:\n        print(u\"焦距小于默认最小值,设定为0.1\")\n    cam.setAttr(\"focusDistance\", 0.1)\n    print(\"=\" * 40)\n\n\ndef toolDoc(winName):\n    \"\"\"工具帮助\"\"\"\n    win_name = u\"工具帮助\"\n    if mc.window(win_name, q=True, ex=True):\n        mc.deleteUI(win_name, window=True)\n    helpWin= mc.window(u\"工具帮助\", t=u\"工具帮助\", wh=(700, 70), p=winName)\n    mc.paneLayout()\n    mc.textScrollList(\"line\",\n                      append=[u\"1.选择相机：先选择要测量焦距的相机，再点击按钮(相机名可以手动填入，但相机名为长名，防止错误选择相机)\",\n                              u\"2.创建locator：点击后创建定位器，或手动填入已有的locator(默认创建的1ocator为'find_focous',手动填入不用点击)\",\n                              u\"3.计算焦距按钮：先移动调整好位置的1ocator，点击'移动locator，计算焦距'按钮，即可测出想要的焦距\",\n                              u\"4.帮 助：本工具的使用说明\"])\n    mc.textScrollList(\"line\", edit=True, lf=[(1, \"fixedWidthFont\"), (2, \"fixedWidthFont\"), (3, \"fixedWidthFont\"), (4, \"fixedWidthFont\")])\n    mc.showWindow(helpWin)\n\n\nif __name__ == \"__main__\":\n    win_name = u\"测量相机焦距\"\n    if mc.window(win_name, q=True, ex=True):\n        mc.deleteUI(win_name, window=True)\n    win = mc.window(win_name, title=u\"测量相机焦距\", iconName=u\"Short_Name\", widthHeight=(400, 110))\n    mc.columnLayout(adjustableColumn=True, rs=2)\n    mc.rowColumnLayout(numberOfColumns=3, columnAttach=(1, \"right\", 0), columnWidth=[(1, 60), (2, 240), (3, 100)])\n    mc.text(label=u'相 机 名:', align='left')\n    camName = mc.textField()\n    mc.button(label=u'选择相机', command=\"getCam(camName)\")\n    mc.setParent('..')\n    mc.rowColumnLayout(numberOfColumns=3, columnAttach=(1, 'right', 0), columnWidth=[(1, 60), (2, 240), (3, 100)])\n    mc.text(label=u'locator: ', align='left')\n    locName = mc.textField()\n    mc.button(label=u'创建1ocator', command=\"createLocator(locName,camName)\")\n    mc.setParent('..')\n    mc.button(label=u\"移动locator,计算距离\", command=\"getInstance(instName, camName, 1ocName)\", bgc=(1, 0.73, 0.14))\n    mc.rowColumnLayout(numberOfColumns=4, columnAttach=(1, 'right', 0), columnWidth=[(1, 60), (2, 200), (3, 100), (4, 40)])\n    mc.text(label=u'焦  距:', align='left')\n    instName = mc.textField(ed=False, bgc=(0.64, 0.79, 10.48))\n    mc.text(label=u\" \", align='left')\n    mc.button(label=u'帮助', command=\"toolDoc(win)\")\n    mc.setParent(\"..\")\n    mc.setParent(\"..\")\n    mc.showWindow(win)\n\n\n若要动态获取相机焦距，可将下面的脚本修改后填入相机属性的表达式中。\n\nvector $camP = `getAttr camera1.translate`; //相机坐标\nfloat $camVct[16] = `xform -q -m -ws camera1`; //相机世界空间矩阵\nvector $camVector = &lt;&lt;$camVct [8],$camVct[9],$camVct [10]>>*-1;  //从maya中获取的相机向量，需要取反\nvector $locP = `getAttr find_focous.translate`;\nvector $lcInstance = $locP - $camP;\nfloat $inst = mag($locP - $camP); //物体距离相机的距离\nfloat $_angle = angle($camVector,$lcInstance); //向量间的夹角\nfloat $_focus = cos($_angle)*$inst; //焦距\nfloat $flag = ($_angle*180)/3.141592657;\nif ($flag >= 90)\n&#123;\n    $focus = 0.1;\n&#125;\nprint $_focus;\ncameraShape1.focusDistance = $_focus;\n\n\n\n方法二：添加约束在相机位置创建两个定位器：其中一号定位器p到相机上，使用二号定位器约束一号定位器的Z轴，并设置Z轴数值的最大值（因为方向是反的，所以设置最大值，可以自己尝试一下），将二号定位器移动到物体的位置并添加约束，此时，一号定位器的Z轴数值即是相机焦距，将此属性连接到相机的aifocus属性即可动态获取相机焦距，如下图所示：\n\n\n约束工具如下：\n\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n# @Auth0r: MirrorCG\n# @Time: 2021/12/28\n# =========================================\n\nimport maya.cmds as mc\nimport pymel.core as pm\n\n\nclass getDistance():\n    def __init__(self):\n        win_name = u\"测量相机焦距\"\n        if mc.window(win_name, q=True, ex=True):\n            mc.deleteUI(win_name, window=True)\n        self.win = mc.window(win_name, title=u\"测量相机焦距\", iconName=u'short Name', widthHeight=(400, 120))\n        mc.columnLayout(adjustableColumn=True, rs=2)\n        mc.rowColumnLayout(numberOfColumns=3, columnAttach=(1, 'right', 0), columnWidth=[(1, 60), (2, 240), (3, 100)])\n        mc.text(label=u\"相 机 名:\", align='left')\n        self.camName = mc.textField()\n        mc.button(label=u\"选择相机\", command=lambda x: self.getCam(self.camName))\n        mc.setParent('..')\n        mc.rowColumnLayout(numberOfColumns=3, columnAttach=(1, 'right', 0), columnWidth=[(1, 60), (2, 240), (3, 100)])\n        mc.text(label=u\"locator:\", align='left')\n        self.locName = mc.textField()\n        mc.button(label=u\"创建locator\", command=lambda x: self.createLocators(self.locName))\n        mc.setParent(\"..\")\n        mc.rowColumnLayout(numberOfColumns=3, columnWidth=[(1, 180), (2, 40), (3, 180)])\n        mc.button(label=u\"约束到选择的物体\", command=lambda x: self.addCtrlWithObj(), bgc=(1, 0.73, 0.14))\n        mc.text(label=u' ', align='right')\n        mc.button(label=u\"清除产生的对象\", command=lambda x: self.cleanAll(), bgc=(1, 0.73, 0.14))\n        mc.setParent(\"..\")\n        mc.rowColumnLayout(numberOfColumns=2, columnAttach=(1, 'right', 0), columnWidth=[(1, 360), (2, 40)])\n        mc.text(label=u' ' * 8, align='left')\n        mc.button(label=u\"帮助\", command=lambda x: self.toolDoc())\n        mc.setParent('..')\n        mc.setParent('..')\n        mc.showWindow(self.win)\n\n    def getCam(self, *args):\n        \"\"\"获取选中的相机，填入窗口\"\"\"\n        try:\n            cam = pm.ls(sl=True)[0].getChildren()[0]  # 选择相机\n        except IndexError as e:\n            mc.warning(u\"未选中对象\")\n            return\n        if (not cam) or (cam.nodeType() != \"camera\"):\n            mc.warning(u\"未选中相机\")\n            return\n        _camName = cam.longName()\n        mc.textField(self.camName, e=True, tx=_camName)\n\n    def connectParm(self, loc_a):\n        \"\"\"连接相机属性\"\"\"\n        cam = pm.ls(mc.textField(self.camName, q=True, tx=True))[0]\n        # cam.setAttr(\"aiEnableDOF\",1)\n        node_name = \"distance_data\"\n        if mc.objExists(node_name):\n            mc.delete(node_name)\n        mc.createNode(\"floatMath\", n=node_name)\n        mc.setAttr(node_name + \".operation\", 2)\n        mc.setAttr(node_name + \".floatB\", -1)\n        mc.connectAttr(loc_a.name() + \".translateZ\", node_name + \".floatA\", f=True)\n        mc.connectAttr(node_name + \".outFloat\", cam.name() + \".aiFocusDistance\", f=True)\n\n    def addCtrl(self, loc_m, loc_a):\n        \"\"\"m添加约束和设置可见性\"\"\"\n        cam = mc.textField(self.camName, q=True, tx=True)\n        mc.parent(loc_a.name(), cam)\n        mc.transformLimits(loc_a.name(), tz=(-1, -0.02), etz=(0, 1))\n        mc.setAttr(loc_a.fullPath() + \".visibility\", 0)\n        mc.setAttr(loc_a.fullPath() + \".visibility\", lock=True)\n\n        mc.parentConstraint(loc_m.name(), loc_a.name(), mo=True, st=[\"x\", \"y\"], sr=[\"x\", \"y\", \"z\"])\n\n    def createLocators(self, *args):\n        \"\"\"创建 / 获取1ocator, 移动至相机位置，并将该主1ocator填入窗口中\"\"\"\n        try:\n            cam = pm.ls(mc.textField(self.camName, q=True, tx=True))[0].getParent().fullPath()\n        except IndexError as e:\n            mc.warning(u\"请选择并添加正确的相机\")\n            return\n        cam_p = mc.xform(cam, q=True, ws=True, t=True)  # 相机世界坐标\n        if mc.objExists(\"find_focus\"):  # 用于移动的locator\n            loc_m = pm.ls(\"find_focus\")[0]\n            pm.delete(loc_m)\n        loc_m = pm.createNode(\"locator\").getParent()\n        loc_m.rename(\"find_focus\")\n\n        if mc.objExists(\"cam_center\"):\n            loc_a = pm.ls(\"cam_center\")[0]\n            pm.delete(loc_a)\n        loc_a = pm.createNode(\"locator\").getParent()\n        loc_a.rename(\"cam_center\")\n\n        loc_m.setAttr(\"translate\", cam_p)\n        loc_a.setAttr(\"translate\", cam_p)\n        mc.textField(self.locName, e=True, tx=loc_m.name())\n\n        self.addCtrl(loc_m, loc_a)  # 添加约束和设置可见性\n        self.connectParm(loc_a)\n\n    def addCtrlWithObj(self, *args):\n        \"\"\"约束到物体\"\"\"\n        try:\n            loc_m = pm.ls(mc.textField(self.locName, q=True, tx=True))[0].fullPath()\n        except IndexError as e:\n            mc.warning(u\"未创建或填入定位器\")\n            return\n        obj = \"\"\n        for i in mc.ls(sl=True):\n            if \"find focus\" not in i:\n                obj = i\n                break\n            continue\n        if not obj:\n            mc.warning(u\"未选择约束物体，或约束物体名称中含有'find_focus'字符串\")\n        mc.parentConstraint(obj, loc_m, mo=True, sr=[\"x\", \"y\", \"z\"])\n\n    def cleanAll(self, *arqs):\n        \"\"\"清除本工具产生的所有节点\"\"\"\n        node_list = [\"distance_data\", \"find_focus\", \"cam_center\"]\n        for i in node_list:\n            if mc.objExists(i):\n                mc.delete(i)\n\n    def toolDoc(self):\n        \"\"\"工具帮助\"\"\"\n        win_name = u\"工具帮助\"\n        if mc.window(win_name, q=True, ex=True):\n            mc.deleteUI(win_name, window=True)\n        help_win = mc.window(u\"工具帮助\", t=u\"工具帮助\", wh=(640, 100), p=self.win)\n        mc.paneLayout()\n        mc.textScrollList(\"line\", append=[u\"1.选择相机:先选择要测量焦距的相机，再点击按钮(相机名可以手动填入，但相机名为长名，防止错误选择相机)\",\n                                          u\"2,创建locator:点击后，在相机处创建定位器，创建的1ocator名称为'find focous'\",\n                                          u\"3.约束到选择物体:先调整好locator(find focous)的位置，选择约束物体，点击'约束到选择物体'，即测出想要的焦距，属性将自动连接\",\n                                          u\"4.清除对象，清除本工具产生的相关节点\", u\"5.帮助:本工具的使用说明\"])\n        mc.textScrollList(\"line\", edit=True, lf=[(1, \"fixedWidthFont\"), (2, \"fixedWidthFont\"), (3, \"fixedWidthFont\"),\n                                                 (4, \"fixedWidthFont\"), (5, \"fixedWidthFont\")])\n\n        mc.showWindow(help_win)\n\n\nif __name__ == \"__main__\":\n    tool = getDistance()\n\n\n\n","categories":["Maya","小工具"],"tags":["灯光","向量计算"]},{"title":"关于Aitoon材质灯光分层的探索","url":"/posts/20220226a2.html","content":"起因前段时间，开始对在 Maya 中进行三渲二的渲染分层有了兴趣。于是，我就尝试自己探索一下：在 Maya 中使用 Aitoon 材质进行三渲二的灯光分层，以及在 Nuke中进行合成的流程。现在的三渲二影视作品普遍采用亮面、暗面加边缘光的方式进行灯光分层，部分镜头需要以亮面、灰面和暗面加边缘光的方式进行灯光分层，灯光师仅完成灯光角度的设计即可，最终画面氛围和效果需要合成师完成，这种分层方式使用aitoon材质球可以很容易地完成。\n\n测试环境:maya 2018.5+Arnold 6.0.1.0测试角色:不要钱的派大星\n一. 材质相关前期部门仅制作卡通材质，不需要在材质球中为rim、highlight 指定灯光。材质球的base 权重需要设定为1（下图1），关闭材质的能量守恒选项和间接反射（下图2），材质的baseTonemap属性都链接ramp节点并保持只有两个点。调节材质、线框效果与贴图的阴影融合等步骤需要前期部门调整到最终效果。如果做了材质阴影融合，材质部门需要提供另一套只带有阴影贴图的 aimatte 材质球用于切换，供灯光部门渲染阴影通道使用。\n\n\n\n\n\n二．灯光环节流程1.灯光使用要求\n\n由于卡通材质的特殊性，灯光渲染需要至少一盏光源即可区分亮暗，根据官方介绍虽然 aitoon 材质并不挑剔灯光类型，但由于面光源和skydome等灯光的性质，可能会导致受光面的强度大于1，从而导致莫名的错误，灯光的要求使用平行光、点光源或者聚光灯，并且这三种光源对于风格化高光的形成效果较好，可控性更高。\n    2.Aov及渲染分层\n通过对aitoon材质的渲染，我们可以获取Arnold提供的所有的Aov通道，但由于aitoon材质球并非基干物理的材质球，并不能按照LPE的方式进行分层，传统的分成方式需要考虑灯光的强度和颜色对贴图的影响以及材质之间的影响，而卡通渲染并不计算diffuse的灯光颜色信息，因此我们可以采用diffusealbedo+主光照射范围+暗部颜色+平面反射+透射的方式进行分层，此方法能保持合成的可调性的同时也最大限度保留了材质的效果。通过读取模型的材质信息，给模型添加附加属性，用aiuserdata节点传递已经记录的每个模型的材质球信息，即可确认模型被灯光照射的亮暗面的范围，最终输出通道，具体方式如下：\n    (1)主光照射范围+暗部颜色\n给每一个材质为aitoon的物体添加Arnold额外属性(color1,color2.pos1,pos2.interpolation)用于记录数据（下图左一），该属性记录材质球的basetonemap中ramp 的信息（下图右一），其中颜色数据使用vector类型 ，位置数据使用float类型，ramp的过度类型使用int类型，这三种类型分别可对应用户数据节点的 aiUserDataColor、aiUserDataFloat、aiUserDatalnt。\n\n\n\n\n以 toon_key 为例创建自定义 aov（下图左一），通过创建自定义的aov，将aov色器选择为新创建的 aitoon 卡通材质球 关闭该aitoon 材质球的能量守恒，边缘，高光。将basecolor调为1，并给basetonemap链接一个默认的ramp节点。创建2个aiUserDataColor2个aiUserDataFloat1个aiUserDatalnt节点，并将color1、color2分别填入aiUserDataColor，pos1、pos2分别填入aiUserDataFloat，interpolation填入aiUserDatalnt，将五个节点链接到上一步的ramp中即可渲染出，所需要的包含有灯光照射的两部范围信息的aov，该aov的色彩信息为仅为灯光照射的亮面（toon_key）(不含材质信息)，以此类推，可获得暗面的颜色（toon_env），渲染出的aov（下图右一）\n\n\n\n\n至此，我们获得需要的灯光层，该灯光层保留材质的 ramp 亮暗面信息和亮暗部区域(非aitoon 材质渲染为黑色。\n    (2) Diffuse abedle、高光和透射\n材质本身的高光和透射可利用maya自身的aov输出，分别为specular direct、specular indirect，transmission direct， transmission indirect。\n    (3) edge\n物体的边缘线输出，需要通过自定义edge aov进行输出，需要将aov的filter设定为 contour类型否则渲染不出线框（如下图）。\n\n\n\n\n    (4) 边缘光和风格化高光\n为了便于调节，aitoon材质的rim边缘光和风格化高光可通过单独分层并对层中的物体进行材质覆盖的方式进行提取aov，单独分层也有利于控制效果。\n    (5) 其他需要的aov\n除上述aov外,其他一些aov可根据需求添加，本文考虑使用的辅助aov包括:N、 fresnel、OCC、RBzd、P、crypto_matte(三种)、direct和indirect 可在含有非aitoon材质时输出，用于调整非aitoon材质物体。\n    (6)文件分层\n文件的分层方式通过maya的renderSetup分层方式进行分层，最后以模板的形式导出渲染层，供流程使用。使用render Setup的方 式分层可以很方便地对模型进行材质覆盖、属性覆盖和导出自定义aov的操作，以边光和风格化层高光为例，为保持物体边缘光的统一性，需要整体赋予一个aitoon材质球，用于调整边缘光效果;而材质球的边缘光和风格化高光属性是没有填入对应灯光的shape名称的，因此可以在覆盖材质或者属性的基础上，统一给相关的模型覆盖属性或材质球，达到渲染效果。\n\n三．合成通过上面的方法，我们可以得到合成所需要的aov，通过合成树即可还原灯光渲染的效果（合成树中的图片不是本例的图片，此处仅做示范），并在此基础上由合成师进行环境氛围和灯光效果的调整即可（如下图）。\n\n\n\n\n\n四．写在最后此方法按照aitoon材质球的非基于物理渲染的特性，以basetonemap的ramp与贴图相乘得出最终颜色信息的特点，进行aov分层;它相对于单纯使用aitoon材质球对物体进行材质覆盖的方式进行亮暗部区分的优点在于，不以单一的材质覆盖的亮暗部过度信息、能更准确地保留材质的亮暗部范围和过度方式、能分别获取到材质的亮暗部rgb信息。相对于传统基于物理的分层方式，能单独调整亮暗面颜色信息，由于三渲二不能在灯光中处理氛围，此方式在合成中可调性更高。\n\n注意：在输出AOV通道时，若自定义的AOV和Arnold渲染器自带的AOV一起渲染出图时，会导致Arnold渲染器自带的Aov渲染错误，不渲染出正确的信息，因此，自定义的AOV需要单独分层渲染。\n","categories":["Maya","arnold"],"tags":["灯光","Aitoon","aiUserData"]},{"title":"博客文章语法示例","url":"/posts/20220220a2.html","content":"这是文章摘要 ，下面是废话\n文件最上方以 — 分隔的区域称为”Front_matter”\n第一章首行缩进\n内容\n\n这是引用块\nNEW: DevDocs now comes with syntax highlighting. http://devdocs.io\n@DevDocswww.baidu.com\n\n这是文字链接\n下载git\n\n这是代码块\nalert(&#39;Hello World!&#39;);\n\n[rectangle setX: 10 y: 10 width: 20 height: 20];\n\nArray.maparray.map(callback[, thisArg])\n\n_.compactUnderscore.js_.compact([0, 1, false, 2, &#39;&#39;, 3]);\n&#x3D;&gt; [1, 2, 3]\n\n这是反引号代码块 [1, 2, 3] 标题  https://www.baidu.com 百度地址 code snippet array.map(callback[, thisArg])\npull quote\ncontentsssssssss\n\n\n这是jsFiddle(jsFiddle是一个在线的shell编辑器)\n\n\n在文章中插入指定大小的图片\n\n  \nhtml支持的使用表放置图片的方式\n\n\n\n\n\n\n这是视频\n\n这是文本引用\nPost not found: hexo-4-released How to use  tag in title\n\n这是数据引用&lt;% for (var link in site.data.menu) { %&gt;  <a href=\"\"> &lt;%&#x3D; link %&gt; &lt;% } %&gt;\n\n第二章内容\n\n参考文献www.codesheep.cn\n\n\n\n\n\nvar gitalk = new Gitalk({\n    id: '',\n    clientID: '',\n    clientSecret: '',\n    repo: 'gitalk',\n    owner: 'JairusTse',\n    admin: ['JairusTse'],\n    labels: ['Gitalk'],\n    perPage: 50\n})\ngitalk.render('gitalk-container')\n\n","categories":["Doc","学习笔记"],"tags":["Blog","Markdown"]},{"title":"Hexo文档","url":"/posts/20220220a1.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Doc"],"tags":["Blog","Hexo"]}]